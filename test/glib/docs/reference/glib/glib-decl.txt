<MACRO>
<NAME>alloca</NAME>
# define alloca(size)   __builtin_alloca (size)
</MACRO>
<MACRO>
<NAME>g_alloca</NAME>
#define g_alloca(size)		 alloca (size)
</MACRO>
<MACRO>
<NAME>g_newa</NAME>
#define g_newa(struct_type, n_structs)	((struct_type*) g_alloca (sizeof (struct_type) * (gsize) (n_structs)))
</MACRO>
<STRUCT>
<NAME>GArray</NAME>
struct _GArray
{
  gchar *data;
  guint len;
};
</STRUCT>
<STRUCT>
<NAME>GByteArray</NAME>
struct _GByteArray
{
  guint8 *data;
  guint	  len;
};
</STRUCT>
<STRUCT>
<NAME>GPtrArray</NAME>
struct _GPtrArray
{
  gpointer *pdata;
  guint	    len;
};
</STRUCT>
<MACRO>
<NAME>g_array_append_val</NAME>
#define g_array_append_val(a,v)	  g_array_append_vals (a, &(v), 1)
</MACRO>
<MACRO>
<NAME>g_array_prepend_val</NAME>
#define g_array_prepend_val(a,v)  g_array_prepend_vals (a, &(v), 1)
</MACRO>
<MACRO>
<NAME>g_array_insert_val</NAME>
#define g_array_insert_val(a,i,v) g_array_insert_vals (a, i, &(v), 1)
</MACRO>
<MACRO>
<NAME>g_array_index</NAME>
#define g_array_index(a,t,i)      (((t*) (void *) (a)->data) [(i)])
</MACRO>
<FUNCTION>
<NAME>g_array_new</NAME>
<RETURNS>GArray * </RETURNS>
gboolean          zero_terminated, gboolean          clear_, guint             element_size
</FUNCTION>
<FUNCTION>
<NAME>g_array_sized_new</NAME>
<RETURNS>GArray * </RETURNS>
gboolean          zero_terminated, gboolean          clear_, guint             element_size, guint             reserved_size
</FUNCTION>
<FUNCTION>
<NAME>g_array_free</NAME>
<RETURNS>gchar *  </RETURNS>
GArray           *array, gboolean          free_segment
</FUNCTION>
<FUNCTION>
<NAME>g_array_ref</NAME>
<RETURNS>GArray  *</RETURNS>
GArray           *array
</FUNCTION>
<FUNCTION>
<NAME>g_array_unref</NAME>
<RETURNS>void     </RETURNS>
GArray           *array
</FUNCTION>
<FUNCTION>
<NAME>g_array_get_element_size</NAME>
<RETURNS>guint    </RETURNS>
GArray           *array
</FUNCTION>
<FUNCTION>
<NAME>g_array_append_vals</NAME>
<RETURNS>GArray * </RETURNS>
GArray           *array, gconstpointer     data, guint             len
</FUNCTION>
<FUNCTION>
<NAME>g_array_prepend_vals</NAME>
<RETURNS>GArray * </RETURNS>
GArray           *array, gconstpointer     data, guint             len
</FUNCTION>
<FUNCTION>
<NAME>g_array_insert_vals</NAME>
<RETURNS>GArray * </RETURNS>
GArray           *array, guint             index_, gconstpointer     data, guint             len
</FUNCTION>
<FUNCTION>
<NAME>g_array_set_size</NAME>
<RETURNS>GArray * </RETURNS>
GArray           *array, guint             length
</FUNCTION>
<FUNCTION>
<NAME>g_array_remove_index</NAME>
<RETURNS>GArray * </RETURNS>
GArray           *array, guint             index_
</FUNCTION>
<FUNCTION>
<NAME>g_array_remove_index_fast</NAME>
<RETURNS>GArray * </RETURNS>
GArray           *array, guint             index_
</FUNCTION>
<FUNCTION>
<NAME>g_array_remove_range</NAME>
<RETURNS>GArray * </RETURNS>
GArray           *array, guint             index_, guint             length
</FUNCTION>
<FUNCTION>
<NAME>g_array_sort</NAME>
<RETURNS>void     </RETURNS>
GArray           *array, GCompareFunc      compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_array_sort_with_data</NAME>
<RETURNS>void     </RETURNS>
GArray           *array, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_array_set_clear_func</NAME>
<RETURNS>void     </RETURNS>
GArray           *array, GDestroyNotify    clear_func
</FUNCTION>
<MACRO>
<NAME>g_ptr_array_index</NAME>
#define    g_ptr_array_index(array,index_) ((array)->pdata)[index_]
</MACRO>
<FUNCTION>
<NAME>g_ptr_array_new</NAME>
<RETURNS>GPtrArray * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_new_with_free_func</NAME>
<RETURNS>GPtrArray * </RETURNS>
GDestroyNotify    element_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_sized_new</NAME>
<RETURNS>GPtrArray * </RETURNS>
guint             reserved_size
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_new_full</NAME>
<RETURNS>GPtrArray * </RETURNS>
guint             reserved_size, GDestroyNotify    element_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_free</NAME>
<RETURNS>gpointer *  </RETURNS>
GPtrArray        *array, gboolean          free_seg
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_ref</NAME>
<RETURNS>GPtrArray * </RETURNS>
GPtrArray        *array
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_unref</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_set_free_func</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array, GDestroyNotify    element_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_set_size</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array, gint              length
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove_index</NAME>
<RETURNS>gpointer    </RETURNS>
GPtrArray        *array, guint             index_
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove_index_fast</NAME>
<RETURNS>gpointer    </RETURNS>
GPtrArray        *array, guint             index_
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove</NAME>
<RETURNS>gboolean    </RETURNS>
GPtrArray        *array, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove_fast</NAME>
<RETURNS>gboolean    </RETURNS>
GPtrArray        *array, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove_range</NAME>
<RETURNS>GPtrArray  *</RETURNS>
GPtrArray        *array, guint             index_, guint             length
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_add</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_insert</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array, gint              index_, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_sort</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array, GCompareFunc      compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_sort_with_data</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_foreach</NAME>
<RETURNS>void        </RETURNS>
GPtrArray        *array, GFunc             func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_find</NAME>
<RETURNS>gboolean    </RETURNS>
GPtrArray        *haystack, gconstpointer     needle, guint            *index_
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_find_with_equal_func</NAME>
<RETURNS>gboolean    </RETURNS>
GPtrArray     *haystack, gconstpointer  needle, GEqualFunc     equal_func, guint         *index_
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_new</NAME>
<RETURNS>GByteArray * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_new_take</NAME>
<RETURNS>GByteArray * </RETURNS>
guint8           *data, gsize             len
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_sized_new</NAME>
<RETURNS>GByteArray * </RETURNS>
guint             reserved_size
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_free</NAME>
<RETURNS>guint8 *     </RETURNS>
GByteArray       *array, gboolean          free_segment
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_free_to_bytes</NAME>
<RETURNS>GBytes *     </RETURNS>
GByteArray       *array
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_ref</NAME>
<RETURNS>GByteArray  *</RETURNS>
GByteArray       *array
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_unref</NAME>
<RETURNS>void         </RETURNS>
GByteArray       *array
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_append</NAME>
<RETURNS>GByteArray * </RETURNS>
GByteArray       *array, const guint8     *data, guint             len
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_prepend</NAME>
<RETURNS>GByteArray * </RETURNS>
GByteArray       *array, const guint8     *data, guint             len
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_set_size</NAME>
<RETURNS>GByteArray * </RETURNS>
GByteArray       *array, guint             length
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_remove_index</NAME>
<RETURNS>GByteArray * </RETURNS>
GByteArray       *array, guint             index_
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_remove_index_fast</NAME>
<RETURNS>GByteArray * </RETURNS>
GByteArray       *array, guint             index_
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_remove_range</NAME>
<RETURNS>GByteArray * </RETURNS>
GByteArray       *array, guint             index_, guint             length
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_sort</NAME>
<RETURNS>void         </RETURNS>
GByteArray       *array, GCompareFunc      compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_sort_with_data</NAME>
<RETURNS>void         </RETURNS>
GByteArray       *array, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<STRUCT>
<NAME>GBytes</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_async_queue_new</NAME>
<RETURNS>GAsyncQueue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_new_full</NAME>
<RETURNS>GAsyncQueue  *</RETURNS>
GDestroyNotify item_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_lock</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_unlock</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_ref</NAME>
<RETURNS>GAsyncQueue  *</RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_unref</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_ref_unlocked</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_unref_and_unlock</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push_unlocked</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push_sorted</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, gpointer          data, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push_sorted_unlocked</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, gpointer          data, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_pop</NAME>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_pop_unlocked</NAME>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_try_pop</NAME>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_try_pop_unlocked</NAME>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_timeout_pop</NAME>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue, guint64           timeout
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_timeout_pop_unlocked</NAME>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue, guint64           timeout
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_length</NAME>
<RETURNS>gint          </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_length_unlocked</NAME>
<RETURNS>gint          </RETURNS>
GAsyncQueue      *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_sort</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_sort_unlocked</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_remove</NAME>
<RETURNS>gboolean      </RETURNS>
GAsyncQueue      *queue, gpointer          item
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_remove_unlocked</NAME>
<RETURNS>gboolean      </RETURNS>
GAsyncQueue      *queue, gpointer          item
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push_front</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, gpointer          item
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push_front_unlocked</NAME>
<RETURNS>void          </RETURNS>
GAsyncQueue      *queue, gpointer          item
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_timed_pop</NAME>
<DEPRECATED/>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue, GTimeVal         *end_time
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_timed_pop_unlocked</NAME>
<DEPRECATED/>
<RETURNS>gpointer      </RETURNS>
GAsyncQueue      *queue, GTimeVal         *end_time
</FUNCTION>
<STRUCT>
<NAME>GAsyncQueue</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_atomic_int_get</NAME>
<RETURNS>gint                     </RETURNS>
const volatile gint *atomic
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_set</NAME>
<RETURNS>void                     </RETURNS>
volatile gint  *atomic, gint            newval
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_inc</NAME>
<RETURNS>void                     </RETURNS>
volatile gint  *atomic
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_dec_and_test</NAME>
<RETURNS>gboolean                 </RETURNS>
volatile gint  *atomic
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_compare_and_exchange</NAME>
<RETURNS>gboolean                 </RETURNS>
volatile gint  *atomic, gint            oldval, gint            newval
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_add</NAME>
<RETURNS>gint                     </RETURNS>
volatile gint  *atomic, gint            val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_and</NAME>
<RETURNS>guint                    </RETURNS>
volatile guint *atomic, guint           val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_or</NAME>
<RETURNS>guint                    </RETURNS>
volatile guint *atomic, guint           val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_xor</NAME>
<RETURNS>guint                    </RETURNS>
volatile guint *atomic, guint           val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_pointer_get</NAME>
<RETURNS>gpointer                 </RETURNS>
const volatile void *atomic
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_pointer_set</NAME>
<RETURNS>void                     </RETURNS>
volatile void  *atomic, gpointer        newval
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_pointer_compare_and_exchange</NAME>
<RETURNS>gboolean                 </RETURNS>
volatile void  *atomic, gpointer        oldval, gpointer        newval
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_pointer_add</NAME>
<RETURNS>gssize                   </RETURNS>
volatile void  *atomic, gssize          val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_pointer_and</NAME>
<RETURNS>gsize                    </RETURNS>
volatile void  *atomic, gsize           val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_pointer_or</NAME>
<RETURNS>gsize                    </RETURNS>
volatile void  *atomic, gsize           val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_pointer_xor</NAME>
<RETURNS>gsize                    </RETURNS>
volatile void  *atomic, gsize           val
</FUNCTION>
<FUNCTION>
<NAME>g_atomic_int_exchange_and_add</NAME>
<DEPRECATED/>
<RETURNS>gint                     </RETURNS>
volatile gint  *atomic, gint            val
</FUNCTION>
<FUNCTION>
<NAME>g_on_error_query</NAME>
<RETURNS>void  </RETURNS>
const gchar *prg_name
</FUNCTION>
<FUNCTION>
<NAME>g_on_error_stack_trace</NAME>
<RETURNS>void  </RETURNS>
const gchar *prg_name
</FUNCTION>
<MACRO>
<NAME>G_BREAKPOINT</NAME>
#  define G_BREAKPOINT()        G_STMT_START{ __asm__ __volatile__ ("int $03"); }G_STMT_END
</MACRO>
<FUNCTION>
<NAME>g_base64_encode_step</NAME>
<RETURNS>gsize    </RETURNS>
const guchar *in, gsize         len, gboolean      break_lines, gchar        *out, gint         *state, gint         *save
</FUNCTION>
<FUNCTION>
<NAME>g_base64_encode_close</NAME>
<RETURNS>gsize    </RETURNS>
gboolean      break_lines, gchar        *out, gint         *state, gint         *save
</FUNCTION>
<FUNCTION>
<NAME>g_base64_encode</NAME>
<RETURNS>gchar *  </RETURNS>
const guchar *data, gsize         len
</FUNCTION>
<FUNCTION>
<NAME>g_base64_decode_step</NAME>
<RETURNS>gsize    </RETURNS>
const gchar  *in, gsize         len, guchar       *out, gint         *state, guint        *save
</FUNCTION>
<FUNCTION>
<NAME>g_base64_decode</NAME>
<RETURNS>guchar  *</RETURNS>
const gchar  *text, gsize        *out_len
</FUNCTION>
<FUNCTION>
<NAME>g_base64_decode_inplace</NAME>
<RETURNS>guchar  *</RETURNS>
gchar        *text, gsize        *out_len
</FUNCTION>
<FUNCTION>
<NAME>g_bit_lock</NAME>
<RETURNS>void       </RETURNS>
volatile gint *address, gint           lock_bit
</FUNCTION>
<FUNCTION>
<NAME>g_bit_trylock</NAME>
<RETURNS>gboolean   </RETURNS>
volatile gint *address, gint           lock_bit
</FUNCTION>
<FUNCTION>
<NAME>g_bit_unlock</NAME>
<RETURNS>void       </RETURNS>
volatile gint *address, gint           lock_bit
</FUNCTION>
<FUNCTION>
<NAME>g_pointer_bit_lock</NAME>
<RETURNS>void       </RETURNS>
volatile void *address, gint           lock_bit
</FUNCTION>
<FUNCTION>
<NAME>g_pointer_bit_trylock</NAME>
<RETURNS>gboolean   </RETURNS>
volatile void *address, gint           lock_bit
</FUNCTION>
<FUNCTION>
<NAME>g_pointer_bit_unlock</NAME>
<RETURNS>void       </RETURNS>
volatile void *address, gint           lock_bit
</FUNCTION>
<MACRO>
<NAME>G_BOOKMARK_FILE_ERROR</NAME>
#define G_BOOKMARK_FILE_ERROR	(g_bookmark_file_error_quark ())
</MACRO>
<ENUM>
<NAME>GBookmarkFileError</NAME>
typedef enum
{
  G_BOOKMARK_FILE_ERROR_INVALID_URI,
  G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
  G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,
  G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
  G_BOOKMARK_FILE_ERROR_READ,
  G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING,
  G_BOOKMARK_FILE_ERROR_WRITE,
  G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND
} GBookmarkFileError;
</ENUM>
<FUNCTION>
<NAME>g_bookmark_file_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_new</NAME>
<RETURNS>GBookmarkFile  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_free</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_load_from_file</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *filename, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_load_from_data</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *data, gsize           length, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_load_from_data_dirs</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *file, gchar         **full_path, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_to_data</NAME>
<RETURNS>gchar  *        </RETURNS>
GBookmarkFile  *bookmark, gsize          *length, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_to_file</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *filename, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_title</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *title
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_title</NAME>
<RETURNS>gchar  *        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_description</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *description
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_description</NAME>
<RETURNS>gchar  *        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_mime_type</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *mime_type
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_mime_type</NAME>
<RETURNS>gchar  *        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_groups</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar   **groups, gsize           length
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_add_group</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *group
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_has_group</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *group, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_groups</NAME>
<RETURNS>gchar  **       </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, gsize          *length, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_add_application</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *name, const gchar    *exec
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_has_application</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *name, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_applications</NAME>
<RETURNS>gchar  **       </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, gsize          *length, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_app_info</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *name, const gchar    *exec, gint            count, time_t          stamp, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_app_info</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *name, gchar         **exec, guint          *count, time_t         *stamp, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_is_private</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, gboolean        is_private
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_is_private</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_icon</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *href, const gchar    *mime_type
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_icon</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, gchar         **href, gchar         **mime_type, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_added</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, time_t          added
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_added</NAME>
<RETURNS>time_t          </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_modified</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, time_t          modified
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_modified</NAME>
<RETURNS>time_t          </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_set_visited</NAME>
<RETURNS>void            </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, time_t          visited
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_visited</NAME>
<RETURNS>time_t          </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_has_item</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_size</NAME>
<RETURNS>gint            </RETURNS>
GBookmarkFile  *bookmark
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_get_uris</NAME>
<RETURNS>gchar  **       </RETURNS>
GBookmarkFile  *bookmark, gsize          *length
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_remove_group</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *group, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_remove_application</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, const gchar    *name, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_remove_item</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *uri, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_bookmark_file_move_item</NAME>
<RETURNS>gboolean        </RETURNS>
GBookmarkFile  *bookmark, const gchar    *old_uri, const gchar    *new_uri, GError        **error
</FUNCTION>
<STRUCT>
<NAME>GBookmarkFile</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_bytes_new</NAME>
<RETURNS>GBytes  *        </RETURNS>
gconstpointer   data, gsize           size
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_new_take</NAME>
<RETURNS>GBytes  *        </RETURNS>
gpointer        data, gsize           size
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_new_static</NAME>
<RETURNS>GBytes  *        </RETURNS>
gconstpointer   data, gsize           size
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_new_with_free_func</NAME>
<RETURNS>GBytes  *        </RETURNS>
gconstpointer   data, gsize           size, GDestroyNotify  free_func, gpointer        user_data
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_new_from_bytes</NAME>
<RETURNS>GBytes  *        </RETURNS>
GBytes         *bytes, gsize           offset, gsize           length
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_get_data</NAME>
<RETURNS>gconstpointer    </RETURNS>
GBytes         *bytes, gsize          *size
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_get_size</NAME>
<RETURNS>gsize            </RETURNS>
GBytes         *bytes
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_ref</NAME>
<RETURNS>GBytes  *        </RETURNS>
GBytes         *bytes
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_unref</NAME>
<RETURNS>void             </RETURNS>
GBytes         *bytes
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_unref_to_data</NAME>
<RETURNS>gpointer         </RETURNS>
GBytes         *bytes, gsize          *size
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_unref_to_array</NAME>
<RETURNS>GByteArray  *    </RETURNS>
GBytes         *bytes
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_hash</NAME>
<RETURNS>guint            </RETURNS>
gconstpointer   bytes
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_equal</NAME>
<RETURNS>gboolean         </RETURNS>
gconstpointer   bytes1, gconstpointer   bytes2
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_compare</NAME>
<RETURNS>gint             </RETURNS>
gconstpointer   bytes1, gconstpointer   bytes2
</FUNCTION>
<FUNCTION>
<NAME>g_get_charset</NAME>
<RETURNS>gboolean               </RETURNS>
const char **charset
</FUNCTION>
<FUNCTION>
<NAME>g_get_codeset</NAME>
<RETURNS>gchar  *               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_language_names</NAME>
<RETURNS>const gchar  * const *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_locale_variants</NAME>
<RETURNS>gchar  **              </RETURNS>
const gchar *locale
</FUNCTION>
<ENUM>
<NAME>GChecksumType</NAME>
typedef enum {
  G_CHECKSUM_MD5,
  G_CHECKSUM_SHA1,
  G_CHECKSUM_SHA256,
  G_CHECKSUM_SHA512,
  G_CHECKSUM_SHA384
} GChecksumType;
</ENUM>
<FUNCTION>
<NAME>g_checksum_type_get_length</NAME>
<RETURNS>gssize                 </RETURNS>
GChecksumType    checksum_type
</FUNCTION>
<FUNCTION>
<NAME>g_checksum_new</NAME>
<RETURNS>GChecksum  *           </RETURNS>
GChecksumType    checksum_type
</FUNCTION>
<FUNCTION>
<NAME>g_checksum_reset</NAME>
<RETURNS>void                   </RETURNS>
GChecksum       *checksum
</FUNCTION>
<FUNCTION>
<NAME>g_checksum_copy</NAME>
<RETURNS>GChecksum  *           </RETURNS>
const GChecksum *checksum
</FUNCTION>
<FUNCTION>
<NAME>g_checksum_free</NAME>
<RETURNS>void                   </RETURNS>
GChecksum       *checksum
</FUNCTION>
<FUNCTION>
<NAME>g_checksum_update</NAME>
<RETURNS>void                   </RETURNS>
GChecksum       *checksum, const guchar    *data, gssize           length
</FUNCTION>
<FUNCTION>
<NAME>g_checksum_get_string</NAME>
<RETURNS>const gchar  *         </RETURNS>
GChecksum       *checksum
</FUNCTION>
<FUNCTION>
<NAME>g_checksum_get_digest</NAME>
<RETURNS>void                   </RETURNS>
GChecksum       *checksum, guint8          *buffer, gsize           *digest_len
</FUNCTION>
<FUNCTION>
<NAME>g_compute_checksum_for_data</NAME>
<RETURNS>gchar                 *</RETURNS>
GChecksumType    checksum_type, const guchar    *data, gsize            length
</FUNCTION>
<FUNCTION>
<NAME>g_compute_checksum_for_string</NAME>
<RETURNS>gchar                 *</RETURNS>
GChecksumType    checksum_type, const gchar     *str, gssize           length
</FUNCTION>
<FUNCTION>
<NAME>g_compute_checksum_for_bytes</NAME>
<RETURNS>gchar                 *</RETURNS>
GChecksumType    checksum_type, GBytes          *data
</FUNCTION>
<STRUCT>
<NAME>GChecksum</NAME>
</STRUCT>
<ENUM>
<NAME>GConvertError</NAME>
typedef enum
{
  G_CONVERT_ERROR_NO_CONVERSION,
  G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
  G_CONVERT_ERROR_FAILED,
  G_CONVERT_ERROR_PARTIAL_INPUT,
  G_CONVERT_ERROR_BAD_URI,
  G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,
  G_CONVERT_ERROR_NO_MEMORY,
  G_CONVERT_ERROR_EMBEDDED_NUL
} GConvertError;
</ENUM>
<MACRO>
<NAME>G_CONVERT_ERROR</NAME>
#define G_CONVERT_ERROR g_convert_error_quark()
</MACRO>
<FUNCTION>
<NAME>g_convert_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>GIConv</NAME>
typedef struct _GIConv *GIConv;
</TYPEDEF>
<FUNCTION>
<NAME>g_iconv_open</NAME>
<RETURNS>GIConv  </RETURNS>
const gchar  *to_codeset, const gchar  *from_codeset
</FUNCTION>
<FUNCTION>
<NAME>g_iconv</NAME>
<RETURNS>gsize   </RETURNS>
GIConv        converter, gchar       **inbuf, gsize        *inbytes_left, gchar       **outbuf, gsize        *outbytes_left
</FUNCTION>
<FUNCTION>
<NAME>g_iconv_close</NAME>
<RETURNS>gint    </RETURNS>
GIConv        converter
</FUNCTION>
<FUNCTION>
<NAME>g_convert</NAME>
<RETURNS>gchar * </RETURNS>
const gchar  *str, gssize        len, const gchar  *to_codeset, const gchar  *from_codeset, gsize        *bytes_read, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_convert_with_iconv</NAME>
<RETURNS>gchar * </RETURNS>
const gchar  *str, gssize        len, GIConv        converter, gsize        *bytes_read, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_convert_with_fallback</NAME>
<RETURNS>gchar * </RETURNS>
const gchar  *str, gssize        len, const gchar  *to_codeset, const gchar  *from_codeset, const gchar  *fallback, gsize        *bytes_read, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_locale_to_utf8</NAME>
<RETURNS>gchar * </RETURNS>
const gchar  *opsysstring, gssize        len, gsize        *bytes_read, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_locale_from_utf8</NAME>
<RETURNS>gchar * </RETURNS>
const gchar  *utf8string, gssize        len, gsize        *bytes_read, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_filename_to_utf8</NAME>
<RETURNS>gchar * </RETURNS>
const gchar  *opsysstring, gssize        len, gsize        *bytes_read, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_filename_from_utf8</NAME>
<RETURNS>gchar * </RETURNS>
const gchar  *utf8string, gssize        len, gsize        *bytes_read, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_filename_from_uri</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *uri, gchar      **hostname, GError     **error
</FUNCTION>
<FUNCTION>
<NAME>g_filename_to_uri</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *filename, const gchar *hostname, GError     **error
</FUNCTION>
<FUNCTION>
<NAME>g_filename_display_name</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>g_get_filename_charsets</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar ***charsets
</FUNCTION>
<FUNCTION>
<NAME>g_filename_display_basename</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>g_uri_list_extract_uris</NAME>
<RETURNS>gchar  **</RETURNS>
const gchar *uri_list
</FUNCTION>
<USER_FUNCTION>
<NAME>GDataForeachFunc</NAME>
<RETURNS>void </RETURNS>
GQuark         key_id,
                                                 gpointer       data,
                                                 gpointer       user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_datalist_init</NAME>
<RETURNS>void      </RETURNS>
GData            **datalist
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_clear</NAME>
<RETURNS>void      </RETURNS>
GData            **datalist
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
GData            **datalist, GQuark             key_id
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_set_data_full</NAME>
<RETURNS>void      </RETURNS>
GData            **datalist, GQuark             key_id, gpointer           data, GDestroyNotify     destroy_func
</FUNCTION>
<USER_FUNCTION>
<NAME>GDuplicateFunc</NAME>
<RETURNS>gpointer </RETURNS>
gpointer data, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_dup_data</NAME>
<RETURNS>gpointer  </RETURNS>
GData            **datalist, GQuark             key_id, GDuplicateFunc     dup_func, gpointer           user_data
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_replace_data</NAME>
<RETURNS>gboolean  </RETURNS>
GData            **datalist, GQuark             key_id, gpointer           oldval, gpointer           newval, GDestroyNotify     destroy, GDestroyNotify    *old_destroy
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_remove_no_notify</NAME>
<RETURNS>gpointer  </RETURNS>
GData            **datalist, GQuark             key_id
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_foreach</NAME>
<RETURNS>void      </RETURNS>
GData            **datalist, GDataForeachFunc   func, gpointer           user_data
</FUNCTION>
<MACRO>
<NAME>G_DATALIST_FLAGS_MASK</NAME>
#define G_DATALIST_FLAGS_MASK 0x3
</MACRO>
<FUNCTION>
<NAME>g_datalist_set_flags</NAME>
<RETURNS>void      </RETURNS>
GData            **datalist, guint              flags
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_unset_flags</NAME>
<RETURNS>void      </RETURNS>
GData            **datalist, guint              flags
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_get_flags</NAME>
<RETURNS>guint     </RETURNS>
GData            **datalist
</FUNCTION>
<MACRO>
<NAME>g_datalist_id_set_data</NAME>
#define   g_datalist_id_set_data(dl, q, d)      \
     g_datalist_id_set_data_full ((dl), (q), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_datalist_id_remove_data</NAME>
#define   g_datalist_id_remove_data(dl, q)      \
     g_datalist_id_set_data ((dl), (q), NULL)
</MACRO>
<MACRO>
<NAME>g_datalist_set_data_full</NAME>
#define   g_datalist_set_data_full(dl, k, d, f) \
     g_datalist_id_set_data_full ((dl), g_quark_from_string (k), (d), (f))
</MACRO>
<MACRO>
<NAME>g_datalist_remove_no_notify</NAME>
#define   g_datalist_remove_no_notify(dl, k)    \
     g_datalist_id_remove_no_notify ((dl), g_quark_try_string (k))
</MACRO>
<MACRO>
<NAME>g_datalist_set_data</NAME>
#define   g_datalist_set_data(dl, k, d)         \
     g_datalist_set_data_full ((dl), (k), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_datalist_remove_data</NAME>
#define   g_datalist_remove_data(dl, k)         \
     g_datalist_id_set_data ((dl), g_quark_try_string (k), NULL)
</MACRO>
<FUNCTION>
<NAME>g_dataset_destroy</NAME>
<RETURNS>void       </RETURNS>
gconstpointer    dataset_location
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_id_get_data</NAME>
<RETURNS>gpointer   </RETURNS>
gconstpointer    dataset_location, GQuark           key_id
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_get_data</NAME>
<RETURNS>gpointer   </RETURNS>
GData	 **datalist, const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_id_set_data_full</NAME>
<RETURNS>void       </RETURNS>
gconstpointer    dataset_location, GQuark           key_id, gpointer         data, GDestroyNotify   destroy_func
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_id_remove_no_notify</NAME>
<RETURNS>gpointer   </RETURNS>
gconstpointer    dataset_location, GQuark           key_id
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_foreach</NAME>
<RETURNS>void       </RETURNS>
gconstpointer    dataset_location, GDataForeachFunc func, gpointer         user_data
</FUNCTION>
<MACRO>
<NAME>g_dataset_id_set_data</NAME>
#define   g_dataset_id_set_data(l, k, d)        \
     g_dataset_id_set_data_full ((l), (k), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_dataset_id_remove_data</NAME>
#define   g_dataset_id_remove_data(l, k)        \
     g_dataset_id_set_data ((l), (k), NULL)
</MACRO>
<MACRO>
<NAME>g_dataset_get_data</NAME>
#define   g_dataset_get_data(l, k)              \
     (g_dataset_id_get_data ((l), g_quark_try_string (k)))
</MACRO>
<MACRO>
<NAME>g_dataset_set_data_full</NAME>
#define   g_dataset_set_data_full(l, k, d, f)   \
     g_dataset_id_set_data_full ((l), g_quark_from_string (k), (d), (f))
</MACRO>
<MACRO>
<NAME>g_dataset_remove_no_notify</NAME>
#define   g_dataset_remove_no_notify(l, k)      \
     g_dataset_id_remove_no_notify ((l), g_quark_try_string (k))
</MACRO>
<MACRO>
<NAME>g_dataset_set_data</NAME>
#define   g_dataset_set_data(l, k, d)           \
     g_dataset_set_data_full ((l), (k), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_dataset_remove_data</NAME>
#define   g_dataset_remove_data(l, k)           \
     g_dataset_id_set_data ((l), g_quark_try_string (k), NULL)
</MACRO>
<STRUCT>
<NAME>GData</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GTime</NAME>
typedef gint32  GTime;
</TYPEDEF>
<TYPEDEF>
<NAME>GDateYear</NAME>
typedef guint16 GDateYear;
</TYPEDEF>
<TYPEDEF>
<NAME>GDateDay</NAME>
typedef guint8  GDateDay;   /* day of the month */
</TYPEDEF>
<ENUM>
<NAME>GDateDMY</NAME>
typedef enum
{
  G_DATE_DAY   = 0,
  G_DATE_MONTH = 1,
  G_DATE_YEAR  = 2
} GDateDMY;
</ENUM>
<ENUM>
<NAME>GDateWeekday</NAME>
typedef enum
{
  G_DATE_BAD_WEEKDAY  = 0,
  G_DATE_MONDAY       = 1,
  G_DATE_TUESDAY      = 2,
  G_DATE_WEDNESDAY    = 3,
  G_DATE_THURSDAY     = 4,
  G_DATE_FRIDAY       = 5,
  G_DATE_SATURDAY     = 6,
  G_DATE_SUNDAY       = 7
} GDateWeekday;
</ENUM>
<ENUM>
<NAME>GDateMonth</NAME>
typedef enum
{
  G_DATE_BAD_MONTH = 0,
  G_DATE_JANUARY   = 1,
  G_DATE_FEBRUARY  = 2,
  G_DATE_MARCH     = 3,
  G_DATE_APRIL     = 4,
  G_DATE_MAY       = 5,
  G_DATE_JUNE      = 6,
  G_DATE_JULY      = 7,
  G_DATE_AUGUST    = 8,
  G_DATE_SEPTEMBER = 9,
  G_DATE_OCTOBER   = 10,
  G_DATE_NOVEMBER  = 11,
  G_DATE_DECEMBER  = 12
} GDateMonth;
</ENUM>
<MACRO>
<NAME>G_DATE_BAD_JULIAN</NAME>
#define G_DATE_BAD_JULIAN 0U
</MACRO>
<MACRO>
<NAME>G_DATE_BAD_DAY</NAME>
#define G_DATE_BAD_DAY    0U
</MACRO>
<MACRO>
<NAME>G_DATE_BAD_YEAR</NAME>
#define G_DATE_BAD_YEAR   0U
</MACRO>
<STRUCT>
<NAME>GDate</NAME>
struct _GDate
{
  guint julian_days : 32; /* julian days representation - we use a
                           *  bitfield hoping that 64 bit platforms
                           *  will pack this whole struct in one big
                           *  int
                           */

  guint julian : 1;    /* julian is valid */
  guint dmy    : 1;    /* dmy is valid */

  /* DMY representation */
  guint day    : 6;
  guint month  : 4;
  guint year   : 16;
};
</STRUCT>
<FUNCTION>
<NAME>g_date_new</NAME>
<RETURNS>GDate *       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_date_new_dmy</NAME>
<RETURNS>GDate *       </RETURNS>
GDateDay     day, GDateMonth   month, GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_new_julian</NAME>
<RETURNS>GDate *       </RETURNS>
guint32      julian_day
</FUNCTION>
<FUNCTION>
<NAME>g_date_free</NAME>
<RETURNS>void          </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_copy</NAME>
<RETURNS>GDate *       </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid</NAME>
<RETURNS>gboolean      </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_day</NAME>
<RETURNS>gboolean      </RETURNS>
GDateDay     day
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_month</NAME>
<RETURNS>gboolean      </RETURNS>
GDateMonth month
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_year</NAME>
<RETURNS>gboolean      </RETURNS>
GDateYear  year
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_weekday</NAME>
<RETURNS>gboolean      </RETURNS>
GDateWeekday weekday
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_julian</NAME>
<RETURNS>gboolean      </RETURNS>
guint32 julian_date
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_dmy</NAME>
<RETURNS>gboolean      </RETURNS>
GDateDay     day, GDateMonth   month, GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_weekday</NAME>
<RETURNS>GDateWeekday  </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_month</NAME>
<RETURNS>GDateMonth    </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_year</NAME>
<RETURNS>GDateYear     </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_day</NAME>
<RETURNS>GDateDay      </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_julian</NAME>
<RETURNS>guint32       </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_day_of_year</NAME>
<RETURNS>guint         </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_monday_week_of_year</NAME>
<RETURNS>guint         </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_sunday_week_of_year</NAME>
<RETURNS>guint         </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_iso8601_week_of_year</NAME>
<RETURNS>guint         </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_clear</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint        n_dates
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_parse</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, const gchar *str
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_time_t</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, time_t       timet
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_time_val</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, GTimeVal    *timeval
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_time</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GDate       *date, GTime        time_
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_month</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, GDateMonth   month
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_day</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, GDateDay     day
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_year</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_dmy</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, GDateDay     day, GDateMonth   month, GDateYear    y
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_julian</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint32      julian_date
</FUNCTION>
<FUNCTION>
<NAME>g_date_is_first_of_month</NAME>
<RETURNS>gboolean      </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_is_last_of_month</NAME>
<RETURNS>gboolean      </RETURNS>
const GDate *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_add_days</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint        n_days
</FUNCTION>
<FUNCTION>
<NAME>g_date_subtract_days</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint        n_days
</FUNCTION>
<FUNCTION>
<NAME>g_date_add_months</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint        n_months
</FUNCTION>
<FUNCTION>
<NAME>g_date_subtract_months</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint        n_months
</FUNCTION>
<FUNCTION>
<NAME>g_date_add_years</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint        n_years
</FUNCTION>
<FUNCTION>
<NAME>g_date_subtract_years</NAME>
<RETURNS>void          </RETURNS>
GDate       *date, guint        n_years
</FUNCTION>
<FUNCTION>
<NAME>g_date_is_leap_year</NAME>
<RETURNS>gboolean      </RETURNS>
GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_days_in_month</NAME>
<RETURNS>guint8        </RETURNS>
GDateMonth   month, GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_monday_weeks_in_year</NAME>
<RETURNS>guint8        </RETURNS>
GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_get_sunday_weeks_in_year</NAME>
<RETURNS>guint8        </RETURNS>
GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_days_between</NAME>
<RETURNS>gint          </RETURNS>
const GDate *date1, const GDate *date2
</FUNCTION>
<FUNCTION>
<NAME>g_date_compare</NAME>
<RETURNS>gint          </RETURNS>
const GDate *lhs, const GDate *rhs
</FUNCTION>
<FUNCTION>
<NAME>g_date_to_struct_tm</NAME>
<RETURNS>void          </RETURNS>
const GDate *date, struct tm   *tm
</FUNCTION>
<FUNCTION>
<NAME>g_date_clamp</NAME>
<RETURNS>void          </RETURNS>
GDate *date, const GDate *min_date, const GDate *max_date
</FUNCTION>
<FUNCTION>
<NAME>g_date_order</NAME>
<RETURNS>void          </RETURNS>
GDate *date1, GDate *date2
</FUNCTION>
<FUNCTION>
<NAME>g_date_strftime</NAME>
<RETURNS>gsize         </RETURNS>
gchar       *s, gsize        slen, const gchar *format, const GDate *date
</FUNCTION>
<MACRO>
<NAME>g_date_weekday</NAME>
<DEPRECATED/>
#define g_date_weekday 			g_date_get_weekday
</MACRO>
<MACRO>
<NAME>g_date_month</NAME>
<DEPRECATED/>
#define g_date_month 			g_date_get_month
</MACRO>
<MACRO>
<NAME>g_date_year</NAME>
<DEPRECATED/>
#define g_date_year 			g_date_get_year
</MACRO>
<MACRO>
<NAME>g_date_day</NAME>
<DEPRECATED/>
#define g_date_day 			g_date_get_day
</MACRO>
<MACRO>
<NAME>g_date_julian</NAME>
<DEPRECATED/>
#define g_date_julian 			g_date_get_julian
</MACRO>
<MACRO>
<NAME>g_date_day_of_year</NAME>
<DEPRECATED/>
#define g_date_day_of_year 		g_date_get_day_of_year
</MACRO>
<MACRO>
<NAME>g_date_monday_week_of_year</NAME>
<DEPRECATED/>
#define g_date_monday_week_of_year 	g_date_get_monday_week_of_year
</MACRO>
<MACRO>
<NAME>g_date_sunday_week_of_year</NAME>
<DEPRECATED/>
#define g_date_sunday_week_of_year 	g_date_get_sunday_week_of_year
</MACRO>
<MACRO>
<NAME>g_date_days_in_month</NAME>
<DEPRECATED/>
#define g_date_days_in_month 		g_date_get_days_in_month
</MACRO>
<MACRO>
<NAME>g_date_monday_weeks_in_year</NAME>
<DEPRECATED/>
#define g_date_monday_weeks_in_year 	g_date_get_monday_weeks_in_year
</MACRO>
<MACRO>
<NAME>g_date_sunday_weeks_in_year</NAME>
<DEPRECATED/>
#define g_date_sunday_weeks_in_year	g_date_get_sunday_weeks_in_year
</MACRO>
<MACRO>
<NAME>G_TIME_SPAN_DAY</NAME>
#define G_TIME_SPAN_DAY                 (G_GINT64_CONSTANT (86400000000))
</MACRO>
<MACRO>
<NAME>G_TIME_SPAN_HOUR</NAME>
#define G_TIME_SPAN_HOUR                (G_GINT64_CONSTANT (3600000000))
</MACRO>
<MACRO>
<NAME>G_TIME_SPAN_MINUTE</NAME>
#define G_TIME_SPAN_MINUTE              (G_GINT64_CONSTANT (60000000))
</MACRO>
<MACRO>
<NAME>G_TIME_SPAN_SECOND</NAME>
#define G_TIME_SPAN_SECOND              (G_GINT64_CONSTANT (1000000))
</MACRO>
<MACRO>
<NAME>G_TIME_SPAN_MILLISECOND</NAME>
#define G_TIME_SPAN_MILLISECOND         (G_GINT64_CONSTANT (1000))
</MACRO>
<TYPEDEF>
<NAME>GTimeSpan</NAME>
typedef gint64 GTimeSpan;
</TYPEDEF>
<FUNCTION>
<NAME>g_date_time_unref</NAME>
<RETURNS>void                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_ref</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_now</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GTimeZone      *tz
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_now_local</NAME>
<RETURNS>GDateTime  *             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_now_utc</NAME>
<RETURNS>GDateTime  *             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_from_unix_local</NAME>
<RETURNS>GDateTime  *             </RETURNS>
gint64          t
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_from_unix_utc</NAME>
<RETURNS>GDateTime  *             </RETURNS>
gint64          t
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_from_timeval_local</NAME>
<RETURNS>GDateTime  *             </RETURNS>
const GTimeVal *tv
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_from_timeval_utc</NAME>
<RETURNS>GDateTime  *             </RETURNS>
const GTimeVal *tv
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_from_iso8601</NAME>
<RETURNS>GDateTime  *             </RETURNS>
const gchar    *text, GTimeZone      *default_tz
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GTimeZone      *tz, gint            year, gint            month, gint            day, gint            hour, gint            minute, gdouble         seconds
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_local</NAME>
<RETURNS>GDateTime  *             </RETURNS>
gint            year, gint            month, gint            day, gint            hour, gint            minute, gdouble         seconds
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_new_utc</NAME>
<RETURNS>GDateTime  *             </RETURNS>
gint            year, gint            month, gint            day, gint            hour, gint            minute, gdouble         seconds
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, GTimeSpan       timespan
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_years</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gint            years
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_months</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gint            months
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_weeks</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gint            weeks
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_days</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gint            days
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_hours</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gint            hours
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_minutes</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gint            minutes
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_seconds</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gdouble         seconds
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_add_full</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, gint            years, gint            months, gint            days, gint            hours, gint            minutes, gdouble         seconds
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_compare</NAME>
<RETURNS>gint                     </RETURNS>
gconstpointer   dt1, gconstpointer   dt2
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_difference</NAME>
<RETURNS>GTimeSpan                </RETURNS>
GDateTime      *end, GDateTime      *begin
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_hash</NAME>
<RETURNS>guint                    </RETURNS>
gconstpointer   datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_equal</NAME>
<RETURNS>gboolean                 </RETURNS>
gconstpointer   dt1, gconstpointer   dt2
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_ymd</NAME>
<RETURNS>void                     </RETURNS>
GDateTime      *datetime, gint           *year, gint           *month, gint           *day
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_year</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_month</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_day_of_month</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_week_numbering_year</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_week_of_year</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_day_of_week</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_day_of_year</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_hour</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_minute</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_second</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_microsecond</NAME>
<RETURNS>gint                     </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_seconds</NAME>
<RETURNS>gdouble                  </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_to_unix</NAME>
<RETURNS>gint64                   </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_to_timeval</NAME>
<RETURNS>gboolean                 </RETURNS>
GDateTime      *datetime, GTimeVal       *tv
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_utc_offset</NAME>
<RETURNS>GTimeSpan                </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_get_timezone_abbreviation</NAME>
<RETURNS>const gchar  *           </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_is_daylight_savings</NAME>
<RETURNS>gboolean                 </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_to_timezone</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime, GTimeZone      *tz
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_to_local</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_to_utc</NAME>
<RETURNS>GDateTime  *             </RETURNS>
GDateTime      *datetime
</FUNCTION>
<FUNCTION>
<NAME>g_date_time_format</NAME>
<RETURNS>gchar  *                 </RETURNS>
GDateTime      *datetime, const gchar    *format
</FUNCTION>
<STRUCT>
<NAME>GDateTime</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_dir_open</NAME>
<RETURNS>GDir     *                </RETURNS>
const gchar  *path, guint         flags, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_dir_read_name</NAME>
<RETURNS>const gchar  *            </RETURNS>
GDir         *dir
</FUNCTION>
<FUNCTION>
<NAME>g_dir_rewind</NAME>
<RETURNS>void                      </RETURNS>
GDir         *dir
</FUNCTION>
<FUNCTION>
<NAME>g_dir_close</NAME>
<RETURNS>void                      </RETURNS>
GDir         *dir
</FUNCTION>
<STRUCT>
<NAME>GDir</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_getenv</NAME>
<RETURNS>const gchar  * </RETURNS>
const gchar  *variable
</FUNCTION>
<FUNCTION>
<NAME>g_setenv</NAME>
<RETURNS>gboolean       </RETURNS>
const gchar  *variable, const gchar  *value, gboolean      overwrite
</FUNCTION>
<FUNCTION>
<NAME>g_unsetenv</NAME>
<RETURNS>void           </RETURNS>
const gchar  *variable
</FUNCTION>
<FUNCTION>
<NAME>g_listenv</NAME>
<RETURNS>gchar  **      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_environ</NAME>
<RETURNS>gchar  **      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_environ_getenv</NAME>
<RETURNS>const gchar  * </RETURNS>
gchar       **envp, const gchar  *variable
</FUNCTION>
<FUNCTION>
<NAME>g_environ_setenv</NAME>
<RETURNS>gchar  **      </RETURNS>
gchar       **envp, const gchar  *variable, const gchar  *value, gboolean      overwrite
</FUNCTION>
<FUNCTION>
<NAME>g_environ_unsetenv</NAME>
<RETURNS>gchar  **      </RETURNS>
gchar       **envp, const gchar  *variable
</FUNCTION>
<STRUCT>
<NAME>GError</NAME>
struct _GError
{
  GQuark       domain;
  gint         code;
  gchar       *message;
};
</STRUCT>
<FUNCTION>
<NAME>g_error_new</NAME>
<RETURNS>GError *  </RETURNS>
GQuark         domain, gint           code, const gchar   *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_error_new_literal</NAME>
<RETURNS>GError *  </RETURNS>
GQuark         domain, gint           code, const gchar   *message
</FUNCTION>
<FUNCTION>
<NAME>g_error_new_valist</NAME>
<RETURNS>GError *  </RETURNS>
GQuark         domain, gint           code, const gchar   *format, va_list        args
</FUNCTION>
<FUNCTION>
<NAME>g_error_free</NAME>
<RETURNS>void      </RETURNS>
GError        *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_copy</NAME>
<RETURNS>GError *  </RETURNS>
const GError  *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_matches</NAME>
<RETURNS>gboolean  </RETURNS>
const GError  *error, GQuark         domain, gint           code
</FUNCTION>
<FUNCTION>
<NAME>g_set_error</NAME>
<RETURNS>void      </RETURNS>
GError       **err, GQuark         domain, gint           code, const gchar   *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_set_error_literal</NAME>
<RETURNS>void      </RETURNS>
GError       **err, GQuark         domain, gint           code, const gchar   *message
</FUNCTION>
<FUNCTION>
<NAME>g_propagate_error</NAME>
<RETURNS>void      </RETURNS>
GError       **dest, GError        *src
</FUNCTION>
<FUNCTION>
<NAME>g_clear_error</NAME>
<RETURNS>void      </RETURNS>
GError       **err
</FUNCTION>
<FUNCTION>
<NAME>g_prefix_error</NAME>
<RETURNS>void      </RETURNS>
GError       **err, const gchar   *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_propagate_prefixed_error</NAME>
<RETURNS>void      </RETURNS>
GError       **dest, GError        *src, const gchar   *format, ...
</FUNCTION>
<MACRO>
<NAME>G_FILE_ERROR</NAME>
#define G_FILE_ERROR g_file_error_quark ()
</MACRO>
<ENUM>
<NAME>GFileError</NAME>
typedef enum
{
  G_FILE_ERROR_EXIST,
  G_FILE_ERROR_ISDIR,
  G_FILE_ERROR_ACCES,
  G_FILE_ERROR_NAMETOOLONG,
  G_FILE_ERROR_NOENT,
  G_FILE_ERROR_NOTDIR,
  G_FILE_ERROR_NXIO,
  G_FILE_ERROR_NODEV,
  G_FILE_ERROR_ROFS,
  G_FILE_ERROR_TXTBSY,
  G_FILE_ERROR_FAULT,
  G_FILE_ERROR_LOOP,
  G_FILE_ERROR_NOSPC,
  G_FILE_ERROR_NOMEM,
  G_FILE_ERROR_MFILE,
  G_FILE_ERROR_NFILE,
  G_FILE_ERROR_BADF,
  G_FILE_ERROR_INVAL,
  G_FILE_ERROR_PIPE,
  G_FILE_ERROR_AGAIN,
  G_FILE_ERROR_INTR,
  G_FILE_ERROR_IO,
  G_FILE_ERROR_PERM,
  G_FILE_ERROR_NOSYS,
  G_FILE_ERROR_FAILED
} GFileError;
</ENUM>
<ENUM>
<NAME>GFileTest</NAME>
typedef enum
{
  G_FILE_TEST_IS_REGULAR    = 1 << 0,
  G_FILE_TEST_IS_SYMLINK    = 1 << 1,
  G_FILE_TEST_IS_DIR        = 1 << 2,
  G_FILE_TEST_IS_EXECUTABLE = 1 << 3,
  G_FILE_TEST_EXISTS        = 1 << 4
} GFileTest;
</ENUM>
<FUNCTION>
<NAME>g_file_error_quark</NAME>
<RETURNS>GQuark      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_error_from_errno</NAME>
<RETURNS>GFileError  </RETURNS>
gint err_no
</FUNCTION>
<FUNCTION>
<NAME>g_file_test</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *filename, GFileTest     test
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_contents</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *filename, gchar       **contents, gsize        *length, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_contents</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *filename, const gchar *contents, gssize         length, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_read_link</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar  *filename, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_mkdtemp</NAME>
<RETURNS>gchar    *</RETURNS>
gchar        *tmpl
</FUNCTION>
<FUNCTION>
<NAME>g_mkdtemp_full</NAME>
<RETURNS>gchar    *</RETURNS>
gchar        *tmpl, gint          mode
</FUNCTION>
<FUNCTION>
<NAME>g_mkstemp</NAME>
<RETURNS>gint      </RETURNS>
gchar        *tmpl
</FUNCTION>
<FUNCTION>
<NAME>g_mkstemp_full</NAME>
<RETURNS>gint      </RETURNS>
gchar        *tmpl, gint          flags, gint          mode
</FUNCTION>
<FUNCTION>
<NAME>g_file_open_tmp</NAME>
<RETURNS>gint      </RETURNS>
const gchar  *tmpl, gchar       **name_used, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_dir_make_tmp</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar  *tmpl, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_build_path</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar *separator, const gchar *first_element, ...
</FUNCTION>
<FUNCTION>
<NAME>g_build_pathv</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar  *separator, gchar       **args
</FUNCTION>
<FUNCTION>
<NAME>g_build_filename</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar *first_element, ...
</FUNCTION>
<FUNCTION>
<NAME>g_build_filenamev</NAME>
<RETURNS>gchar    *</RETURNS>
gchar      **args
</FUNCTION>
<FUNCTION>
<NAME>g_build_filename_valist</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar  *first_element, va_list      *args
</FUNCTION>
<FUNCTION>
<NAME>g_mkdir_with_parents</NAME>
<RETURNS>gint      </RETURNS>
const gchar *pathname, gint         mode
</FUNCTION>
<MACRO>
<NAME>G_IS_DIR_SEPARATOR</NAME>
#define G_IS_DIR_SEPARATOR(c) ((c) == G_DIR_SEPARATOR || (c) == '/')
</MACRO>
<FUNCTION>
<NAME>g_path_is_absolute</NAME>
<RETURNS>gboolean      </RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_path_skip_root</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_basename</NAME>
<DEPRECATED/>
<RETURNS>const gchar  *</RETURNS>
const gchar *file_name
</FUNCTION>
<MACRO>
<NAME>g_dirname</NAME>
<DEPRECATED/>
#define g_dirname g_path_get_dirname
</MACRO>
<FUNCTION>
<NAME>g_get_current_dir</NAME>
<RETURNS>gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_path_get_basename</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_path_get_dirname</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_strip_context</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *msgid, const gchar *msgval
</FUNCTION>
<FUNCTION>
<NAME>g_dgettext</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *domain, const gchar *msgid
</FUNCTION>
<FUNCTION>
<NAME>g_dcgettext</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *domain, const gchar *msgid, gint         category
</FUNCTION>
<FUNCTION>
<NAME>g_dngettext</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong       n
</FUNCTION>
<FUNCTION>
<NAME>g_dpgettext</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *domain, const gchar *msgctxtid, gsize        msgidoffset
</FUNCTION>
<FUNCTION>
<NAME>g_dpgettext2</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *domain, const gchar *context, const gchar *msgid
</FUNCTION>
<USER_FUNCTION>
<NAME>GHRFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer  key,
                               gpointer  value,
                               gpointer  user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GHashTableIter</NAME>
struct _GHashTableIter
{
  /*< private >*/
  gpointer      dummy1;
  gpointer      dummy2;
  gpointer      dummy3;
  int           dummy4;
  gboolean      dummy5;
  gpointer      dummy6;
};
</STRUCT>
<FUNCTION>
<NAME>g_hash_table_new</NAME>
<RETURNS>GHashTable * </RETURNS>
GHashFunc       hash_func, GEqualFunc      key_equal_func
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_new_full</NAME>
<RETURNS>GHashTable * </RETURNS>
GHashFunc       hash_func, GEqualFunc      key_equal_func, GDestroyNotify  key_destroy_func, GDestroyNotify  value_destroy_func
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_destroy</NAME>
<RETURNS>void         </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_insert</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTable     *hash_table, gpointer        key, gpointer        value
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_replace</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTable     *hash_table, gpointer        key, gpointer        value
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_add</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTable     *hash_table, gpointer        key
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_remove</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTable     *hash_table, gconstpointer   key
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_remove_all</NAME>
<RETURNS>void         </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_steal</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTable     *hash_table, gconstpointer   key
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_steal_all</NAME>
<RETURNS>void         </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_lookup</NAME>
<RETURNS>gpointer     </RETURNS>
GHashTable     *hash_table, gconstpointer   key
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_contains</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTable     *hash_table, gconstpointer   key
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_lookup_extended</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTable     *hash_table, gconstpointer   lookup_key, gpointer       *orig_key, gpointer       *value
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_foreach</NAME>
<RETURNS>void         </RETURNS>
GHashTable     *hash_table, GHFunc          func, gpointer        user_data
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_find</NAME>
<RETURNS>gpointer     </RETURNS>
GHashTable     *hash_table, GHRFunc         predicate, gpointer        user_data
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_foreach_remove</NAME>
<RETURNS>guint        </RETURNS>
GHashTable     *hash_table, GHRFunc         func, gpointer        user_data
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_foreach_steal</NAME>
<RETURNS>guint        </RETURNS>
GHashTable     *hash_table, GHRFunc         func, gpointer        user_data
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_size</NAME>
<RETURNS>guint        </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_get_keys</NAME>
<RETURNS>GList  *     </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_get_values</NAME>
<RETURNS>GList  *     </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_get_keys_as_array</NAME>
<RETURNS>gpointer  *  </RETURNS>
GHashTable     *hash_table, guint          *length
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_iter_init</NAME>
<RETURNS>void         </RETURNS>
GHashTableIter *iter, GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_iter_next</NAME>
<RETURNS>gboolean     </RETURNS>
GHashTableIter *iter, gpointer       *key, gpointer       *value
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_iter_get_hash_table</NAME>
<RETURNS>GHashTable * </RETURNS>
GHashTableIter *iter
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_iter_remove</NAME>
<RETURNS>void         </RETURNS>
GHashTableIter *iter
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_iter_replace</NAME>
<RETURNS>void         </RETURNS>
GHashTableIter *iter, gpointer        value
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_iter_steal</NAME>
<RETURNS>void         </RETURNS>
GHashTableIter *iter
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_ref</NAME>
<RETURNS>GHashTable * </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_unref</NAME>
<RETURNS>void         </RETURNS>
GHashTable     *hash_table
</FUNCTION>
<MACRO>
<NAME>g_hash_table_freeze</NAME>
<DEPRECATED/>
#define g_hash_table_freeze(hash_table) ((void)0)
</MACRO>
<MACRO>
<NAME>g_hash_table_thaw</NAME>
<DEPRECATED/>
#define g_hash_table_thaw(hash_table) ((void)0)
</MACRO>
<FUNCTION>
<NAME>g_str_equal</NAME>
<RETURNS>gboolean  </RETURNS>
gconstpointer  v1, gconstpointer  v2
</FUNCTION>
<FUNCTION>
<NAME>g_str_hash</NAME>
<RETURNS>guint     </RETURNS>
gconstpointer  v
</FUNCTION>
<FUNCTION>
<NAME>g_int_equal</NAME>
<RETURNS>gboolean  </RETURNS>
gconstpointer  v1, gconstpointer  v2
</FUNCTION>
<FUNCTION>
<NAME>g_int_hash</NAME>
<RETURNS>guint     </RETURNS>
gconstpointer  v
</FUNCTION>
<FUNCTION>
<NAME>g_int64_equal</NAME>
<RETURNS>gboolean  </RETURNS>
gconstpointer  v1, gconstpointer  v2
</FUNCTION>
<FUNCTION>
<NAME>g_int64_hash</NAME>
<RETURNS>guint     </RETURNS>
gconstpointer  v
</FUNCTION>
<FUNCTION>
<NAME>g_double_equal</NAME>
<RETURNS>gboolean  </RETURNS>
gconstpointer  v1, gconstpointer  v2
</FUNCTION>
<FUNCTION>
<NAME>g_double_hash</NAME>
<RETURNS>guint     </RETURNS>
gconstpointer  v
</FUNCTION>
<FUNCTION>
<NAME>g_direct_hash</NAME>
<RETURNS>guint     </RETURNS>
gconstpointer  v
</FUNCTION>
<FUNCTION>
<NAME>g_direct_equal</NAME>
<RETURNS>gboolean  </RETURNS>
gconstpointer  v1, gconstpointer  v2
</FUNCTION>
<STRUCT>
<NAME>GHashTable</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_hmac_new</NAME>
<RETURNS>GHmac  *               </RETURNS>
GChecksumType  digest_type, const guchar  *key, gsize          key_len
</FUNCTION>
<FUNCTION>
<NAME>g_hmac_copy</NAME>
<RETURNS>GHmac  *               </RETURNS>
const GHmac   *hmac
</FUNCTION>
<FUNCTION>
<NAME>g_hmac_ref</NAME>
<RETURNS>GHmac  *               </RETURNS>
GHmac         *hmac
</FUNCTION>
<FUNCTION>
<NAME>g_hmac_unref</NAME>
<RETURNS>void                   </RETURNS>
GHmac         *hmac
</FUNCTION>
<FUNCTION>
<NAME>g_hmac_update</NAME>
<RETURNS>void                   </RETURNS>
GHmac         *hmac, const guchar  *data, gssize         length
</FUNCTION>
<FUNCTION>
<NAME>g_hmac_get_string</NAME>
<RETURNS>const gchar  *         </RETURNS>
GHmac         *hmac
</FUNCTION>
<FUNCTION>
<NAME>g_hmac_get_digest</NAME>
<RETURNS>void                   </RETURNS>
GHmac         *hmac, guint8        *buffer, gsize         *digest_len
</FUNCTION>
<FUNCTION>
<NAME>g_compute_hmac_for_data</NAME>
<RETURNS>gchar                 *</RETURNS>
GChecksumType  digest_type, const guchar  *key, gsize          key_len, const guchar  *data, gsize          length
</FUNCTION>
<FUNCTION>
<NAME>g_compute_hmac_for_string</NAME>
<RETURNS>gchar                 *</RETURNS>
GChecksumType  digest_type, const guchar  *key, gsize          key_len, const gchar   *str, gssize         length
</FUNCTION>
<FUNCTION>
<NAME>g_compute_hmac_for_bytes</NAME>
<RETURNS>gchar                *</RETURNS>
GChecksumType  digest_type, GBytes        *key, GBytes        *data
</FUNCTION>
<STRUCT>
<NAME>GHmac</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GHookCompareFunc</NAME>
<RETURNS>gint </RETURNS>
GHook		*new_hook,
						 GHook		*sibling
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookFindFunc</NAME>
<RETURNS>gboolean </RETURNS>
GHook		*hook,
						 gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookMarshaller</NAME>
<RETURNS>void </RETURNS>
GHook		*hook,
						 gpointer	 marshal_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookCheckMarshaller</NAME>
<RETURNS>gboolean </RETURNS>
GHook		*hook,
						 gpointer	 marshal_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookFunc</NAME>
<RETURNS>void </RETURNS>
gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookCheckFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookFinalizeFunc</NAME>
<RETURNS>void </RETURNS>
GHookList      *hook_list,
						 GHook          *hook
</USER_FUNCTION>
<ENUM>
<NAME>GHookFlagMask</NAME>
typedef enum
{
  G_HOOK_FLAG_ACTIVE	    = 1 << 0,
  G_HOOK_FLAG_IN_CALL	    = 1 << 1,
  G_HOOK_FLAG_MASK	    = 0x0f
} GHookFlagMask;
</ENUM>
<MACRO>
<NAME>G_HOOK_FLAG_USER_SHIFT</NAME>
#define G_HOOK_FLAG_USER_SHIFT	(4)
</MACRO>
<STRUCT>
<NAME>GHookList</NAME>
struct _GHookList
{
  gulong	    seq_id;
  guint		    hook_size : 16;
  guint		    is_setup : 1;
  GHook		   *hooks;
  gpointer	    dummy3;
  GHookFinalizeFunc finalize_hook;
  gpointer	    dummy[2];
};
</STRUCT>
<STRUCT>
<NAME>GHook</NAME>
struct _GHook
{
  gpointer	 data;
  GHook		*next;
  GHook		*prev;
  guint		 ref_count;
  gulong	 hook_id;
  guint		 flags;
  gpointer	 func;
  GDestroyNotify destroy;
};
</STRUCT>
<MACRO>
<NAME>G_HOOK</NAME>
#define	G_HOOK(hook)			((GHook*) (hook))
</MACRO>
<MACRO>
<NAME>G_HOOK_FLAGS</NAME>
#define	G_HOOK_FLAGS(hook)		(G_HOOK (hook)->flags)
</MACRO>
<MACRO>
<NAME>G_HOOK_ACTIVE</NAME>
#define	G_HOOK_ACTIVE(hook)		((G_HOOK_FLAGS (hook) & \
					  G_HOOK_FLAG_ACTIVE) != 0)
</MACRO>
<MACRO>
<NAME>G_HOOK_IN_CALL</NAME>
#define	G_HOOK_IN_CALL(hook)		((G_HOOK_FLAGS (hook) & \
					  G_HOOK_FLAG_IN_CALL) != 0)
</MACRO>
<MACRO>
<NAME>G_HOOK_IS_VALID</NAME>
#define G_HOOK_IS_VALID(hook)		(G_HOOK (hook)->hook_id != 0 && \
					 (G_HOOK_FLAGS (hook) & \
                                          G_HOOK_FLAG_ACTIVE))
</MACRO>
<MACRO>
<NAME>G_HOOK_IS_UNLINKED</NAME>
#define G_HOOK_IS_UNLINKED(hook)	(G_HOOK (hook)->next == NULL && \
					 G_HOOK (hook)->prev == NULL && \
					 G_HOOK (hook)->hook_id == 0 && \
					 G_HOOK (hook)->ref_count == 0)
</MACRO>
<FUNCTION>
<NAME>g_hook_list_init</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, guint			 hook_size
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_clear</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list
</FUNCTION>
<FUNCTION>
<NAME>g_hook_alloc</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list
</FUNCTION>
<FUNCTION>
<NAME>g_hook_free</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_ref</NAME>
<RETURNS>GHook  *	 </RETURNS>
GHookList		*hook_list, GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_unref</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_destroy</NAME>
<RETURNS>gboolean  </RETURNS>
GHookList		*hook_list, gulong			 hook_id
</FUNCTION>
<FUNCTION>
<NAME>g_hook_destroy_link</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_prepend</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_insert_before</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, GHook			*sibling, GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_insert_sorted</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, GHook			*hook, GHookCompareFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_hook_get</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list, gulong			 hook_id
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list, gboolean		 need_valids, GHookFindFunc		 func, gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find_data</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list, gboolean		 need_valids, gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find_func</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list, gboolean		 need_valids, gpointer		 func
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find_func_data</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list, gboolean		 need_valids, gpointer		 func, gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_first_valid</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list, gboolean		 may_be_in_call
</FUNCTION>
<FUNCTION>
<NAME>g_hook_next_valid</NAME>
<RETURNS>GHook *	 </RETURNS>
GHookList		*hook_list, GHook			*hook, gboolean		 may_be_in_call
</FUNCTION>
<FUNCTION>
<NAME>g_hook_compare_ids</NAME>
<RETURNS>gint 	 </RETURNS>
GHook			*new_hook, GHook			*sibling
</FUNCTION>
<MACRO>
<NAME>g_hook_append</NAME>
#define	 g_hook_append( hook_list, hook )  \
     g_hook_insert_before ((hook_list), NULL, (hook))
</MACRO>
<FUNCTION>
<NAME>g_hook_list_invoke</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, gboolean		 may_recurse
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_invoke_check</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, gboolean		 may_recurse
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_marshal</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, gboolean		 may_recurse, GHookMarshaller	 marshaller, gpointer		 marshal_data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_marshal_check</NAME>
<RETURNS>void 	 </RETURNS>
GHookList		*hook_list, gboolean		 may_recurse, GHookCheckMarshaller	 marshaller, gpointer		 marshal_data
</FUNCTION>
<FUNCTION>
<NAME>g_hostname_is_non_ascii</NAME>
<RETURNS>gboolean   </RETURNS>
const gchar *hostname
</FUNCTION>
<FUNCTION>
<NAME>g_hostname_is_ascii_encoded</NAME>
<RETURNS>gboolean   </RETURNS>
const gchar *hostname
</FUNCTION>
<FUNCTION>
<NAME>g_hostname_is_ip_address</NAME>
<RETURNS>gboolean   </RETURNS>
const gchar *hostname
</FUNCTION>
<FUNCTION>
<NAME>g_hostname_to_ascii</NAME>
<RETURNS>gchar     *</RETURNS>
const gchar *hostname
</FUNCTION>
<FUNCTION>
<NAME>g_hostname_to_unicode</NAME>
<RETURNS>gchar     *</RETURNS>
const gchar *hostname
</FUNCTION>
<MACRO>
<NAME>Q_</NAME>
#define Q_(String) g_dpgettext (GETTEXT_PACKAGE, String, 0)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#define N_(String) (String)
</MACRO>
<MACRO>
<NAME>C_</NAME>
#define C_(Context,String) g_dpgettext (GETTEXT_PACKAGE, Context "\004" String, strlen (Context) + 1)
</MACRO>
<MACRO>
<NAME>NC_</NAME>
#define NC_(Context, String) (String)
</MACRO>
<MACRO>
<NAME>Q_</NAME>
#define Q_(String) g_dpgettext (NULL, String, 0)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#define N_(String) (String)
</MACRO>
<MACRO>
<NAME>C_</NAME>
#define C_(Context,String) g_dpgettext (NULL, Context "\004" String, strlen (Context) + 1)
</MACRO>
<MACRO>
<NAME>NC_</NAME>
#define NC_(Context, String) (String)
</MACRO>
<ENUM>
<NAME>GIOError</NAME>
typedef enum
{
  G_IO_ERROR_NONE,
  G_IO_ERROR_AGAIN,
  G_IO_ERROR_INVAL,
  G_IO_ERROR_UNKNOWN
} GIOError;
</ENUM>
<MACRO>
<NAME>G_IO_CHANNEL_ERROR</NAME>
#define G_IO_CHANNEL_ERROR g_io_channel_error_quark()
</MACRO>
<ENUM>
<NAME>GIOChannelError</NAME>
typedef enum
{
  /* Derived from errno */
  G_IO_CHANNEL_ERROR_FBIG,
  G_IO_CHANNEL_ERROR_INVAL,
  G_IO_CHANNEL_ERROR_IO,
  G_IO_CHANNEL_ERROR_ISDIR,
  G_IO_CHANNEL_ERROR_NOSPC,
  G_IO_CHANNEL_ERROR_NXIO,
  G_IO_CHANNEL_ERROR_OVERFLOW,
  G_IO_CHANNEL_ERROR_PIPE,
  /* Other */
  G_IO_CHANNEL_ERROR_FAILED
} GIOChannelError;
</ENUM>
<ENUM>
<NAME>GIOStatus</NAME>
typedef enum
{
  G_IO_STATUS_ERROR,
  G_IO_STATUS_NORMAL,
  G_IO_STATUS_EOF,
  G_IO_STATUS_AGAIN
} GIOStatus;
</ENUM>
<ENUM>
<NAME>GSeekType</NAME>
typedef enum
{
  G_SEEK_CUR,
  G_SEEK_SET,
  G_SEEK_END
} GSeekType;
</ENUM>
<ENUM>
<NAME>GIOFlags</NAME>
typedef enum
{
  G_IO_FLAG_APPEND = 1 << 0,
  G_IO_FLAG_NONBLOCK = 1 << 1,
  G_IO_FLAG_IS_READABLE = 1 << 2,	/* Read only flag */
  G_IO_FLAG_IS_WRITABLE = 1 << 3,	/* Read only flag */
  G_IO_FLAG_IS_WRITEABLE = 1 << 3,      /* Misspelling in 2.29.10 and earlier */
  G_IO_FLAG_IS_SEEKABLE = 1 << 4,	/* Read only flag */
  G_IO_FLAG_MASK = (1 << 5) - 1,
  G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
  G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
} GIOFlags;
</ENUM>
<STRUCT>
<NAME>GIOChannel</NAME>
struct _GIOChannel
{
  /*< private >*/
  gint ref_count;
  GIOFuncs *funcs;

  gchar *encoding;
  GIConv read_cd;
  GIConv write_cd;
  gchar *line_term;		/* String which indicates the end of a line of text */
  guint line_term_len;		/* So we can have null in the line term */

  gsize buf_size;
  GString *read_buf;		/* Raw data from the channel */
  GString *encoded_read_buf;    /* Channel data converted to UTF-8 */
  GString *write_buf;		/* Data ready to be written to the file */
  gchar partial_write_buf[6];	/* UTF-8 partial characters, null terminated */

  /* Group the flags together, immediately after partial_write_buf, to save memory */

  guint use_buffer     : 1;	/* The encoding uses the buffers */
  guint do_encode      : 1;	/* The encoding uses the GIConv coverters */
  guint close_on_unref : 1;	/* Close the channel on final unref */
  guint is_readable    : 1;	/* Cached GIOFlag */
  guint is_writeable   : 1;	/* ditto */
  guint is_seekable    : 1;	/* ditto */

  gpointer reserved1;	
  gpointer reserved2;	
};
</STRUCT>
<USER_FUNCTION>
<NAME>GIOFunc</NAME>
<RETURNS>gboolean </RETURNS>
GIOChannel   *source,
			     GIOCondition  condition,
			     gpointer      data
</USER_FUNCTION>
<STRUCT>
<NAME>GIOFuncs</NAME>
struct _GIOFuncs
{
  GIOStatus (*io_read)           (GIOChannel   *channel, 
			          gchar        *buf, 
				  gsize         count,
				  gsize        *bytes_read,
				  GError      **err);
  GIOStatus (*io_write)          (GIOChannel   *channel, 
				  const gchar  *buf, 
				  gsize         count,
				  gsize        *bytes_written,
				  GError      **err);
  GIOStatus (*io_seek)           (GIOChannel   *channel, 
				  gint64        offset, 
				  GSeekType     type,
				  GError      **err);
  GIOStatus  (*io_close)         (GIOChannel   *channel,
				  GError      **err);
  GSource*   (*io_create_watch)  (GIOChannel   *channel,
				  GIOCondition  condition);
  void       (*io_free)          (GIOChannel   *channel);
  GIOStatus  (*io_set_flags)     (GIOChannel   *channel,
                                  GIOFlags      flags,
				  GError      **err);
  GIOFlags   (*io_get_flags)     (GIOChannel   *channel);
};
</STRUCT>
<FUNCTION>
<NAME>g_io_channel_init</NAME>
<RETURNS>void         </RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_ref</NAME>
<RETURNS>GIOChannel  *</RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_unref</NAME>
<RETURNS>void         </RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_read</NAME>
<DEPRECATED/>
<RETURNS>GIOError     </RETURNS>
GIOChannel    *channel, gchar         *buf, gsize          count, gsize         *bytes_read
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_write</NAME>
<DEPRECATED/>
<RETURNS>GIOError   </RETURNS>
GIOChannel    *channel, const gchar   *buf, gsize          count, gsize         *bytes_written
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_seek</NAME>
<DEPRECATED/>
<RETURNS>GIOError   </RETURNS>
GIOChannel    *channel, gint64         offset, GSeekType      type
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_close</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_shutdown</NAME>
<RETURNS>GIOStatus  </RETURNS>
GIOChannel      *channel, gboolean         flush, GError         **err
</FUNCTION>
<FUNCTION>
<NAME>g_io_add_watch_full</NAME>
<RETURNS>guint      </RETURNS>
GIOChannel      *channel, gint             priority, GIOCondition     condition, GIOFunc          func, gpointer         user_data, GDestroyNotify   notify
</FUNCTION>
<FUNCTION>
<NAME>g_io_create_watch</NAME>
<RETURNS>GSource  * </RETURNS>
GIOChannel      *channel, GIOCondition     condition
</FUNCTION>
<FUNCTION>
<NAME>g_io_add_watch</NAME>
<RETURNS>guint      </RETURNS>
GIOChannel      *channel, GIOCondition     condition, GIOFunc          func, gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_set_buffer_size</NAME>
<RETURNS>void                   </RETURNS>
GIOChannel   *channel, gsize         size
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_get_buffer_size</NAME>
<RETURNS>gsize                  </RETURNS>
GIOChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_get_buffer_condition</NAME>
<RETURNS>GIOCondition           </RETURNS>
GIOChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_set_flags</NAME>
<RETURNS>GIOStatus              </RETURNS>
GIOChannel   *channel, GIOFlags      flags, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_get_flags</NAME>
<RETURNS>GIOFlags               </RETURNS>
GIOChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_set_line_term</NAME>
<RETURNS>void                   </RETURNS>
GIOChannel   *channel, const gchar  *line_term, gint          length
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_get_line_term</NAME>
<RETURNS>const gchar  *         </RETURNS>
GIOChannel   *channel, gint         *length
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_set_buffered</NAME>
<RETURNS>void 		      </RETURNS>
GIOChannel   *channel, gboolean      buffered
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_get_buffered</NAME>
<RETURNS>gboolean 	      </RETURNS>
GIOChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_set_encoding</NAME>
<RETURNS>GIOStatus              </RETURNS>
GIOChannel   *channel, const gchar  *encoding, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_get_encoding</NAME>
<RETURNS>const gchar  *         </RETURNS>
GIOChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_set_close_on_unref</NAME>
<RETURNS>void                   </RETURNS>
GIOChannel   *channel, gboolean      do_close
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_get_close_on_unref</NAME>
<RETURNS>gboolean               </RETURNS>
GIOChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_flush</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_read_line</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, gchar       **str_return, gsize        *length, gsize        *terminator_pos, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_read_line_string</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, GString      *buffer, gsize        *terminator_pos, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_read_to_end</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, gchar       **str_return, gsize        *length, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_read_chars</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, gchar        *buf, gsize         count, gsize        *bytes_read, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_read_unichar</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, gunichar     *thechar, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_write_chars</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, const gchar  *buf, gssize        count, gsize        *bytes_written, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_write_unichar</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, gunichar      thechar, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_seek_position</NAME>
<RETURNS>GIOStatus    </RETURNS>
GIOChannel   *channel, gint64        offset, GSeekType     type, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_new_file</NAME>
<RETURNS>GIOChannel * </RETURNS>
const gchar  *filename, const gchar  *mode, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_error_quark</NAME>
<RETURNS>GQuark           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_error_from_errno</NAME>
<RETURNS>GIOChannelError  </RETURNS>
gint en
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_unix_new</NAME>
<RETURNS>GIOChannel * </RETURNS>
int         fd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_unix_get_fd</NAME>
<RETURNS>gint         </RETURNS>
GIOChannel *channel
</FUNCTION>
<VARIABLE>
<NAME>g_io_watch_funcs</NAME>
extern GSourceFuncs g_io_watch_funcs;
</VARIABLE>
<MACRO>
<NAME>G_WIN32_MSG_HANDLE</NAME>
#define G_WIN32_MSG_HANDLE 19981206
</MACRO>
<FUNCTION>
<NAME>g_io_channel_win32_make_pollfd</NAME>
<RETURNS>void         </RETURNS>
GIOChannel   *channel, GIOCondition  condition, GPollFD      *fd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_poll</NAME>
<RETURNS>gint         </RETURNS>
GPollFD    *fds, gint        n_fds, gint        timeout_
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_new_messages</NAME>
<RETURNS>GIOChannel  *</RETURNS>
gsize hwnd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_new_fd</NAME>
<RETURNS>GIOChannel * </RETURNS>
gint         fd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_get_fd</NAME>
<RETURNS>gint         </RETURNS>
GIOChannel *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_new_socket</NAME>
<RETURNS>GIOChannel  *</RETURNS>
gint socket
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_new_stream_socket</NAME>
<DEPRECATED/>
<RETURNS>GIOChannel  *</RETURNS>
gint socket
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_set_debug</NAME>
<RETURNS>void         </RETURNS>
GIOChannel *channel, gboolean    flag
</FUNCTION>
<ENUM>
<NAME>GKeyFileError</NAME>
typedef enum
{
  G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
  G_KEY_FILE_ERROR_PARSE,
  G_KEY_FILE_ERROR_NOT_FOUND,
  G_KEY_FILE_ERROR_KEY_NOT_FOUND,
  G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
  G_KEY_FILE_ERROR_INVALID_VALUE
} GKeyFileError;
</ENUM>
<MACRO>
<NAME>G_KEY_FILE_ERROR</NAME>
#define G_KEY_FILE_ERROR g_key_file_error_quark()
</MACRO>
<FUNCTION>
<NAME>g_key_file_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GKeyFileFlags</NAME>
typedef enum
{
  G_KEY_FILE_NONE              = 0,
  G_KEY_FILE_KEEP_COMMENTS     = 1 << 0,
  G_KEY_FILE_KEEP_TRANSLATIONS = 1 << 1
} GKeyFileFlags;
</ENUM>
<FUNCTION>
<NAME>g_key_file_new</NAME>
<RETURNS>GKeyFile  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_ref</NAME>
<RETURNS>GKeyFile  *</RETURNS>
GKeyFile             *key_file
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_unref</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_free</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_list_separator</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, gchar                 separator
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_load_from_file</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *file, GKeyFileFlags         flags, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_load_from_data</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *data, gsize                 length, GKeyFileFlags         flags, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_load_from_bytes</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, GBytes               *bytes, GKeyFileFlags         flags, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_load_from_dirs</NAME>
<RETURNS>gboolean  </RETURNS>
GKeyFile             *key_file, const gchar	  *file, const gchar	 **search_dirs, gchar		 **full_path, GKeyFileFlags         flags, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_load_from_data_dirs</NAME>
<RETURNS>gboolean  </RETURNS>
GKeyFile             *key_file, const gchar          *file, gchar               **full_path, GKeyFileFlags         flags, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_to_data</NAME>
<RETURNS>gchar     *</RETURNS>
GKeyFile             *key_file, gsize                *length, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_save_to_file</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *filename, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_start_group</NAME>
<RETURNS>gchar     *</RETURNS>
GKeyFile             *key_file
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_groups</NAME>
<RETURNS>gchar    **</RETURNS>
GKeyFile             *key_file, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_keys</NAME>
<RETURNS>gchar    **</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, gsize                *length, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_has_group</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *group_name
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_has_key</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_value</NAME>
<RETURNS>gchar     *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_value</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *value
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_string</NAME>
<RETURNS>gchar     *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_string</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *string
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_locale_string</NAME>
<RETURNS>gchar     *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *locale, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_locale_for_key</NAME>
<RETURNS>gchar     *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *locale
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_locale_string</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *locale, const gchar          *string
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_boolean</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_boolean</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gboolean              value
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_integer</NAME>
<RETURNS>gint       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_integer</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gint                  value
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_int64</NAME>
<RETURNS>gint64     </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_int64</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gint64                value
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_uint64</NAME>
<RETURNS>guint64    </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_uint64</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, guint64               value
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_double</NAME>
<RETURNS>gdouble    </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_double</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gdouble               value
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_string_list</NAME>
<RETURNS>gchar    **</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gsize                *length, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_string_list</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar * const   list[], gsize                 length
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_locale_string_list</NAME>
<RETURNS>gchar    **</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *locale, gsize                *length, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_locale_string_list</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *locale, const gchar * const   list[], gsize                 length
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_boolean_list</NAME>
<RETURNS>gboolean  *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gsize                *length, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_boolean_list</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gboolean              list[], gsize                 length
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_integer_list</NAME>
<RETURNS>gint      *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gsize                *length, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_double_list</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gdouble               list[], gsize                 length
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_double_list</NAME>
<RETURNS>gdouble   *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gsize                *length, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_integer_list</NAME>
<RETURNS>void       </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, gint                  list[], gsize                 length
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_set_comment</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, const gchar          *comment, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_get_comment</NAME>
<RETURNS>gchar     *</RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_remove_comment</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_remove_key</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, const gchar          *key, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_key_file_remove_group</NAME>
<RETURNS>gboolean   </RETURNS>
GKeyFile             *key_file, const gchar          *group_name, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_GROUP</NAME>
#define G_KEY_FILE_DESKTOP_GROUP                "Desktop Entry"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_TYPE</NAME>
#define G_KEY_FILE_DESKTOP_KEY_TYPE             "Type"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_VERSION</NAME>
#define G_KEY_FILE_DESKTOP_KEY_VERSION          "Version"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_NAME</NAME>
#define G_KEY_FILE_DESKTOP_KEY_NAME             "Name"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME</NAME>
#define G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME     "GenericName"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY</NAME>
#define G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY       "NoDisplay"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_COMMENT</NAME>
#define G_KEY_FILE_DESKTOP_KEY_COMMENT          "Comment"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_ICON</NAME>
#define G_KEY_FILE_DESKTOP_KEY_ICON             "Icon"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_HIDDEN</NAME>
#define G_KEY_FILE_DESKTOP_KEY_HIDDEN           "Hidden"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN</NAME>
#define G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN     "OnlyShowIn"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN</NAME>
#define G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN      "NotShowIn"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_TRY_EXEC</NAME>
#define G_KEY_FILE_DESKTOP_KEY_TRY_EXEC         "TryExec"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_EXEC</NAME>
#define G_KEY_FILE_DESKTOP_KEY_EXEC             "Exec"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_PATH</NAME>
#define G_KEY_FILE_DESKTOP_KEY_PATH             "Path"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_TERMINAL</NAME>
#define G_KEY_FILE_DESKTOP_KEY_TERMINAL         "Terminal"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_MIME_TYPE</NAME>
#define G_KEY_FILE_DESKTOP_KEY_MIME_TYPE        "MimeType"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_CATEGORIES</NAME>
#define G_KEY_FILE_DESKTOP_KEY_CATEGORIES       "Categories"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY</NAME>
#define G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY   "StartupNotify"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS</NAME>
#define G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS "StartupWMClass"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_URL</NAME>
#define G_KEY_FILE_DESKTOP_KEY_URL              "URL"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE</NAME>
#define G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE "DBusActivatable"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_KEY_ACTIONS</NAME>
#define G_KEY_FILE_DESKTOP_KEY_ACTIONS          "Actions"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_TYPE_APPLICATION</NAME>
#define G_KEY_FILE_DESKTOP_TYPE_APPLICATION     "Application"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_TYPE_LINK</NAME>
#define G_KEY_FILE_DESKTOP_TYPE_LINK            "Link"
</MACRO>
<MACRO>
<NAME>G_KEY_FILE_DESKTOP_TYPE_DIRECTORY</NAME>
#define G_KEY_FILE_DESKTOP_TYPE_DIRECTORY       "Directory"
</MACRO>
<STRUCT>
<NAME>GKeyFile</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_autoptr_cleanup_generic_gfree</NAME>
<RETURNS>void</RETURNS>
void *p
</FUNCTION>
<FUNCTION>
<NAME>g_autoptr_cleanup_gstring_free</NAME>
<RETURNS>void</RETURNS>
GString *string
</FUNCTION>
<MACRO>
<NAME>G_UNIX_ERROR</NAME>
#define G_UNIX_ERROR (g_unix_error_quark())
</MACRO>
<FUNCTION>
<NAME>g_unix_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_open_pipe</NAME>
<RETURNS>gboolean  </RETURNS>
gint    *fds, gint     flags, GError **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_set_fd_nonblocking</NAME>
<RETURNS>gboolean  </RETURNS>
gint       fd, gboolean   nonblock, GError   **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_signal_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
gint signum
</FUNCTION>
<FUNCTION>
<NAME>g_unix_signal_add_full</NAME>
<RETURNS>guint     </RETURNS>
gint           priority, gint           signum, GSourceFunc    handler, gpointer       user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>g_unix_signal_add</NAME>
<RETURNS>guint     </RETURNS>
gint        signum, GSourceFunc handler, gpointer    user_data
</FUNCTION>
<USER_FUNCTION>
<NAME>GUnixFDSourceFunc</NAME>
<RETURNS>gboolean </RETURNS>
gint         fd,
                                       GIOCondition condition,
                                       gpointer     user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
gint         fd, GIOCondition condition
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_add_full</NAME>
<RETURNS>guint     </RETURNS>
gint              priority, gint              fd, GIOCondition      condition, GUnixFDSourceFunc function, gpointer          user_data, GDestroyNotify    notify
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_add</NAME>
<RETURNS>guint     </RETURNS>
gint              fd, GIOCondition      condition, GUnixFDSourceFunc function, gpointer          user_data
</FUNCTION>
<STRUCT>
<NAME>GList</NAME>
struct _GList
{
  gpointer data;
  GList *next;
  GList *prev;
};
</STRUCT>
<FUNCTION>
<NAME>g_list_alloc</NAME>
<RETURNS>GList *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_list_free</NAME>
<RETURNS>void      </RETURNS>
GList            *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_free_1</NAME>
<RETURNS>void      </RETURNS>
GList            *list
</FUNCTION>
<MACRO>
<NAME>g_list_free1</NAME>
#define  g_list_free1                   g_list_free_1
</MACRO>
<FUNCTION>
<NAME>g_list_free_full</NAME>
<RETURNS>void      </RETURNS>
GList            *list, GDestroyNotify    free_func
</FUNCTION>
<FUNCTION>
<NAME>g_list_append</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_list_prepend</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_list_insert</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gpointer          data, gint              position
</FUNCTION>
<FUNCTION>
<NAME>g_list_insert_sorted</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gpointer          data, GCompareFunc      func
</FUNCTION>
<FUNCTION>
<NAME>g_list_insert_sorted_with_data</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gpointer          data, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_list_insert_before</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, GList            *sibling, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_list_concat</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list1, GList            *list2
</FUNCTION>
<FUNCTION>
<NAME>g_list_remove</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_list_remove_all</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_list_remove_link</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, GList            *llink
</FUNCTION>
<FUNCTION>
<NAME>g_list_delete_link</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, GList            *link_
</FUNCTION>
<FUNCTION>
<NAME>g_list_reverse</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_copy</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_copy_deep</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, GCopyFunc         func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_list_nth</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, guint             n
</FUNCTION>
<FUNCTION>
<NAME>g_list_nth_prev</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, guint             n
</FUNCTION>
<FUNCTION>
<NAME>g_list_find</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_list_find_custom</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, gconstpointer     data, GCompareFunc      func
</FUNCTION>
<FUNCTION>
<NAME>g_list_position</NAME>
<RETURNS>gint      </RETURNS>
GList            *list, GList            *llink
</FUNCTION>
<FUNCTION>
<NAME>g_list_index</NAME>
<RETURNS>gint      </RETURNS>
GList            *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_list_last</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_first</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_length</NAME>
<RETURNS>guint     </RETURNS>
GList            *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_foreach</NAME>
<RETURNS>void      </RETURNS>
GList            *list, GFunc             func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_list_sort</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, GCompareFunc      compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_list_sort_with_data</NAME>
<RETURNS>GList *   </RETURNS>
GList            *list, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_list_nth_data</NAME>
<RETURNS>gpointer  </RETURNS>
GList            *list, guint             n
</FUNCTION>
<MACRO>
<NAME>g_list_previous</NAME>
#define g_list_previous(list)	        ((list) ? (((GList *)(list))->prev) : NULL)
</MACRO>
<MACRO>
<NAME>g_list_next</NAME>
#define g_list_next(list)	        ((list) ? (((GList *)(list))->next) : NULL)
</MACRO>
<MACRO>
<NAME>G_GNUC_CHECK_VERSION</NAME>
#define G_GNUC_CHECK_VERSION(major, minor) \
    ((__GNUC__ > (major)) || \
     ((__GNUC__ == (major)) && \
      (__GNUC_MINOR__ >= (minor))))
</MACRO>
<MACRO>
<NAME>G_GNUC_EXTENSION</NAME>
#define G_GNUC_EXTENSION __extension__
</MACRO>
<MACRO>
<NAME>G_CAN_INLINE</NAME>
#define G_CAN_INLINE
</MACRO>
<MACRO>
<NAME>G_INLINE_DEFINE_NEEDED</NAME>
#   define G_INLINE_DEFINE_NEEDED
</MACRO>
<MACRO>
<NAME>inline</NAME>
# define inline __inline
</MACRO>
<MACRO>
<NAME>G_INLINE_FUNC</NAME>
#  define G_INLINE_FUNC extern
</MACRO>
<MACRO>
<NAME>G_GNUC_PURE</NAME>
#define G_GNUC_PURE __attribute__((__pure__))
</MACRO>
<MACRO>
<NAME>G_GNUC_MALLOC</NAME>
#define G_GNUC_MALLOC __attribute__((__malloc__))
</MACRO>
<MACRO>
<NAME>G_GNUC_NULL_TERMINATED</NAME>
#define G_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
</MACRO>
<MACRO>
<NAME>G_GNUC_ALLOC_SIZE</NAME>
#define G_GNUC_ALLOC_SIZE(x) __attribute__((__alloc_size__(x)))
</MACRO>
<MACRO>
<NAME>G_GNUC_ALLOC_SIZE2</NAME>
#define G_GNUC_ALLOC_SIZE2(x,y) __attribute__((__alloc_size__(x,y)))
</MACRO>
<MACRO>
<NAME>G_GNUC_PRINTF</NAME>
#define G_GNUC_PRINTF( format_idx, arg_idx )    \
  __attribute__((__format__ (__printf__, format_idx, arg_idx)))
</MACRO>
<MACRO>
<NAME>G_GNUC_SCANF</NAME>
#define G_GNUC_SCANF( format_idx, arg_idx )     \
  __attribute__((__format__ (__scanf__, format_idx, arg_idx)))
</MACRO>
<MACRO>
<NAME>G_GNUC_FORMAT</NAME>
#define G_GNUC_FORMAT( arg_idx )                \
  __attribute__((__format_arg__ (arg_idx)))
</MACRO>
<MACRO>
<NAME>G_GNUC_NORETURN</NAME>
#define G_GNUC_NORETURN                         \
  __attribute__((__noreturn__))
</MACRO>
<MACRO>
<NAME>G_GNUC_CONST</NAME>
#define G_GNUC_CONST                            \
  __attribute__((__const__))
</MACRO>
<MACRO>
<NAME>G_GNUC_UNUSED</NAME>
#define G_GNUC_UNUSED                           \
  __attribute__((__unused__))
</MACRO>
<MACRO>
<NAME>G_GNUC_NO_INSTRUMENT</NAME>
#define G_GNUC_NO_INSTRUMENT			\
  __attribute__((__no_instrument_function__))
</MACRO>
<MACRO>
<NAME>G_GNUC_DEPRECATED</NAME>
#define G_GNUC_DEPRECATED __attribute__((__deprecated__))
</MACRO>
<MACRO>
<NAME>G_GNUC_DEPRECATED_FOR</NAME>
#define G_GNUC_DEPRECATED_FOR(f)                        \
  __attribute__((deprecated("Use " #f " instead")))
</MACRO>
<MACRO>
<NAME>G_GNUC_BEGIN_IGNORE_DEPRECATIONS</NAME>
#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS                \
  _Pragma ("warning (push)")                            \
  _Pragma ("warning (disable:1478)")
</MACRO>
<MACRO>
<NAME>G_GNUC_END_IGNORE_DEPRECATIONS</NAME>
#define G_GNUC_END_IGNORE_DEPRECATIONS			\
  _Pragma ("warning (pop)")
</MACRO>
<MACRO>
<NAME>G_GNUC_MAY_ALIAS</NAME>
#define G_GNUC_MAY_ALIAS __attribute__((may_alias))
</MACRO>
<MACRO>
<NAME>G_GNUC_WARN_UNUSED_RESULT</NAME>
#define G_GNUC_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
</MACRO>
<MACRO>
<NAME>G_GNUC_FUNCTION</NAME>
<DEPRECATED/>
#define G_GNUC_FUNCTION         __FUNCTION__
</MACRO>
<MACRO>
<NAME>G_GNUC_PRETTY_FUNCTION</NAME>
<DEPRECATED/>
#define G_GNUC_PRETTY_FUNCTION  __PRETTY_FUNCTION__
</MACRO>
<MACRO>
<NAME>G_ANALYZER_ANALYZING</NAME>
<DEPRECATED/>
#define G_ANALYZER_ANALYZING 1
</MACRO>
<MACRO>
<NAME>G_ANALYZER_NORETURN</NAME>
#define G_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
</MACRO>
<MACRO>
<NAME>G_STRINGIFY</NAME>
#define G_STRINGIFY(macro_or_string)	G_STRINGIFY_ARG (macro_or_string)
</MACRO>
<MACRO>
<NAME>G_STRINGIFY_ARG</NAME>
#define	G_STRINGIFY_ARG(contents)	#contents
</MACRO>
<MACRO>
<NAME>G_PASTE_ARGS</NAME>
#define G_PASTE_ARGS(identifier1,identifier2) identifier1 ## identifier2
</MACRO>
<MACRO>
<NAME>G_PASTE</NAME>
#define G_PASTE(identifier1,identifier2)      G_PASTE_ARGS (identifier1, identifier2)
</MACRO>
<MACRO>
<NAME>G_STATIC_ASSERT</NAME>
#define G_STATIC_ASSERT(expr) typedef char G_PASTE (_GStaticAssertCompileTimeAssertion_, __COUNTER__)[(expr) ? 1 : -1] G_GNUC_UNUSED
</MACRO>
<MACRO>
<NAME>G_STATIC_ASSERT_EXPR</NAME>
#define G_STATIC_ASSERT_EXPR(expr) ((void) sizeof (char[(expr) ? 1 : -1]))
</MACRO>
<MACRO>
<NAME>G_STRLOC</NAME>
#define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__) ":" __PRETTY_FUNCTION__ "()"
</MACRO>
<MACRO>
<NAME>G_STRFUNC</NAME>
#define G_STRFUNC     ((const char*) (__PRETTY_FUNCTION__))
</MACRO>
<MACRO>
<NAME>G_BEGIN_DECLS</NAME>
#define G_BEGIN_DECLS  extern "C" {
</MACRO>
<MACRO>
<NAME>G_END_DECLS</NAME>
#define G_END_DECLS    }
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#  define NULL        (0L)
</MACRO>
<MACRO>
<NAME>FALSE</NAME>
#define	FALSE	(0)
</MACRO>
<MACRO>
<NAME>TRUE</NAME>
#define	TRUE	(!FALSE)
</MACRO>
<MACRO>
<NAME>MAX</NAME>
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
</MACRO>
<MACRO>
<NAME>MIN</NAME>
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
</MACRO>
<MACRO>
<NAME>ABS</NAME>
#define ABS(a)	   (((a) < 0) ? -(a) : (a))
</MACRO>
<MACRO>
<NAME>CLAMP</NAME>
#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
</MACRO>
<MACRO>
<NAME>G_N_ELEMENTS</NAME>
#define G_N_ELEMENTS(arr)		(sizeof (arr) / sizeof ((arr)[0]))
</MACRO>
<MACRO>
<NAME>GPOINTER_TO_SIZE</NAME>
#define GPOINTER_TO_SIZE(p)	((gsize) (p))
</MACRO>
<MACRO>
<NAME>GSIZE_TO_POINTER</NAME>
#define GSIZE_TO_POINTER(s)	((gpointer) (gsize) (s))
</MACRO>
<MACRO>
<NAME>G_STRUCT_OFFSET</NAME>
#define G_STRUCT_OFFSET(struct_type, member) \
      ((glong) offsetof (struct_type, member))
</MACRO>
<MACRO>
<NAME>G_STRUCT_MEMBER_P</NAME>
#define G_STRUCT_MEMBER_P(struct_p, struct_offset)   \
    ((gpointer) ((guint8*) (struct_p) + (glong) (struct_offset)))
</MACRO>
<MACRO>
<NAME>G_STRUCT_MEMBER</NAME>
#define G_STRUCT_MEMBER(member_type, struct_p, struct_offset)   \
    (*(member_type*) G_STRUCT_MEMBER_P ((struct_p), (struct_offset)))
</MACRO>
<MACRO>
<NAME>G_STMT_START</NAME>
#define G_STMT_START  do
</MACRO>
<MACRO>
<NAME>G_STMT_END</NAME>
#define G_STMT_END \
    __pragma(warning(push)) \
    __pragma(warning(disable:4127)) \
    while(0) \
    __pragma(warning(pop))
</MACRO>
<MACRO>
<NAME>G_CONST_RETURN</NAME>
<DEPRECATED/>
#define G_CONST_RETURN
</MACRO>
<MACRO>
<NAME>G_LIKELY</NAME>
#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR((expr)), 1))
</MACRO>
<MACRO>
<NAME>G_UNLIKELY</NAME>
#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR((expr)), 0))
</MACRO>
<MACRO>
<NAME>G_DEPRECATED</NAME>
#define G_DEPRECATED __attribute__((__deprecated__))
</MACRO>
<MACRO>
<NAME>G_DEPRECATED_FOR</NAME>
#define G_DEPRECATED_FOR(f) __attribute__((__deprecated__("Use '" #f "' instead")))
</MACRO>
<MACRO>
<NAME>G_UNAVAILABLE</NAME>
#define G_UNAVAILABLE(maj,min) __attribute__((deprecated("Not available before " #maj "." #min)))
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED</NAME>
#define GLIB_DEPRECATED _GLIB_EXTERN
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_FOR</NAME>
#define GLIB_DEPRECATED_FOR(f) _GLIB_EXTERN
</MACRO>
<MACRO>
<NAME>GLIB_UNAVAILABLE</NAME>
#define GLIB_UNAVAILABLE(maj,min) _GLIB_EXTERN
</MACRO>
<MACRO>
<NAME>G_DEFINE_AUTOPTR_CLEANUP_FUNC</NAME>
#define G_DEFINE_AUTOPTR_CLEANUP_FUNC(TypeName, func) \
  typedef TypeName *_GLIB_AUTOPTR_TYPENAME(TypeName);                                                           \
  typedef GList *_GLIB_AUTOPTR_LIST_TYPENAME(TypeName);                                                         \
  typedef GSList *_GLIB_AUTOPTR_SLIST_TYPENAME(TypeName);                                                         \
  G_GNUC_BEGIN_IGNORE_DEPRECATIONS                                                                              \
  static inline void _GLIB_AUTOPTR_FUNC_NAME(TypeName) (TypeName **_ptr) { if (*_ptr) (func) (*_ptr); }         \
  static inline void _GLIB_AUTOPTR_LIST_FUNC_NAME(TypeName) (GList **_l) { g_list_free_full (*_l, (GDestroyNotify) func); } \
  static inline void _GLIB_AUTOPTR_SLIST_FUNC_NAME(TypeName) (GSList **_l) { g_slist_free_full (*_l, (GDestroyNotify) func); } \
  G_GNUC_END_IGNORE_DEPRECATIONS
</MACRO>
<MACRO>
<NAME>G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC</NAME>
#define G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(TypeName, func) \
  G_GNUC_BEGIN_IGNORE_DEPRECATIONS                                                                              \
  static inline void _GLIB_AUTO_FUNC_NAME(TypeName) (TypeName *_ptr) { (func) (_ptr); }                         \
  G_GNUC_END_IGNORE_DEPRECATIONS
</MACRO>
<MACRO>
<NAME>G_DEFINE_AUTO_CLEANUP_FREE_FUNC</NAME>
#define G_DEFINE_AUTO_CLEANUP_FREE_FUNC(TypeName, func, none) \
  G_GNUC_BEGIN_IGNORE_DEPRECATIONS                                                                              \
  static inline void _GLIB_AUTO_FUNC_NAME(TypeName) (TypeName *_ptr) { if (*_ptr != none) (func) (*_ptr); }     \
  G_GNUC_END_IGNORE_DEPRECATIONS
</MACRO>
<MACRO>
<NAME>g_autoptr</NAME>
#define g_autoptr(TypeName) _GLIB_CLEANUP(_GLIB_AUTOPTR_FUNC_NAME(TypeName)) _GLIB_AUTOPTR_TYPENAME(TypeName)
</MACRO>
<MACRO>
<NAME>g_autolist</NAME>
#define g_autolist(TypeName) _GLIB_CLEANUP(_GLIB_AUTOPTR_LIST_FUNC_NAME(TypeName)) _GLIB_AUTOPTR_LIST_TYPENAME(TypeName)
</MACRO>
<MACRO>
<NAME>g_autoslist</NAME>
#define g_autoslist(TypeName) _GLIB_CLEANUP(_GLIB_AUTOPTR_SLIST_FUNC_NAME(TypeName)) _GLIB_AUTOPTR_SLIST_TYPENAME(TypeName)
</MACRO>
<MACRO>
<NAME>g_auto</NAME>
#define g_auto(TypeName) _GLIB_CLEANUP(_GLIB_AUTO_FUNC_NAME(TypeName)) TypeName
</MACRO>
<MACRO>
<NAME>g_autofree</NAME>
#define g_autofree _GLIB_CLEANUP(g_autoptr_cleanup_generic_gfree)
</MACRO>
<ENUM>
<NAME>GIOCondition</NAME>
typedef enum /*< flags >*/
{
  G_IO_IN	GLIB_SYSDEF_POLLIN,
  G_IO_OUT	GLIB_SYSDEF_POLLOUT,
  G_IO_PRI	GLIB_SYSDEF_POLLPRI,
  G_IO_ERR	GLIB_SYSDEF_POLLERR,
  G_IO_HUP	GLIB_SYSDEF_POLLHUP,
  G_IO_NVAL	GLIB_SYSDEF_POLLNVAL
} GIOCondition;
</ENUM>
<USER_FUNCTION>
<NAME>GSourceFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GChildWatchFunc</NAME>
<RETURNS>void </RETURNS>
GPid     pid,
                                       gint     status,
                                       gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GSource</NAME>
struct _GSource
{
  /*< private >*/
  gpointer callback_data;
  GSourceCallbackFuncs *callback_funcs;

  const GSourceFuncs *source_funcs;
  guint ref_count;

  GMainContext *context;

  gint priority;
  guint flags;
  guint source_id;

  GSList *poll_fds;
  
  GSource *prev;
  GSource *next;

  char    *name;

  GSourcePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSourceCallbackFuncs</NAME>
struct _GSourceCallbackFuncs
{
  void (*ref)   (gpointer     cb_data);
  void (*unref) (gpointer     cb_data);
  void (*get)   (gpointer     cb_data,
                 GSource     *source, 
                 GSourceFunc *func,
                 gpointer    *data);
};
</STRUCT>
<USER_FUNCTION>
<NAME>GSourceDummyMarshal</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<STRUCT>
<NAME>GSourceFuncs</NAME>
struct _GSourceFuncs
{
  gboolean (*prepare)  (GSource    *source,
                        gint       *timeout_);
  gboolean (*check)    (GSource    *source);
  gboolean (*dispatch) (GSource    *source,
                        GSourceFunc callback,
                        gpointer    user_data);
  void     (*finalize) (GSource    *source); /* Can be NULL */

  /*< private >*/
  /* For use by g_source_set_closure */
  GSourceFunc     closure_callback;        
  GSourceDummyMarshal closure_marshal; /* Really is of type GClosureMarshal */
};
</STRUCT>
<MACRO>
<NAME>G_PRIORITY_HIGH</NAME>
#define G_PRIORITY_HIGH            -100
</MACRO>
<MACRO>
<NAME>G_PRIORITY_DEFAULT</NAME>
#define G_PRIORITY_DEFAULT          0
</MACRO>
<MACRO>
<NAME>G_PRIORITY_HIGH_IDLE</NAME>
#define G_PRIORITY_HIGH_IDLE        100
</MACRO>
<MACRO>
<NAME>G_PRIORITY_DEFAULT_IDLE</NAME>
#define G_PRIORITY_DEFAULT_IDLE     200
</MACRO>
<MACRO>
<NAME>G_PRIORITY_LOW</NAME>
#define G_PRIORITY_LOW              300
</MACRO>
<MACRO>
<NAME>G_SOURCE_REMOVE</NAME>
#define G_SOURCE_REMOVE         FALSE
</MACRO>
<MACRO>
<NAME>G_SOURCE_CONTINUE</NAME>
#define G_SOURCE_CONTINUE       TRUE
</MACRO>
<FUNCTION>
<NAME>g_main_context_new</NAME>
<RETURNS>GMainContext  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_ref</NAME>
<RETURNS>GMainContext  *</RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_unref</NAME>
<RETURNS>void           </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_default</NAME>
<RETURNS>GMainContext  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_iteration</NAME>
<RETURNS>gboolean       </RETURNS>
GMainContext *context, gboolean      may_block
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_pending</NAME>
<RETURNS>gboolean       </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_find_source_by_id</NAME>
<RETURNS>GSource       *</RETURNS>
GMainContext *context, guint         source_id
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_find_source_by_user_data</NAME>
<RETURNS>GSource       *</RETURNS>
GMainContext *context, gpointer      user_data
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_find_source_by_funcs_user_data</NAME>
<RETURNS>GSource       *</RETURNS>
GMainContext *context, GSourceFuncs *funcs, gpointer      user_data
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_wakeup</NAME>
<RETURNS>void      </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_acquire</NAME>
<RETURNS>gboolean  </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_release</NAME>
<RETURNS>void      </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_is_owner</NAME>
<RETURNS>gboolean  </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_wait</NAME>
<RETURNS>gboolean  </RETURNS>
GMainContext *context, GCond        *cond, GMutex       *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_prepare</NAME>
<RETURNS>gboolean  </RETURNS>
GMainContext *context, gint         *priority
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_query</NAME>
<RETURNS>gint      </RETURNS>
GMainContext *context, gint          max_priority, gint         *timeout_, GPollFD      *fds, gint          n_fds
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_check</NAME>
<RETURNS>gboolean      </RETURNS>
GMainContext *context, gint          max_priority, GPollFD      *fds, gint          n_fds
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_dispatch</NAME>
<RETURNS>void      </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_set_poll_func</NAME>
<RETURNS>void      </RETURNS>
GMainContext *context, GPollFunc     func
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_get_poll_func</NAME>
<RETURNS>GPollFunc  </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_add_poll</NAME>
<RETURNS>void      </RETURNS>
GMainContext *context, GPollFD      *fd, gint          priority
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_remove_poll</NAME>
<RETURNS>void      </RETURNS>
GMainContext *context, GPollFD      *fd
</FUNCTION>
<FUNCTION>
<NAME>g_main_depth</NAME>
<RETURNS>gint      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_main_current_source</NAME>
<RETURNS>GSource  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_push_thread_default</NAME>
<RETURNS>void           </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_pop_thread_default</NAME>
<RETURNS>void           </RETURNS>
GMainContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_get_thread_default</NAME>
<RETURNS>GMainContext  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_ref_thread_default</NAME>
<RETURNS>GMainContext  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_main_loop_new</NAME>
<RETURNS>GMainLoop  *</RETURNS>
GMainContext *context, gboolean      is_running
</FUNCTION>
<FUNCTION>
<NAME>g_main_loop_run</NAME>
<RETURNS>void        </RETURNS>
GMainLoop    *loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_loop_quit</NAME>
<RETURNS>void        </RETURNS>
GMainLoop    *loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_loop_ref</NAME>
<RETURNS>GMainLoop  *</RETURNS>
GMainLoop    *loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_loop_unref</NAME>
<RETURNS>void        </RETURNS>
GMainLoop    *loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_loop_is_running</NAME>
<RETURNS>gboolean    </RETURNS>
GMainLoop    *loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_loop_get_context</NAME>
<RETURNS>GMainContext  *</RETURNS>
GMainLoop    *loop
</FUNCTION>
<FUNCTION>
<NAME>g_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
GSourceFuncs   *source_funcs, guint           struct_size
</FUNCTION>
<FUNCTION>
<NAME>g_source_ref</NAME>
<RETURNS>GSource  *</RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_unref</NAME>
<RETURNS>void      </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_attach</NAME>
<RETURNS>guint     </RETURNS>
GSource        *source, GMainContext   *context
</FUNCTION>
<FUNCTION>
<NAME>g_source_destroy</NAME>
<RETURNS>void      </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_priority</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, gint            priority
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_priority</NAME>
<RETURNS>gint      </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_can_recurse</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, gboolean        can_recurse
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_can_recurse</NAME>
<RETURNS>gboolean  </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_id</NAME>
<RETURNS>guint     </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_context</NAME>
<RETURNS>GMainContext  *</RETURNS>
GSource       *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_callback</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, GSourceFunc     func, gpointer        data, GDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_funcs</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, GSourceFuncs   *funcs
</FUNCTION>
<FUNCTION>
<NAME>g_source_is_destroyed</NAME>
<RETURNS>gboolean  </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_name</NAME>
<RETURNS>void                  </RETURNS>
GSource        *source, const char     *name
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_name</NAME>
<RETURNS>const char  *         </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_name_by_id</NAME>
<RETURNS>void                  </RETURNS>
guint           tag, const char     *name
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_ready_time</NAME>
<RETURNS>void                  </RETURNS>
GSource        *source, gint64          ready_time
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_ready_time</NAME>
<RETURNS>gint64                </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_source_add_unix_fd</NAME>
<RETURNS>gpointer              </RETURNS>
GSource        *source, gint            fd, GIOCondition    events
</FUNCTION>
<FUNCTION>
<NAME>g_source_modify_unix_fd</NAME>
<RETURNS>void                  </RETURNS>
GSource        *source, gpointer        tag, GIOCondition    new_events
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_unix_fd</NAME>
<RETURNS>void                  </RETURNS>
GSource        *source, gpointer        tag
</FUNCTION>
<FUNCTION>
<NAME>g_source_query_unix_fd</NAME>
<RETURNS>GIOCondition          </RETURNS>
GSource        *source, gpointer        tag
</FUNCTION>
<FUNCTION>
<NAME>g_source_set_callback_indirect</NAME>
<RETURNS>void  </RETURNS>
GSource              *source, gpointer              callback_data, GSourceCallbackFuncs *callback_funcs
</FUNCTION>
<FUNCTION>
<NAME>g_source_add_poll</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, GPollFD        *fd
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_poll</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, GPollFD        *fd
</FUNCTION>
<FUNCTION>
<NAME>g_source_add_child_source</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, GSource        *child_source
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_child_source</NAME>
<RETURNS>void      </RETURNS>
GSource        *source, GSource        *child_source
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_current_time</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GSource        *source, GTimeVal       *timeval
</FUNCTION>
<FUNCTION>
<NAME>g_source_get_time</NAME>
<RETURNS>gint64    </RETURNS>
GSource        *source
</FUNCTION>
<FUNCTION>
<NAME>g_idle_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_child_watch_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
GPid pid
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
guint interval
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_source_new_seconds</NAME>
<RETURNS>GSource  *</RETURNS>
guint interval
</FUNCTION>
<FUNCTION>
<NAME>g_get_current_time</NAME>
<RETURNS>void    </RETURNS>
GTimeVal       *result
</FUNCTION>
<FUNCTION>
<NAME>g_get_monotonic_time</NAME>
<RETURNS>gint64  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_real_time</NAME>
<RETURNS>gint64  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove</NAME>
<RETURNS>gboolean  </RETURNS>
guint          tag
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_by_user_data</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer       user_data
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_by_funcs_user_data</NAME>
<RETURNS>gboolean  </RETURNS>
GSourceFuncs  *funcs, gpointer       user_data
</FUNCTION>
<USER_FUNCTION>
<NAME>GClearHandleFunc</NAME>
<RETURNS>void </RETURNS>
guint handle_id
</USER_FUNCTION>
<FUNCTION>
<NAME>g_clear_handle_id</NAME>
<RETURNS>void     </RETURNS>
guint           *tag_ptr, GClearHandleFunc clear_func
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_add_full</NAME>
<RETURNS>guint     </RETURNS>
gint            priority, guint           interval, GSourceFunc     function, gpointer        data, GDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_add</NAME>
<RETURNS>guint     </RETURNS>
guint           interval, GSourceFunc     function, gpointer        data
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_add_seconds_full</NAME>
<RETURNS>guint     </RETURNS>
gint            priority, guint           interval, GSourceFunc     function, gpointer        data, GDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_add_seconds</NAME>
<RETURNS>guint     </RETURNS>
guint           interval, GSourceFunc     function, gpointer        data
</FUNCTION>
<FUNCTION>
<NAME>g_child_watch_add_full</NAME>
<RETURNS>guint     </RETURNS>
gint            priority, GPid            pid, GChildWatchFunc function, gpointer        data, GDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>g_child_watch_add</NAME>
<RETURNS>guint     </RETURNS>
GPid            pid, GChildWatchFunc function, gpointer        data
</FUNCTION>
<FUNCTION>
<NAME>g_idle_add</NAME>
<RETURNS>guint     </RETURNS>
GSourceFunc     function, gpointer        data
</FUNCTION>
<FUNCTION>
<NAME>g_idle_add_full</NAME>
<RETURNS>guint     </RETURNS>
gint            priority, GSourceFunc     function, gpointer        data, GDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>g_idle_remove_by_data</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer        data
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_invoke_full</NAME>
<RETURNS>void      </RETURNS>
GMainContext   *context, gint            priority, GSourceFunc     function, gpointer        data, GDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>g_main_context_invoke</NAME>
<RETURNS>void      </RETURNS>
GMainContext   *context, GSourceFunc     function, gpointer        data
</FUNCTION>
<VARIABLE>
<NAME>g_timeout_funcs</NAME>
extern GSourceFuncs g_timeout_funcs;
</VARIABLE>
<VARIABLE>
<NAME>g_child_watch_funcs</NAME>
extern GSourceFuncs g_child_watch_funcs;
</VARIABLE>
<VARIABLE>
<NAME>g_idle_funcs</NAME>
extern GSourceFuncs g_idle_funcs;
</VARIABLE>
<VARIABLE>
<NAME>g_unix_signal_funcs</NAME>
extern GSourceFuncs g_unix_signal_funcs;
</VARIABLE>
<VARIABLE>
<NAME>g_unix_fd_source_funcs</NAME>
extern GSourceFuncs g_unix_fd_source_funcs;
</VARIABLE>
<STRUCT>
<NAME>GMainContext</NAME>
</STRUCT>
<STRUCT>
<NAME>GMainLoop</NAME>
</STRUCT>
<STRUCT>
<NAME>GSourcePrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_mapped_file_new</NAME>
<RETURNS>GMappedFile  *</RETURNS>
const gchar  *filename, gboolean      writable, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_mapped_file_new_from_fd</NAME>
<RETURNS>GMappedFile  *</RETURNS>
gint          fd, gboolean      writable, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_mapped_file_get_length</NAME>
<RETURNS>gsize         </RETURNS>
GMappedFile  *file
</FUNCTION>
<FUNCTION>
<NAME>g_mapped_file_get_contents</NAME>
<RETURNS>gchar        *</RETURNS>
GMappedFile  *file
</FUNCTION>
<FUNCTION>
<NAME>g_mapped_file_get_bytes</NAME>
<RETURNS>GBytes  *     </RETURNS>
GMappedFile  *file
</FUNCTION>
<FUNCTION>
<NAME>g_mapped_file_ref</NAME>
<RETURNS>GMappedFile  *</RETURNS>
GMappedFile  *file
</FUNCTION>
<FUNCTION>
<NAME>g_mapped_file_unref</NAME>
<RETURNS>void          </RETURNS>
GMappedFile  *file
</FUNCTION>
<FUNCTION>
<NAME>g_mapped_file_free</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GMappedFile  *file
</FUNCTION>
<STRUCT>
<NAME>GMappedFile</NAME>
</STRUCT>
<ENUM>
<NAME>GMarkupError</NAME>
typedef enum
{
  G_MARKUP_ERROR_BAD_UTF8,
  G_MARKUP_ERROR_EMPTY,
  G_MARKUP_ERROR_PARSE,
  /* The following are primarily intended for specific GMarkupParser
   * implementations to set.
   */
  G_MARKUP_ERROR_UNKNOWN_ELEMENT,
  G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
  G_MARKUP_ERROR_INVALID_CONTENT,
  G_MARKUP_ERROR_MISSING_ATTRIBUTE
} GMarkupError;
</ENUM>
<MACRO>
<NAME>G_MARKUP_ERROR</NAME>
#define G_MARKUP_ERROR g_markup_error_quark ()
</MACRO>
<FUNCTION>
<NAME>g_markup_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GMarkupParseFlags</NAME>
typedef enum
{
  G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0,
  G_MARKUP_TREAT_CDATA_AS_TEXT              = 1 << 1,
  G_MARKUP_PREFIX_ERROR_POSITION            = 1 << 2,
  G_MARKUP_IGNORE_QUALIFIED                 = 1 << 3
} GMarkupParseFlags;
</ENUM>
<STRUCT>
<NAME>GMarkupParser</NAME>
struct _GMarkupParser
{
  /* Called for open tags <foo bar="baz"> */
  void (*start_element)  (GMarkupParseContext *context,
                          const gchar         *element_name,
                          const gchar        **attribute_names,
                          const gchar        **attribute_values,
                          gpointer             user_data,
                          GError             **error);

  /* Called for close tags </foo> */
  void (*end_element)    (GMarkupParseContext *context,
                          const gchar         *element_name,
                          gpointer             user_data,
                          GError             **error);

  /* Called for character data */
  /* text is not nul-terminated */
  void (*text)           (GMarkupParseContext *context,
                          const gchar         *text,
                          gsize                text_len,
                          gpointer             user_data,
                          GError             **error);

  /* Called for strings that should be re-saved verbatim in this same
   * position, but are not otherwise interpretable.  At the moment
   * this includes comments and processing instructions.
   */
  /* text is not nul-terminated. */
  void (*passthrough)    (GMarkupParseContext *context,
                          const gchar         *passthrough_text,
                          gsize                text_len,
                          gpointer             user_data,
                          GError             **error);

  /* Called on error, including one set by other
   * methods in the vtable. The GError should not be freed.
   */
  void (*error)          (GMarkupParseContext *context,
                          GError              *error,
                          gpointer             user_data);
};
</STRUCT>
<FUNCTION>
<NAME>g_markup_parse_context_new</NAME>
<RETURNS>GMarkupParseContext  *</RETURNS>
const GMarkupParser *parser, GMarkupParseFlags    flags, gpointer             user_data, GDestroyNotify       user_data_dnotify
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_ref</NAME>
<RETURNS>GMarkupParseContext  *</RETURNS>
GMarkupParseContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_unref</NAME>
<RETURNS>void                  </RETURNS>
GMarkupParseContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_free</NAME>
<RETURNS>void                  </RETURNS>
GMarkupParseContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_parse</NAME>
<RETURNS>gboolean              </RETURNS>
GMarkupParseContext *context, const gchar         *text, gssize               text_len, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_push</NAME>
<RETURNS>void                  </RETURNS>
GMarkupParseContext *context, const GMarkupParser *parser, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_pop</NAME>
<RETURNS>gpointer              </RETURNS>
GMarkupParseContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_end_parse</NAME>
<RETURNS>gboolean              </RETURNS>
GMarkupParseContext *context, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_get_element</NAME>
<RETURNS>const gchar  *        </RETURNS>
GMarkupParseContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_get_element_stack</NAME>
<RETURNS>const GSList  *       </RETURNS>
GMarkupParseContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_get_position</NAME>
<RETURNS>void                  </RETURNS>
GMarkupParseContext *context, gint                *line_number, gint                *char_number
</FUNCTION>
<FUNCTION>
<NAME>g_markup_parse_context_get_user_data</NAME>
<RETURNS>gpointer              </RETURNS>
GMarkupParseContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_markup_escape_text</NAME>
<RETURNS>gchar * </RETURNS>
const gchar *text, gssize       length
</FUNCTION>
<FUNCTION>
<NAME>g_markup_printf_escaped</NAME>
<RETURNS>gchar  *</RETURNS>
const char *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_markup_vprintf_escaped</NAME>
<RETURNS>gchar  *</RETURNS>
const char *format, va_list     args
</FUNCTION>
<ENUM>
<NAME>GMarkupCollectType</NAME>
typedef enum
{
  G_MARKUP_COLLECT_INVALID,
  G_MARKUP_COLLECT_STRING,
  G_MARKUP_COLLECT_STRDUP,
  G_MARKUP_COLLECT_BOOLEAN,
  G_MARKUP_COLLECT_TRISTATE,

  G_MARKUP_COLLECT_OPTIONAL = (1 << 16)
} GMarkupCollectType;
</ENUM>
<FUNCTION>
<NAME>g_markup_collect_attributes</NAME>
<RETURNS>gboolean    </RETURNS>
const gchar         *element_name, const gchar        **attribute_names, const gchar        **attribute_values, GError             **error, GMarkupCollectType   first_type, const gchar         *first_attr, ...
</FUNCTION>
<STRUCT>
<NAME>GMarkupParseContext</NAME>
</STRUCT>
<MACRO>
<NAME>G_MEM_ALIGN</NAME>
#  define G_MEM_ALIGN	GLIB_SIZEOF_VOID_P
</MACRO>
<FUNCTION>
<NAME>g_free</NAME>
<RETURNS>void 	 </RETURNS>
gpointer	 mem
</FUNCTION>
<FUNCTION>
<NAME>g_clear_pointer</NAME>
<RETURNS>void      </RETURNS>
gpointer      *pp, GDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>g_malloc</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_malloc0</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_realloc</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer	 mem, gsize	 n_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_try_malloc</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_try_malloc0</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_try_realloc</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer	 mem, gsize	 n_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_malloc_n</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_blocks, gsize	 n_block_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_malloc0_n</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_blocks, gsize	 n_block_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_realloc_n</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer	 mem, gsize	 n_blocks, gsize	 n_block_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_try_malloc_n</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_blocks, gsize	 n_block_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_try_malloc0_n</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	 n_blocks, gsize	 n_block_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_try_realloc_n</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer	 mem, gsize	 n_blocks, gsize	 n_block_bytes
</FUNCTION>
<FUNCTION>
<NAME>g_steal_pointer</NAME>
<RETURNS>gpointer</RETURNS>
gpointer pp
</FUNCTION>
<MACRO>
<NAME>g_new</NAME>
#define g_new(struct_type, n_structs)			_G_NEW (struct_type, n_structs, malloc)
</MACRO>
<MACRO>
<NAME>g_new0</NAME>
#define g_new0(struct_type, n_structs)			_G_NEW (struct_type, n_structs, malloc0)
</MACRO>
<MACRO>
<NAME>g_renew</NAME>
#define g_renew(struct_type, mem, n_structs)		_G_RENEW (struct_type, mem, n_structs, realloc)
</MACRO>
<MACRO>
<NAME>g_try_new</NAME>
#define g_try_new(struct_type, n_structs)		_G_NEW (struct_type, n_structs, try_malloc)
</MACRO>
<MACRO>
<NAME>g_try_new0</NAME>
#define g_try_new0(struct_type, n_structs)		_G_NEW (struct_type, n_structs, try_malloc0)
</MACRO>
<MACRO>
<NAME>g_try_renew</NAME>
#define g_try_renew(struct_type, mem, n_structs)	_G_RENEW (struct_type, mem, n_structs, try_realloc)
</MACRO>
<STRUCT>
<NAME>GMemVTable</NAME>
struct _GMemVTable {
  gpointer (*malloc)      (gsize    n_bytes);
  gpointer (*realloc)     (gpointer mem,
			   gsize    n_bytes);
  void     (*free)        (gpointer mem);
  /* optional; set to NULL if not used ! */
  gpointer (*calloc)      (gsize    n_blocks,
			   gsize    n_block_bytes);
  gpointer (*try_malloc)  (gsize    n_bytes);
  gpointer (*try_realloc) (gpointer mem,
			   gsize    n_bytes);
};
</STRUCT>
<FUNCTION>
<NAME>g_mem_set_vtable</NAME>
<DEPRECATED/>
<RETURNS>void 	 </RETURNS>
GMemVTable	*vtable
</FUNCTION>
<FUNCTION>
<NAME>g_mem_is_system_malloc</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>g_mem_gc_friendly</NAME>
extern gboolean g_mem_gc_friendly;
</VARIABLE>
<VARIABLE>
<NAME>glib_mem_profiler_table</NAME>
extern GMemVTable	*glib_mem_profiler_table;
</VARIABLE>
<FUNCTION>
<NAME>g_mem_profile</NAME>
<DEPRECATED/>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_printf_string_upper_bound</NAME>
<RETURNS>gsize 	</RETURNS>
const gchar* format, va_list	  args
</FUNCTION>
<MACRO>
<NAME>G_LOG_LEVEL_USER_SHIFT</NAME>
#define G_LOG_LEVEL_USER_SHIFT  (8)
</MACRO>
<ENUM>
<NAME>GLogLevelFlags</NAME>
typedef enum
{
  /* log flags */
  G_LOG_FLAG_RECURSION          = 1 << 0,
  G_LOG_FLAG_FATAL              = 1 << 1,

  /* GLib log levels */
  G_LOG_LEVEL_ERROR             = 1 << 2,       /* always fatal */
  G_LOG_LEVEL_CRITICAL          = 1 << 3,
  G_LOG_LEVEL_WARNING           = 1 << 4,
  G_LOG_LEVEL_MESSAGE           = 1 << 5,
  G_LOG_LEVEL_INFO              = 1 << 6,
  G_LOG_LEVEL_DEBUG             = 1 << 7,

  G_LOG_LEVEL_MASK              = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
} GLogLevelFlags;
</ENUM>
<MACRO>
<NAME>G_LOG_FATAL_MASK</NAME>
#define G_LOG_FATAL_MASK        (G_LOG_FLAG_RECURSION | G_LOG_LEVEL_ERROR)
</MACRO>
<USER_FUNCTION>
<NAME>GLogFunc</NAME>
<RETURNS>void </RETURNS>
const gchar   *log_domain,
                                                 GLogLevelFlags log_level,
                                                 const gchar   *message,
                                                 gpointer       user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_log_set_handler</NAME>
<RETURNS>guint            </RETURNS>
const gchar    *log_domain, GLogLevelFlags  log_levels, GLogFunc        log_func, gpointer        user_data
</FUNCTION>
<FUNCTION>
<NAME>g_log_set_handler_full</NAME>
<RETURNS>guint            </RETURNS>
const gchar    *log_domain, GLogLevelFlags  log_levels, GLogFunc        log_func, gpointer        user_data, GDestroyNotify  destroy
</FUNCTION>
<FUNCTION>
<NAME>g_log_remove_handler</NAME>
<RETURNS>void             </RETURNS>
const gchar    *log_domain, guint           handler_id
</FUNCTION>
<FUNCTION>
<NAME>g_log_default_handler</NAME>
<RETURNS>void             </RETURNS>
const gchar    *log_domain, GLogLevelFlags  log_level, const gchar    *message, gpointer        unused_data
</FUNCTION>
<FUNCTION>
<NAME>g_log_set_default_handler</NAME>
<RETURNS>GLogFunc         </RETURNS>
GLogFunc      log_func, gpointer      user_data
</FUNCTION>
<FUNCTION>
<NAME>g_log</NAME>
<RETURNS>void             </RETURNS>
const gchar    *log_domain, GLogLevelFlags  log_level, const gchar    *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_logv</NAME>
<RETURNS>void             </RETURNS>
const gchar    *log_domain, GLogLevelFlags  log_level, const gchar    *format, va_list         args
</FUNCTION>
<FUNCTION>
<NAME>g_log_set_fatal_mask</NAME>
<RETURNS>GLogLevelFlags   </RETURNS>
const gchar    *log_domain, GLogLevelFlags  fatal_mask
</FUNCTION>
<FUNCTION>
<NAME>g_log_set_always_fatal</NAME>
<RETURNS>GLogLevelFlags   </RETURNS>
GLogLevelFlags  fatal_mask
</FUNCTION>
<ENUM>
<NAME>GLogWriterOutput</NAME>
typedef enum
{
  G_LOG_WRITER_HANDLED = 1,
  G_LOG_WRITER_UNHANDLED = 0,
} GLogWriterOutput;
</ENUM>
<STRUCT>
<NAME>GLogField</NAME>
struct _GLogField
{
  const gchar *key;
  gconstpointer value;
  gssize length;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GLogWriterFunc</NAME>
<RETURNS>GLogWriterOutput </RETURNS>
GLogLevelFlags   log_level,
                                                const GLogField *fields,
                                                gsize            n_fields,
                                                gpointer         user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_log_structured</NAME>
<RETURNS>void              </RETURNS>
const gchar     *log_domain, GLogLevelFlags   log_level, ...
</FUNCTION>
<FUNCTION>
<NAME>g_log_structured_array</NAME>
<RETURNS>void              </RETURNS>
GLogLevelFlags   log_level, const GLogField *fields, gsize            n_fields
</FUNCTION>
<FUNCTION>
<NAME>g_log_variant</NAME>
<RETURNS>void              </RETURNS>
const gchar     *log_domain, GLogLevelFlags   log_level, GVariant        *fields
</FUNCTION>
<FUNCTION>
<NAME>g_log_set_writer_func</NAME>
<RETURNS>void              </RETURNS>
GLogWriterFunc   func, gpointer         user_data, GDestroyNotify   user_data_free
</FUNCTION>
<FUNCTION>
<NAME>g_log_writer_supports_color</NAME>
<RETURNS>gboolean          </RETURNS>
gint             output_fd
</FUNCTION>
<FUNCTION>
<NAME>g_log_writer_is_journald</NAME>
<RETURNS>gboolean          </RETURNS>
gint             output_fd
</FUNCTION>
<FUNCTION>
<NAME>g_log_writer_format_fields</NAME>
<RETURNS>gchar            *</RETURNS>
GLogLevelFlags   log_level, const GLogField *fields, gsize            n_fields, gboolean         use_color
</FUNCTION>
<FUNCTION>
<NAME>g_log_writer_journald</NAME>
<RETURNS>GLogWriterOutput  </RETURNS>
GLogLevelFlags   log_level, const GLogField *fields, gsize            n_fields, gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>g_log_writer_standard_streams</NAME>
<RETURNS>GLogWriterOutput  </RETURNS>
GLogLevelFlags   log_level, const GLogField *fields, gsize            n_fields, gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>g_log_writer_default</NAME>
<RETURNS>GLogWriterOutput  </RETURNS>
GLogLevelFlags   log_level, const GLogField *fields, gsize            n_fields, gpointer         user_data
</FUNCTION>
<MACRO>
<NAME>G_DEBUG_HERE</NAME>
#define G_DEBUG_HERE()                                          \
  g_log_structured (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,            \
                    "CODE_FILE", __FILE__,                      \
                    "CODE_LINE", G_STRINGIFY (__LINE__),        \
                    "CODE_FUNC", G_STRFUNC,                      \
                    "MESSAGE", "%" G_GINT64_FORMAT ": %s",      \
                    g_get_monotonic_time (), G_STRLOC)
</MACRO>
<FUNCTION>
<NAME>g_return_if_fail_warning</NAME>
<DEPRECATED/>
<RETURNS>void  </RETURNS>
const char *log_domain, const char *pretty_function, const char *expression) G_ANALYZER_NORETURN; GLIB_AVAILABLE_IN_ALL void g_warn_message           (const char     *domain, const char     *file, int             line, const char     *func, const char     *warnexpr) G_ANALYZER_NORETURN; GLIB_DEPRECATED void g_assert_warning         (const char *log_domain, const char *file, const int   line, const char *pretty_function, const char *expression
</FUNCTION>
<FUNCTION>
<NAME>g_log_structured_standard</NAME>
<RETURNS>void  </RETURNS>
const gchar    *log_domain, GLogLevelFlags  log_level, const gchar    *file, const gchar    *line, const gchar    *func, const gchar    *message_format, ...
</FUNCTION>
<MACRO>
<NAME>G_LOG_DOMAIN</NAME>
#define G_LOG_DOMAIN    ((gchar*) 0)
</MACRO>
<MACRO>
<NAME>g_error</NAME>
#define g_error(...)  G_STMT_START {                                            \
                        g_log_structured_standard (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, \
                                                   __FILE__, G_STRINGIFY (__LINE__), \
                                                   G_STRFUNC, __VA_ARGS__); \
                        for (;;) ;                                              \
                      } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_message</NAME>
#define g_message(...)  g_log_structured_standard (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, \
                                                   __FILE__, G_STRINGIFY (__LINE__), \
                                                   G_STRFUNC, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_critical</NAME>
#define g_critical(...) g_log_structured_standard (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, \
                                                   __FILE__, G_STRINGIFY (__LINE__), \
                                                   G_STRFUNC, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_warning</NAME>
#define g_warning(...)  g_log_structured_standard (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING, \
                                                   __FILE__, G_STRINGIFY (__LINE__), \
                                                   G_STRFUNC, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_info</NAME>
#define g_info(...)     g_log_structured_standard (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, \
                                                   __FILE__, G_STRINGIFY (__LINE__), \
                                                   G_STRFUNC, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_debug</NAME>
#define g_debug(...)    g_log_structured_standard (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG, \
                                                   __FILE__, G_STRINGIFY (__LINE__), \
                                                   G_STRFUNC, __VA_ARGS__)
</MACRO>
<USER_FUNCTION>
<NAME>GPrintFunc</NAME>
<RETURNS>void </RETURNS>
const gchar    *string
</USER_FUNCTION>
<FUNCTION>
<NAME>g_print</NAME>
<RETURNS>void             </RETURNS>
const gchar    *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_set_print_handler</NAME>
<RETURNS>GPrintFunc       </RETURNS>
GPrintFunc      func
</FUNCTION>
<FUNCTION>
<NAME>g_printerr</NAME>
<RETURNS>void             </RETURNS>
const gchar    *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_set_printerr_handler</NAME>
<RETURNS>GPrintFunc       </RETURNS>
GPrintFunc      func
</FUNCTION>
<MACRO>
<NAME>g_warn_if_reached</NAME>
#define g_warn_if_reached() \
  do { \
    g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, NULL); \
  } while (0)
</MACRO>
<MACRO>
<NAME>g_warn_if_fail</NAME>
#define g_warn_if_fail(expr) \
  do { \
    if G_LIKELY (expr) ; \
    else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr); \
  } while (0)
</MACRO>
<MACRO>
<NAME>g_return_if_fail</NAME>
#define g_return_if_fail(expr) G_STMT_START{ (void)0; }G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_val_if_fail</NAME>
#define g_return_val_if_fail(expr,val) G_STMT_START{ (void)0; }G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_if_reached</NAME>
#define g_return_if_reached() G_STMT_START{ return; }G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_val_if_reached</NAME>
#define g_return_val_if_reached(val) G_STMT_START{ return (val); }G_STMT_END
</MACRO>
<ENUM>
<NAME>GTraverseFlags</NAME>
typedef enum
{
  G_TRAVERSE_LEAVES     = 1 << 0,
  G_TRAVERSE_NON_LEAVES = 1 << 1,
  G_TRAVERSE_ALL        = G_TRAVERSE_LEAVES | G_TRAVERSE_NON_LEAVES,
  G_TRAVERSE_MASK       = 0x03,
  G_TRAVERSE_LEAFS      = G_TRAVERSE_LEAVES,
  G_TRAVERSE_NON_LEAFS  = G_TRAVERSE_NON_LEAVES
} GTraverseFlags;
</ENUM>
<ENUM>
<NAME>GTraverseType</NAME>
typedef enum
{
  G_IN_ORDER,
  G_PRE_ORDER,
  G_POST_ORDER,
  G_LEVEL_ORDER
} GTraverseType;
</ENUM>
<USER_FUNCTION>
<NAME>GNodeTraverseFunc</NAME>
<RETURNS>gboolean </RETURNS>
GNode	       *node,
						 gpointer	data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GNodeForeachFunc</NAME>
<RETURNS>void </RETURNS>
GNode	       *node,
						 gpointer	data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCopyFunc</NAME>
<RETURNS>gpointer </RETURNS>
gconstpointer  src,
                                                 gpointer       data
</USER_FUNCTION>
<STRUCT>
<NAME>GNode</NAME>
struct _GNode
{
  gpointer data;
  GNode	  *next;
  GNode	  *prev;
  GNode	  *parent;
  GNode	  *children;
};
</STRUCT>
<MACRO>
<NAME>G_NODE_IS_ROOT</NAME>
#define	 G_NODE_IS_ROOT(node)	(((GNode*) (node))->parent == NULL && \
				 ((GNode*) (node))->prev == NULL && \
				 ((GNode*) (node))->next == NULL)
</MACRO>
<MACRO>
<NAME>G_NODE_IS_LEAF</NAME>
#define	 G_NODE_IS_LEAF(node)	(((GNode*) (node))->children == NULL)
</MACRO>
<FUNCTION>
<NAME>g_node_new</NAME>
<RETURNS>GNode *	 </RETURNS>
gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_destroy</NAME>
<RETURNS>void 	 </RETURNS>
GNode		  *root
</FUNCTION>
<FUNCTION>
<NAME>g_node_unlink</NAME>
<RETURNS>void 	 </RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_copy_deep</NAME>
<RETURNS>GNode *   </RETURNS>
GNode            *node, GCopyFunc         copy_func, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_node_copy</NAME>
<RETURNS>GNode *   </RETURNS>
GNode            *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_insert</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *parent, gint		   position, GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_insert_before</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *parent, GNode		  *sibling, GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_insert_after</NAME>
<RETURNS>GNode *   </RETURNS>
GNode            *parent, GNode            *sibling, GNode            *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_prepend</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *parent, GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_n_nodes</NAME>
<RETURNS>guint 	 </RETURNS>
GNode		  *root, GTraverseFlags	   flags
</FUNCTION>
<FUNCTION>
<NAME>g_node_get_root</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_is_ancestor</NAME>
<RETURNS>gboolean  </RETURNS>
GNode		  *node, GNode		  *descendant
</FUNCTION>
<FUNCTION>
<NAME>g_node_depth</NAME>
<RETURNS>guint 	 </RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_find</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *root, GTraverseType	   order, GTraverseFlags	   flags, gpointer	   data
</FUNCTION>
<MACRO>
<NAME>g_node_append</NAME>
#define g_node_append(parent, node)				\
     g_node_insert_before ((parent), NULL, (node))
</MACRO>
<MACRO>
<NAME>g_node_insert_data</NAME>
#define	g_node_insert_data(parent, position, data)		\
     g_node_insert ((parent), (position), g_node_new (data))
</MACRO>
<MACRO>
<NAME>g_node_insert_data_after</NAME>
#define	g_node_insert_data_after(parent, sibling, data)	\
     g_node_insert_after ((parent), (sibling), g_node_new (data))
</MACRO>
<MACRO>
<NAME>g_node_insert_data_before</NAME>
#define	g_node_insert_data_before(parent, sibling, data)	\
     g_node_insert_before ((parent), (sibling), g_node_new (data))
</MACRO>
<MACRO>
<NAME>g_node_prepend_data</NAME>
#define	g_node_prepend_data(parent, data)			\
     g_node_prepend ((parent), g_node_new (data))
</MACRO>
<MACRO>
<NAME>g_node_append_data</NAME>
#define	g_node_append_data(parent, data)			\
     g_node_insert_before ((parent), NULL, g_node_new (data))
</MACRO>
<FUNCTION>
<NAME>g_node_traverse</NAME>
<RETURNS>void 	 </RETURNS>
GNode		  *root, GTraverseType	   order, GTraverseFlags	   flags, gint		   max_depth, GNodeTraverseFunc func, gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_max_height</NAME>
<RETURNS>guint 	 </RETURNS>
GNode *root
</FUNCTION>
<FUNCTION>
<NAME>g_node_children_foreach</NAME>
<RETURNS>void 	 </RETURNS>
GNode		  *node, GTraverseFlags   flags, GNodeForeachFunc func, gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_reverse_children</NAME>
<RETURNS>void 	 </RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_n_children</NAME>
<RETURNS>guint 	 </RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_nth_child</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *node, guint		   n
</FUNCTION>
<FUNCTION>
<NAME>g_node_last_child</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_find_child</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *node, GTraverseFlags   flags, gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_child_position</NAME>
<RETURNS>gint 	 </RETURNS>
GNode		  *node, GNode		  *child
</FUNCTION>
<FUNCTION>
<NAME>g_node_child_index</NAME>
<RETURNS>gint 	 </RETURNS>
GNode		  *node, gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_first_sibling</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_last_sibling</NAME>
<RETURNS>GNode *	 </RETURNS>
GNode		  *node
</FUNCTION>
<MACRO>
<NAME>g_node_prev_sibling</NAME>
#define	 g_node_prev_sibling(node)	((node) ? \
					 ((GNode*) (node))->prev : NULL)
</MACRO>
<MACRO>
<NAME>g_node_next_sibling</NAME>
#define	 g_node_next_sibling(node)	((node) ? \
					 ((GNode*) (node))->next : NULL)
</MACRO>
<MACRO>
<NAME>g_node_first_child</NAME>
#define	 g_node_first_child(node)	((node) ? \
					 ((GNode*) (node))->children : NULL)
</MACRO>
<ENUM>
<NAME>GOptionFlags</NAME>
typedef enum
{
  G_OPTION_FLAG_NONE            = 0,
  G_OPTION_FLAG_HIDDEN		= 1 << 0,
  G_OPTION_FLAG_IN_MAIN		= 1 << 1,
  G_OPTION_FLAG_REVERSE		= 1 << 2,
  G_OPTION_FLAG_NO_ARG		= 1 << 3,
  G_OPTION_FLAG_FILENAME	= 1 << 4,
  G_OPTION_FLAG_OPTIONAL_ARG    = 1 << 5,
  G_OPTION_FLAG_NOALIAS	        = 1 << 6
} GOptionFlags;
</ENUM>
<ENUM>
<NAME>GOptionArg</NAME>
typedef enum
{
  G_OPTION_ARG_NONE,
  G_OPTION_ARG_STRING,
  G_OPTION_ARG_INT,
  G_OPTION_ARG_CALLBACK,
  G_OPTION_ARG_FILENAME,
  G_OPTION_ARG_STRING_ARRAY,
  G_OPTION_ARG_FILENAME_ARRAY,
  G_OPTION_ARG_DOUBLE,
  G_OPTION_ARG_INT64
} GOptionArg;
</ENUM>
<USER_FUNCTION>
<NAME>GOptionArgFunc</NAME>
<RETURNS>gboolean </RETURNS>
const gchar    *option_name,
				    const gchar    *value,
				    gpointer        data,
				    GError        **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GOptionParseFunc</NAME>
<RETURNS>gboolean </RETURNS>
GOptionContext *context,
				      GOptionGroup   *group,
				      gpointer	      data,
				      GError        **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GOptionErrorFunc</NAME>
<RETURNS>void </RETURNS>
GOptionContext *context,
				  GOptionGroup   *group,
				  gpointer        data,
				  GError        **error
</USER_FUNCTION>
<MACRO>
<NAME>G_OPTION_ERROR</NAME>
#define G_OPTION_ERROR (g_option_error_quark ())
</MACRO>
<ENUM>
<NAME>GOptionError</NAME>
typedef enum
{
  G_OPTION_ERROR_UNKNOWN_OPTION,
  G_OPTION_ERROR_BAD_VALUE,
  G_OPTION_ERROR_FAILED
} GOptionError;
</ENUM>
<FUNCTION>
<NAME>g_option_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GOptionEntry</NAME>
struct _GOptionEntry
{
  const gchar *long_name;
  gchar        short_name;
  gint         flags;

  GOptionArg   arg;
  gpointer     arg_data;
  
  const gchar *description;
  const gchar *arg_description;
};
</STRUCT>
<MACRO>
<NAME>G_OPTION_REMAINING</NAME>
#define G_OPTION_REMAINING ""
</MACRO>
<FUNCTION>
<NAME>g_option_context_new</NAME>
<RETURNS>GOptionContext  *</RETURNS>
const gchar         *parameter_string
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_summary</NAME>
<RETURNS>void             </RETURNS>
GOptionContext      *context, const gchar         *summary
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_get_summary</NAME>
<RETURNS>const gchar  *   </RETURNS>
GOptionContext     *context
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_description</NAME>
<RETURNS>void             </RETURNS>
GOptionContext      *context, const gchar         *description
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_get_description</NAME>
<RETURNS>const gchar  *   </RETURNS>
GOptionContext     *context
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_free</NAME>
<RETURNS>void             </RETURNS>
GOptionContext      *context
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_help_enabled</NAME>
<RETURNS>void 		</RETURNS>
GOptionContext      *context, gboolean		help_enabled
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_get_help_enabled</NAME>
<RETURNS>gboolean 	</RETURNS>
GOptionContext      *context
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_ignore_unknown_options</NAME>
<RETURNS>void 		</RETURNS>
GOptionContext *context, gboolean	     ignore_unknown
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_get_ignore_unknown_options</NAME>
<RETURNS>gboolean         </RETURNS>
GOptionContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_strict_posix</NAME>
<RETURNS>void             </RETURNS>
GOptionContext *context, gboolean        strict_posix
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_get_strict_posix</NAME>
<RETURNS>gboolean         </RETURNS>
GOptionContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_add_main_entries</NAME>
<RETURNS>void             </RETURNS>
GOptionContext      *context, const GOptionEntry  *entries, const gchar         *translation_domain
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_parse</NAME>
<RETURNS>gboolean         </RETURNS>
GOptionContext      *context, gint                *argc, gchar             ***argv, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_parse_strv</NAME>
<RETURNS>gboolean         </RETURNS>
GOptionContext      *context, gchar             ***arguments, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_translate_func</NAME>
<RETURNS>void             </RETURNS>
GOptionContext     *context, GTranslateFunc      func, gpointer            data, GDestroyNotify      destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_translation_domain</NAME>
<RETURNS>void             </RETURNS>
GOptionContext  *context, const gchar     *domain
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_add_group</NAME>
<RETURNS>void             </RETURNS>
GOptionContext *context, GOptionGroup   *group
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_set_main_group</NAME>
<RETURNS>void           </RETURNS>
GOptionContext *context, GOptionGroup   *group
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_get_main_group</NAME>
<RETURNS>GOptionGroup  *</RETURNS>
GOptionContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_option_context_get_help</NAME>
<RETURNS>gchar         *</RETURNS>
GOptionContext *context, gboolean        main_help, GOptionGroup   *group
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_new</NAME>
<RETURNS>GOptionGroup  *</RETURNS>
const gchar        *name, const gchar        *description, const gchar        *help_description, gpointer            user_data, GDestroyNotify      destroy
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_set_parse_hooks</NAME>
<RETURNS>void 	      </RETURNS>
GOptionGroup       *group, GOptionParseFunc    pre_parse_func, GOptionParseFunc	 post_parse_func
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_set_error_hook</NAME>
<RETURNS>void 	      </RETURNS>
GOptionGroup       *group, GOptionErrorFunc	 error_func
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_free</NAME>
<DEPRECATED/>
<RETURNS>void           </RETURNS>
GOptionGroup       *group
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_ref</NAME>
<RETURNS>GOptionGroup  *</RETURNS>
GOptionGroup       *group
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_unref</NAME>
<RETURNS>void           </RETURNS>
GOptionGroup       *group
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_add_entries</NAME>
<RETURNS>void           </RETURNS>
GOptionGroup       *group, const GOptionEntry *entries
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_set_translate_func</NAME>
<RETURNS>void           </RETURNS>
GOptionGroup       *group, GTranslateFunc      func, gpointer            data, GDestroyNotify      destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>g_option_group_set_translation_domain</NAME>
<RETURNS>void           </RETURNS>
GOptionGroup       *group, const gchar        *domain
</FUNCTION>
<STRUCT>
<NAME>GOptionContext</NAME>
</STRUCT>
<STRUCT>
<NAME>GOptionGroup</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_pattern_spec_new</NAME>
<RETURNS>GPatternSpec * </RETURNS>
const gchar  *pattern
</FUNCTION>
<FUNCTION>
<NAME>g_pattern_spec_free</NAME>
<RETURNS>void           </RETURNS>
GPatternSpec *pspec
</FUNCTION>
<FUNCTION>
<NAME>g_pattern_spec_equal</NAME>
<RETURNS>gboolean       </RETURNS>
GPatternSpec *pspec1, GPatternSpec *pspec2
</FUNCTION>
<FUNCTION>
<NAME>g_pattern_match</NAME>
<RETURNS>gboolean       </RETURNS>
GPatternSpec *pspec, guint         string_length, const gchar  *string, const gchar  *string_reversed
</FUNCTION>
<FUNCTION>
<NAME>g_pattern_match_string</NAME>
<RETURNS>gboolean       </RETURNS>
GPatternSpec *pspec, const gchar  *string
</FUNCTION>
<FUNCTION>
<NAME>g_pattern_match_simple</NAME>
<RETURNS>gboolean       </RETURNS>
const gchar  *pattern, const gchar  *string
</FUNCTION>
<STRUCT>
<NAME>GPatternSpec</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GPollFunc</NAME>
<RETURNS>gint </RETURNS>
GPollFD *ufds,
                                 guint    nfsd,
                                 gint     timeout_
</USER_FUNCTION>
<STRUCT>
<NAME>GPollFD</NAME>
struct _GPollFD
{
#if defined (G_OS_WIN32) && GLIB_SIZEOF_VOID_P == 8
#endif
#else
  gint		fd;
#endif
  gushort 	events;
  gushort 	revents;
};
</STRUCT>
<FUNCTION>
<NAME>g_poll</NAME>
<RETURNS>gint</RETURNS>
GPollFD *fds, guint    nfds, gint     timeout
</FUNCTION>
<FUNCTION>
<NAME>g_spaced_primes_closest</NAME>
<RETURNS>guint 	   </RETURNS>
guint num
</FUNCTION>
<FUNCTION>
<NAME>g_printf</NAME>
<RETURNS>gint                   </RETURNS>
gchar const *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_fprintf</NAME>
<RETURNS>gint                   </RETURNS>
FILE        *file, gchar const *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_sprintf</NAME>
<RETURNS>gint                   </RETURNS>
gchar       *string, gchar const *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_vprintf</NAME>
<RETURNS>gint                   </RETURNS>
gchar const *format, va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_vfprintf</NAME>
<RETURNS>gint                   </RETURNS>
FILE        *file, gchar const *format, va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_vsprintf</NAME>
<RETURNS>gint                   </RETURNS>
gchar       *string, gchar const *format, va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_vasprintf</NAME>
<RETURNS>gint                   </RETURNS>
gchar      **string, gchar const *format, va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_qsort_with_data</NAME>
<RETURNS>void  </RETURNS>
gconstpointer    pbase, gint             total_elems, gsize            size, GCompareDataFunc compare_func, gpointer         user_data
</FUNCTION>
<TYPEDEF>
<NAME>GQuark</NAME>
typedef guint32 GQuark;
</TYPEDEF>
<FUNCTION>
<NAME>g_quark_try_string</NAME>
<RETURNS>GQuark                 </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_quark_from_static_string</NAME>
<RETURNS>GQuark                 </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_quark_from_string</NAME>
<RETURNS>GQuark                 </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_quark_to_string</NAME>
<RETURNS>const gchar  *         </RETURNS>
GQuark       quark
</FUNCTION>
<MACRO>
<NAME>G_DEFINE_QUARK</NAME>
#define G_DEFINE_QUARK(QN, q_n)                                         \
GQuark                                                                  \
q_n##_quark (void)                                                      \
{                                                                       \
  static GQuark q;                                                      \
                                                                        \
  if G_UNLIKELY (q == 0)                                                \
    q = g_quark_from_static_string (#QN);                               \
                                                                        \
  return q;                                                             \
}
</MACRO>
<FUNCTION>
<NAME>g_intern_string</NAME>
<RETURNS>const gchar  *         </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_intern_static_string</NAME>
<RETURNS>const gchar  *         </RETURNS>
const gchar *string
</FUNCTION>
<STRUCT>
<NAME>GQueue</NAME>
struct _GQueue
{
  GList *head;
  GList *tail;
  guint  length;
};
</STRUCT>
<MACRO>
<NAME>G_QUEUE_INIT</NAME>
#define G_QUEUE_INIT { NULL, NULL, 0 }
</MACRO>
<FUNCTION>
<NAME>g_queue_new</NAME>
<RETURNS>GQueue *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_queue_free</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_free_full</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GDestroyNotify    free_func
</FUNCTION>
<FUNCTION>
<NAME>g_queue_init</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_clear</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_is_empty</NAME>
<RETURNS>gboolean  </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_get_length</NAME>
<RETURNS>guint     </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_reverse</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_copy</NAME>
<RETURNS>GQueue  * </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_foreach</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GFunc             func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_find</NAME>
<RETURNS>GList  *  </RETURNS>
GQueue           *queue, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_find_custom</NAME>
<RETURNS>GList  *  </RETURNS>
GQueue           *queue, gconstpointer     data, GCompareFunc      func
</FUNCTION>
<FUNCTION>
<NAME>g_queue_sort</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_head</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_tail</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_nth</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, gpointer          data, gint              n
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_head</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_tail</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_nth</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue           *queue, guint             n
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_head</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_tail</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_nth</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue           *queue, guint             n
</FUNCTION>
<FUNCTION>
<NAME>g_queue_index</NAME>
<RETURNS>gint      </RETURNS>
GQueue           *queue, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_remove</NAME>
<RETURNS>gboolean  </RETURNS>
GQueue           *queue, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_remove_all</NAME>
<RETURNS>guint     </RETURNS>
GQueue           *queue, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_insert_before</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GList            *sibling, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_insert_after</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GList            *sibling, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_insert_sorted</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, gpointer          data, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_head_link</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GList            *link_
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_tail_link</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GList            *link_
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_nth_link</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, gint              n, GList            *link_
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_head_link</NAME>
<RETURNS>GList *   </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_tail_link</NAME>
<RETURNS>GList *   </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_nth_link</NAME>
<RETURNS>GList *   </RETURNS>
GQueue           *queue, guint             n
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_head_link</NAME>
<RETURNS>GList *   </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_tail_link</NAME>
<RETURNS>GList *   </RETURNS>
GQueue           *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_nth_link</NAME>
<RETURNS>GList *   </RETURNS>
GQueue           *queue, guint             n
</FUNCTION>
<FUNCTION>
<NAME>g_queue_link_index</NAME>
<RETURNS>gint      </RETURNS>
GQueue           *queue, GList            *link_
</FUNCTION>
<FUNCTION>
<NAME>g_queue_unlink</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GList            *link_
</FUNCTION>
<FUNCTION>
<NAME>g_queue_delete_link</NAME>
<RETURNS>void      </RETURNS>
GQueue           *queue, GList            *link_
</FUNCTION>
<FUNCTION>
<NAME>g_rand_new_with_seed</NAME>
<RETURNS>GRand *  </RETURNS>
guint32  seed
</FUNCTION>
<FUNCTION>
<NAME>g_rand_new_with_seed_array</NAME>
<RETURNS>GRand *  </RETURNS>
const guint32 *seed, guint seed_length
</FUNCTION>
<FUNCTION>
<NAME>g_rand_new</NAME>
<RETURNS>GRand *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_rand_free</NAME>
<RETURNS>void     </RETURNS>
GRand   *rand_
</FUNCTION>
<FUNCTION>
<NAME>g_rand_copy</NAME>
<RETURNS>GRand *  </RETURNS>
GRand   *rand_
</FUNCTION>
<FUNCTION>
<NAME>g_rand_set_seed</NAME>
<RETURNS>void     </RETURNS>
GRand   *rand_, guint32  seed
</FUNCTION>
<FUNCTION>
<NAME>g_rand_set_seed_array</NAME>
<RETURNS>void 	</RETURNS>
GRand   *rand_, const guint32 *seed, guint    seed_length
</FUNCTION>
<MACRO>
<NAME>g_rand_boolean</NAME>
#define g_rand_boolean(rand_) ((g_rand_int (rand_) & (1 << 15)) != 0)
</MACRO>
<FUNCTION>
<NAME>g_rand_int</NAME>
<RETURNS>guint32  </RETURNS>
GRand   *rand_
</FUNCTION>
<FUNCTION>
<NAME>g_rand_int_range</NAME>
<RETURNS>gint32   </RETURNS>
GRand   *rand_, gint32   begin, gint32   end
</FUNCTION>
<FUNCTION>
<NAME>g_rand_double</NAME>
<RETURNS>gdouble  </RETURNS>
GRand   *rand_
</FUNCTION>
<FUNCTION>
<NAME>g_rand_double_range</NAME>
<RETURNS>gdouble  </RETURNS>
GRand   *rand_, gdouble  begin, gdouble  end
</FUNCTION>
<FUNCTION>
<NAME>g_random_set_seed</NAME>
<RETURNS>void     </RETURNS>
guint32  seed
</FUNCTION>
<MACRO>
<NAME>g_random_boolean</NAME>
#define g_random_boolean() ((g_random_int () & (1 << 15)) != 0)
</MACRO>
<FUNCTION>
<NAME>g_random_int</NAME>
<RETURNS>guint32  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_random_int_range</NAME>
<RETURNS>gint32   </RETURNS>
gint32   begin, gint32   end
</FUNCTION>
<FUNCTION>
<NAME>g_random_double</NAME>
<RETURNS>gdouble  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_random_double_range</NAME>
<RETURNS>gdouble  </RETURNS>
gdouble  begin, gdouble  end
</FUNCTION>
<STRUCT>
<NAME>GRand</NAME>
</STRUCT>
<ENUM>
<NAME>GRegexError</NAME>
typedef enum
{
  G_REGEX_ERROR_COMPILE,
  G_REGEX_ERROR_OPTIMIZE,
  G_REGEX_ERROR_REPLACE,
  G_REGEX_ERROR_MATCH,
  G_REGEX_ERROR_INTERNAL,

  /* These are the error codes from PCRE + 100 */
  G_REGEX_ERROR_STRAY_BACKSLASH = 101,
  G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
  G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
  G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
  G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
  G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
  G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
  G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
  G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
  G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
  G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
  G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
  G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
  G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
  G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
  G_REGEX_ERROR_MEMORY_ERROR = 121,
  G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
  G_REGEX_ERROR_MALFORMED_CONDITION = 126,
  G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
  G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
  G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
  G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
  G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
  G_REGEX_ERROR_INVALID_CONDITION = 135,
  G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
  G_REGEX_ERROR_INFINITE_LOOP = 140,
  G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
  G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
  G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
  G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
  G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
  G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
  G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
  G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
  G_REGEX_ERROR_DEFINE_REPETION = 155,
  G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
  G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
  G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
  G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
  G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB  = 160,
  G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
  G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
  G_REGEX_ERROR_MISSING_DIGIT = 163,
  G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
  G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
  G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
  G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
  G_REGEX_ERROR_MISSING_NAME = 169,
  G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
  G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
  G_REGEX_ERROR_NAME_TOO_LONG = 175,
  G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
} GRegexError;
</ENUM>
<MACRO>
<NAME>G_REGEX_ERROR</NAME>
#define G_REGEX_ERROR g_regex_error_quark ()
</MACRO>
<FUNCTION>
<NAME>g_regex_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GRegexCompileFlags</NAME>
typedef enum
{
  G_REGEX_CASELESS          = 1 << 0,
  G_REGEX_MULTILINE         = 1 << 1,
  G_REGEX_DOTALL            = 1 << 2,
  G_REGEX_EXTENDED          = 1 << 3,
  G_REGEX_ANCHORED          = 1 << 4,
  G_REGEX_DOLLAR_ENDONLY    = 1 << 5,
  G_REGEX_UNGREEDY          = 1 << 9,
  G_REGEX_RAW               = 1 << 11,
  G_REGEX_NO_AUTO_CAPTURE   = 1 << 12,
  G_REGEX_OPTIMIZE          = 1 << 13,
  G_REGEX_FIRSTLINE         = 1 << 18,
  G_REGEX_DUPNAMES          = 1 << 19,
  G_REGEX_NEWLINE_CR        = 1 << 20,
  G_REGEX_NEWLINE_LF        = 1 << 21,
  G_REGEX_NEWLINE_CRLF      = G_REGEX_NEWLINE_CR | G_REGEX_NEWLINE_LF,
  G_REGEX_NEWLINE_ANYCRLF   = G_REGEX_NEWLINE_CR | 1 << 22,
  G_REGEX_BSR_ANYCRLF       = 1 << 23,
  G_REGEX_JAVASCRIPT_COMPAT = 1 << 25
} GRegexCompileFlags;
</ENUM>
<ENUM>
<NAME>GRegexMatchFlags</NAME>
typedef enum
{
  G_REGEX_MATCH_ANCHORED         = 1 << 4,
  G_REGEX_MATCH_NOTBOL           = 1 << 7,
  G_REGEX_MATCH_NOTEOL           = 1 << 8,
  G_REGEX_MATCH_NOTEMPTY         = 1 << 10,
  G_REGEX_MATCH_PARTIAL          = 1 << 15,
  G_REGEX_MATCH_NEWLINE_CR       = 1 << 20,
  G_REGEX_MATCH_NEWLINE_LF       = 1 << 21,
  G_REGEX_MATCH_NEWLINE_CRLF     = G_REGEX_MATCH_NEWLINE_CR | G_REGEX_MATCH_NEWLINE_LF,
  G_REGEX_MATCH_NEWLINE_ANY      = 1 << 22,
  G_REGEX_MATCH_NEWLINE_ANYCRLF  = G_REGEX_MATCH_NEWLINE_CR | G_REGEX_MATCH_NEWLINE_ANY,
  G_REGEX_MATCH_BSR_ANYCRLF      = 1 << 23,
  G_REGEX_MATCH_BSR_ANY          = 1 << 24,
  G_REGEX_MATCH_PARTIAL_SOFT     = G_REGEX_MATCH_PARTIAL,
  G_REGEX_MATCH_PARTIAL_HARD     = 1 << 27,
  G_REGEX_MATCH_NOTEMPTY_ATSTART = 1 << 28
} GRegexMatchFlags;
</ENUM>
<USER_FUNCTION>
<NAME>GRegexEvalCallback</NAME>
<RETURNS>gboolean </RETURNS>
const GMatchInfo *match_info,
						 GString          *result,
						 gpointer          user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_regex_new</NAME>
<RETURNS>GRegex 		 *</RETURNS>
const gchar         *pattern, GRegexCompileFlags   compile_options, GRegexMatchFlags     match_options, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_regex_ref</NAME>
<RETURNS>GRegex            *</RETURNS>
GRegex              *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_unref</NAME>
<RETURNS>void 		  </RETURNS>
GRegex              *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_pattern</NAME>
<RETURNS>const gchar 	 *</RETURNS>
const GRegex        *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_max_backref</NAME>
<RETURNS>gint 		  </RETURNS>
const GRegex        *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_capture_count</NAME>
<RETURNS>gint 		  </RETURNS>
const GRegex        *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_has_cr_or_lf</NAME>
<RETURNS>gboolean           </RETURNS>
const GRegex        *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_max_lookbehind</NAME>
<RETURNS>gint               </RETURNS>
const GRegex        *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_string_number</NAME>
<RETURNS>gint 		  </RETURNS>
const GRegex        *regex, const gchar         *name
</FUNCTION>
<FUNCTION>
<NAME>g_regex_escape_string</NAME>
<RETURNS>gchar 		 *</RETURNS>
const gchar         *string, gint                 length
</FUNCTION>
<FUNCTION>
<NAME>g_regex_escape_nul</NAME>
<RETURNS>gchar 		 *</RETURNS>
const gchar         *string, gint                 length
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_compile_flags</NAME>
<RETURNS>GRegexCompileFlags  </RETURNS>
const GRegex        *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_get_match_flags</NAME>
<RETURNS>GRegexMatchFlags    </RETURNS>
const GRegex        *regex
</FUNCTION>
<FUNCTION>
<NAME>g_regex_match_simple</NAME>
<RETURNS>gboolean 	  </RETURNS>
const gchar         *pattern, const gchar         *string, GRegexCompileFlags   compile_options, GRegexMatchFlags     match_options
</FUNCTION>
<FUNCTION>
<NAME>g_regex_match</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GRegex        *regex, const gchar         *string, GRegexMatchFlags     match_options, GMatchInfo         **match_info
</FUNCTION>
<FUNCTION>
<NAME>g_regex_match_full</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GRegex        *regex, const gchar         *string, gssize               string_len, gint                 start_position, GRegexMatchFlags     match_options, GMatchInfo         **match_info, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_regex_match_all</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GRegex        *regex, const gchar         *string, GRegexMatchFlags     match_options, GMatchInfo         **match_info
</FUNCTION>
<FUNCTION>
<NAME>g_regex_match_all_full</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GRegex        *regex, const gchar         *string, gssize               string_len, gint                 start_position, GRegexMatchFlags     match_options, GMatchInfo         **match_info, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_regex_split_simple</NAME>
<RETURNS>gchar 		**</RETURNS>
const gchar         *pattern, const gchar         *string, GRegexCompileFlags   compile_options, GRegexMatchFlags     match_options
</FUNCTION>
<FUNCTION>
<NAME>g_regex_split</NAME>
<RETURNS>gchar 		**</RETURNS>
const GRegex        *regex, const gchar         *string, GRegexMatchFlags     match_options
</FUNCTION>
<FUNCTION>
<NAME>g_regex_split_full</NAME>
<RETURNS>gchar 		**</RETURNS>
const GRegex        *regex, const gchar         *string, gssize               string_len, gint                 start_position, GRegexMatchFlags     match_options, gint                 max_tokens, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_regex_replace</NAME>
<RETURNS>gchar 		 *</RETURNS>
const GRegex        *regex, const gchar         *string, gssize               string_len, gint                 start_position, const gchar         *replacement, GRegexMatchFlags     match_options, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_regex_replace_literal</NAME>
<RETURNS>gchar 		 *</RETURNS>
const GRegex        *regex, const gchar         *string, gssize               string_len, gint                 start_position, const gchar         *replacement, GRegexMatchFlags     match_options, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_regex_replace_eval</NAME>
<RETURNS>gchar 		 *</RETURNS>
const GRegex        *regex, const gchar         *string, gssize               string_len, gint                 start_position, GRegexMatchFlags     match_options, GRegexEvalCallback   eval, gpointer             user_data, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_regex_check_replacement</NAME>
<RETURNS>gboolean 	  </RETURNS>
const gchar         *replacement, gboolean            *has_references, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_get_regex</NAME>
<RETURNS>GRegex 		 *</RETURNS>
const GMatchInfo    *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_get_string</NAME>
<RETURNS>const gchar       *</RETURNS>
const GMatchInfo    *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_ref</NAME>
<RETURNS>GMatchInfo        *</RETURNS>
GMatchInfo          *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_unref</NAME>
<RETURNS>void               </RETURNS>
GMatchInfo          *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_free</NAME>
<RETURNS>void 		  </RETURNS>
GMatchInfo          *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_next</NAME>
<RETURNS>gboolean 	  </RETURNS>
GMatchInfo          *match_info, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_matches</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GMatchInfo    *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_get_match_count</NAME>
<RETURNS>gint 		  </RETURNS>
const GMatchInfo    *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_is_partial_match</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GMatchInfo    *match_info
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_expand_references</NAME>
<RETURNS>gchar 		 *</RETURNS>
const GMatchInfo    *match_info, const gchar         *string_to_expand, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_fetch</NAME>
<RETURNS>gchar 		 *</RETURNS>
const GMatchInfo    *match_info, gint                 match_num
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_fetch_pos</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GMatchInfo    *match_info, gint                 match_num, gint                *start_pos, gint                *end_pos
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_fetch_named</NAME>
<RETURNS>gchar 		 *</RETURNS>
const GMatchInfo    *match_info, const gchar         *name
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_fetch_named_pos</NAME>
<RETURNS>gboolean 	  </RETURNS>
const GMatchInfo    *match_info, const gchar         *name, gint                *start_pos, gint                *end_pos
</FUNCTION>
<FUNCTION>
<NAME>g_match_info_fetch_all</NAME>
<RETURNS>gchar 		**</RETURNS>
const GMatchInfo    *match_info
</FUNCTION>
<STRUCT>
<NAME>GMatchInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GRegex</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GScannerMsgFunc</NAME>
<RETURNS>void </RETURNS>
GScanner      *scanner,
						 gchar	       *message,
						 gboolean	error
</USER_FUNCTION>
<MACRO>
<NAME>G_CSET_A_2_Z</NAME>
#define G_CSET_A_2_Z	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
</MACRO>
<MACRO>
<NAME>G_CSET_a_2_z</NAME>
#define G_CSET_a_2_z	"abcdefghijklmnopqrstuvwxyz"
</MACRO>
<MACRO>
<NAME>G_CSET_DIGITS</NAME>
#define G_CSET_DIGITS	"0123456789"
</MACRO>
<MACRO>
<NAME>G_CSET_LATINC</NAME>
#define G_CSET_LATINC	"\300\301\302\303\304\305\306"\
			"\307\310\311\312\313\314\315\316\317\320"\
			"\321\322\323\324\325\326"\
			"\330\331\332\333\334\335\336"
</MACRO>
<MACRO>
<NAME>G_CSET_LATINS</NAME>
#define G_CSET_LATINS	"\337\340\341\342\343\344\345\346"\
			"\347\350\351\352\353\354\355\356\357\360"\
			"\361\362\363\364\365\366"\
			"\370\371\372\373\374\375\376\377"
</MACRO>
<ENUM>
<NAME>GErrorType</NAME>
typedef enum
{
  G_ERR_UNKNOWN,
  G_ERR_UNEXP_EOF,
  G_ERR_UNEXP_EOF_IN_STRING,
  G_ERR_UNEXP_EOF_IN_COMMENT,
  G_ERR_NON_DIGIT_IN_CONST,
  G_ERR_DIGIT_RADIX,
  G_ERR_FLOAT_RADIX,
  G_ERR_FLOAT_MALFORMED
} GErrorType;
</ENUM>
<ENUM>
<NAME>GTokenType</NAME>
typedef enum
{
  G_TOKEN_EOF			=   0,
  
  G_TOKEN_LEFT_PAREN		= '(',
  G_TOKEN_RIGHT_PAREN		= ')',
  G_TOKEN_LEFT_CURLY		= '{',
  G_TOKEN_RIGHT_CURLY		= '}',
  G_TOKEN_LEFT_BRACE		= '[',
  G_TOKEN_RIGHT_BRACE		= ']',
  G_TOKEN_EQUAL_SIGN		= '=',
  G_TOKEN_COMMA			= ',',
  
  G_TOKEN_NONE			= 256,
  
  G_TOKEN_ERROR,
  
  G_TOKEN_CHAR,
  G_TOKEN_BINARY,
  G_TOKEN_OCTAL,
  G_TOKEN_INT,
  G_TOKEN_HEX,
  G_TOKEN_FLOAT,
  G_TOKEN_STRING,
  
  G_TOKEN_SYMBOL,
  G_TOKEN_IDENTIFIER,
  G_TOKEN_IDENTIFIER_NULL,
  
  G_TOKEN_COMMENT_SINGLE,
  G_TOKEN_COMMENT_MULTI,

  /*< private >*/
  G_TOKEN_LAST
} GTokenType;
</ENUM>
<UNION>
<NAME>GTokenValue</NAME>
union	_GTokenValue
{
  gpointer	v_symbol;
  gchar		*v_identifier;
  gulong	v_binary;
  gulong	v_octal;
  gulong	v_int;
  guint64       v_int64;
  gdouble	v_float;
  gulong	v_hex;
  gchar		*v_string;
  gchar		*v_comment;
  guchar	v_char;
  guint		v_error;
};
</UNION>
<STRUCT>
<NAME>GScannerConfig</NAME>
struct	_GScannerConfig
{
  /* Character sets
   */
  gchar		*cset_skip_characters;		/* default: " \t\n" */
  gchar		*cset_identifier_first;
  gchar		*cset_identifier_nth;
  gchar		*cpair_comment_single;		/* default: "#\n" */
  
  /* Should symbol lookup work case sensitive?
   */
  guint		case_sensitive : 1;
  
  /* Boolean values to be adjusted "on the fly"
   * to configure scanning behaviour.
   */
  guint		skip_comment_multi : 1;		/* C like comment */
  guint		skip_comment_single : 1;	/* single line comment */
  guint		scan_comment_multi : 1;		/* scan multi line comments? */
  guint		scan_identifier : 1;
  guint		scan_identifier_1char : 1;
  guint		scan_identifier_NULL : 1;
  guint		scan_symbols : 1;
  guint		scan_binary : 1;
  guint		scan_octal : 1;
  guint		scan_float : 1;
  guint		scan_hex : 1;			/* '0x0ff0' */
  guint		scan_hex_dollar : 1;		/* '$0ff0' */
  guint		scan_string_sq : 1;		/* string: 'anything' */
  guint		scan_string_dq : 1;		/* string: "\\-escapes!\n" */
  guint		numbers_2_int : 1;		/* bin, octal, hex => int */
  guint		int_2_float : 1;		/* int => G_TOKEN_FLOAT? */
  guint		identifier_2_string : 1;
  guint		char_2_token : 1;		/* return G_TOKEN_CHAR? */
  guint		symbol_2_token : 1;
  guint		scope_0_fallback : 1;		/* try scope 0 on lookups? */
  guint		store_int64 : 1; 		/* use value.v_int64 rather than v_int */

  /*< private >*/
  guint		padding_dummy;
};
</STRUCT>
<STRUCT>
<NAME>GScanner</NAME>
struct	_GScanner
{
  /* unused fields */
  gpointer		user_data;
  guint			max_parse_errors;
  
  /* g_scanner_error() increments this field */
  guint			parse_errors;
  
  /* name of input stream, featured by the default message handler */
  const gchar		*input_name;
  
  /* quarked data */
  GData			*qdata;
  
  /* link into the scanner configuration */
  GScannerConfig	*config;
  
  /* fields filled in after g_scanner_get_next_token() */
  GTokenType		token;
  GTokenValue		value;
  guint			line;
  guint			position;
  
  /* fields filled in after g_scanner_peek_next_token() */
  GTokenType		next_token;
  GTokenValue		next_value;
  guint			next_line;
  guint			next_position;

  /*< private >*/
  /* to be considered private */
  GHashTable		*symbol_table;
  gint			input_fd;
  const gchar		*text;
  const gchar		*text_end;
  gchar			*buffer;
  guint			scope_id;

  /*< public >*/
  /* handler function for _warn and _error */
  GScannerMsgFunc	msg_handler;
};
</STRUCT>
<FUNCTION>
<NAME>g_scanner_new</NAME>
<RETURNS>GScanner *	</RETURNS>
const GScannerConfig *config_templ
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_destroy</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_input_file</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, gint		input_fd
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_sync_file_offset</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_input_text</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, const	gchar	*text, guint		text_len
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_get_next_token</NAME>
<RETURNS>GTokenType 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_peek_next_token</NAME>
<RETURNS>GTokenType 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_token</NAME>
<RETURNS>GTokenType 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_value</NAME>
<RETURNS>GTokenValue 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_line</NAME>
<RETURNS>guint 		</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_position</NAME>
<RETURNS>guint 		</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_eof</NAME>
<RETURNS>gboolean 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_set_scope</NAME>
<RETURNS>guint 		</RETURNS>
GScanner	*scanner, guint		 scope_id
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_add_symbol</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, guint		 scope_id, const gchar	*symbol, gpointer	value
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_remove_symbol</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, guint		 scope_id, const gchar	*symbol
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_lookup_symbol</NAME>
<RETURNS>gpointer 	</RETURNS>
GScanner	*scanner, guint		 scope_id, const gchar	*symbol
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_foreach_symbol</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, guint		 scope_id, GHFunc		 func, gpointer	 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_lookup_symbol</NAME>
<RETURNS>gpointer 	</RETURNS>
GScanner	*scanner, const gchar	*symbol
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_unexp_token</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, GTokenType	expected_token, const gchar	*identifier_spec, const gchar	*symbol_spec, const gchar	*symbol_name, const gchar	*message, gint		 is_error
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_error</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, const gchar	*format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_warn</NAME>
<RETURNS>void 		</RETURNS>
GScanner	*scanner, const gchar	*format, ...
</FUNCTION>
<MACRO>
<NAME>g_scanner_add_symbol</NAME>
<DEPRECATED/>
#define		g_scanner_add_symbol( scanner, symbol, value )	G_STMT_START { \
  g_scanner_scope_add_symbol ((scanner), 0, (symbol), (value)); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>g_scanner_remove_symbol</NAME>
<DEPRECATED/>
#define		g_scanner_remove_symbol( scanner, symbol )	G_STMT_START { \
  g_scanner_scope_remove_symbol ((scanner), 0, (symbol)); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>g_scanner_foreach_symbol</NAME>
<DEPRECATED/>
#define		g_scanner_foreach_symbol( scanner, func, data )	G_STMT_START { \
  g_scanner_scope_foreach_symbol ((scanner), 0, (func), (data)); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>g_scanner_freeze_symbol_table</NAME>
<DEPRECATED/>
#define g_scanner_freeze_symbol_table(scanner) ((void)0)
</MACRO>
<MACRO>
<NAME>g_scanner_thaw_symbol_table</NAME>
<DEPRECATED/>
#define g_scanner_thaw_symbol_table(scanner) ((void)0)
</MACRO>
<TYPEDEF>
<NAME>GSequenceIter</NAME>
typedef struct _GSequenceNode  GSequenceIter;
</TYPEDEF>
<USER_FUNCTION>
<NAME>GSequenceIterCompareFunc</NAME>
<RETURNS>gint </RETURNS>
GSequenceIter *a,
                                           GSequenceIter *b,
                                           gpointer       data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_sequence_new</NAME>
<RETURNS>GSequence  *    </RETURNS>
GDestroyNotify            data_destroy
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_free</NAME>
<RETURNS>void            </RETURNS>
GSequence                *seq
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_get_length</NAME>
<RETURNS>gint            </RETURNS>
GSequence                *seq
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_foreach</NAME>
<RETURNS>void            </RETURNS>
GSequence                *seq, GFunc                     func, gpointer                  user_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_foreach_range</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *begin, GSequenceIter            *end, GFunc                     func, gpointer                  user_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_sort</NAME>
<RETURNS>void            </RETURNS>
GSequence                *seq, GCompareDataFunc          cmp_func, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_sort_iter</NAME>
<RETURNS>void            </RETURNS>
GSequence                *seq, GSequenceIterCompareFunc  cmp_func, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_is_empty</NAME>
<RETURNS>gboolean        </RETURNS>
GSequence                *seq
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_get_begin_iter</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_get_end_iter</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_get_iter_at_pos</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gint                      pos
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_append</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_prepend</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_insert_before</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequenceIter            *iter, gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_move</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *src, GSequenceIter            *dest
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_swap</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *a, GSequenceIter            *b
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_insert_sorted</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data, GCompareDataFunc          cmp_func, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_insert_sorted_iter</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data, GSequenceIterCompareFunc  iter_cmp, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_sort_changed</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *iter, GCompareDataFunc          cmp_func, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_sort_changed_iter</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *iter, GSequenceIterCompareFunc  iter_cmp, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_remove</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_remove_range</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *begin, GSequenceIter            *end
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_move_range</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *dest, GSequenceIter            *begin, GSequenceIter            *end
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_search</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data, GCompareDataFunc          cmp_func, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_search_iter</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data, GSequenceIterCompareFunc  iter_cmp, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_lookup</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data, GCompareDataFunc          cmp_func, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_lookup_iter</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequence                *seq, gpointer                  data, GSequenceIterCompareFunc  iter_cmp, gpointer                  cmp_data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_get</NAME>
<RETURNS>gpointer        </RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_set</NAME>
<RETURNS>void            </RETURNS>
GSequenceIter            *iter, gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_is_begin</NAME>
<RETURNS>gboolean        </RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_is_end</NAME>
<RETURNS>gboolean        </RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_next</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_prev</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_get_position</NAME>
<RETURNS>gint            </RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_move</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequenceIter            *iter, gint                      delta
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_get_sequence</NAME>
<RETURNS>GSequence  *    </RETURNS>
GSequenceIter            *iter
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_iter_compare</NAME>
<RETURNS>gint            </RETURNS>
GSequenceIter            *a, GSequenceIter            *b
</FUNCTION>
<FUNCTION>
<NAME>g_sequence_range_get_midpoint</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
GSequenceIter            *begin, GSequenceIter            *end
</FUNCTION>
<STRUCT>
<NAME>GSequence</NAME>
</STRUCT>
<MACRO>
<NAME>G_SHELL_ERROR</NAME>
#define G_SHELL_ERROR g_shell_error_quark ()
</MACRO>
<ENUM>
<NAME>GShellError</NAME>
typedef enum
{
  /* mismatched or otherwise mangled quoting */
  G_SHELL_ERROR_BAD_QUOTING,
  /* string to be parsed was empty */
  G_SHELL_ERROR_EMPTY_STRING,
  G_SHELL_ERROR_FAILED
} GShellError;
</ENUM>
<FUNCTION>
<NAME>g_shell_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_shell_quote</NAME>
<RETURNS>gchar *   </RETURNS>
const gchar   *unquoted_string
</FUNCTION>
<FUNCTION>
<NAME>g_shell_unquote</NAME>
<RETURNS>gchar *   </RETURNS>
const gchar   *quoted_string, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_shell_parse_argv</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar   *command_line, gint          *argcp, gchar       ***argvp, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_slice_alloc</NAME>
<RETURNS>gpointer  </RETURNS>
gsize	       block_size
</FUNCTION>
<FUNCTION>
<NAME>g_slice_alloc0</NAME>
<RETURNS>gpointer  </RETURNS>
gsize         block_size
</FUNCTION>
<FUNCTION>
<NAME>g_slice_copy</NAME>
<RETURNS>gpointer  </RETURNS>
gsize         block_size, gconstpointer mem_block
</FUNCTION>
<FUNCTION>
<NAME>g_slice_free1</NAME>
<RETURNS>void      </RETURNS>
gsize         block_size, gpointer      mem_block
</FUNCTION>
<FUNCTION>
<NAME>g_slice_free_chain_with_offset</NAME>
<RETURNS>void      </RETURNS>
gsize         block_size, gpointer      mem_chain, gsize         next_offset
</FUNCTION>
<MACRO>
<NAME>g_slice_new</NAME>
#define  g_slice_new(type)      ((type*) g_slice_alloc (sizeof (type)))
</MACRO>
<MACRO>
<NAME>g_slice_new0</NAME>
#define  g_slice_new0(type)     ((type*) g_slice_alloc0 (sizeof (type)))
</MACRO>
<MACRO>
<NAME>g_slice_dup</NAME>
#define g_slice_dup(type, mem)                                  \
  (1 ? (type*) g_slice_copy (sizeof (type), (mem))              \
     : ((void) ((type*) 0 == (mem)), (type*) 0))
</MACRO>
<MACRO>
<NAME>g_slice_free</NAME>
#define g_slice_free(type, mem)                                 \
G_STMT_START {                                                  \
  if (1) g_slice_free1 (sizeof (type), (mem));			\
  else   (void) ((type*) 0 == (mem)); 				\
} G_STMT_END
</MACRO>
<MACRO>
<NAME>g_slice_free_chain</NAME>
#define g_slice_free_chain(type, mem_chain, next)               \
G_STMT_START {                                                  \
  if (1) g_slice_free_chain_with_offset (sizeof (type),		\
                 (mem_chain), G_STRUCT_OFFSET (type, next)); 	\
  else   (void) ((type*) 0 == (mem_chain));			\
} G_STMT_END
</MACRO>
<ENUM>
<NAME>GSliceConfig</NAME>
typedef enum {
  G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
  G_SLICE_CONFIG_BYPASS_MAGAZINES,
  G_SLICE_CONFIG_WORKING_SET_MSECS,
  G_SLICE_CONFIG_COLOR_INCREMENT,
  G_SLICE_CONFIG_CHUNK_SIZES,
  G_SLICE_CONFIG_CONTENTION_COUNTER
} GSliceConfig;
</ENUM>
<FUNCTION>
<NAME>g_slice_set_config</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GSliceConfig ckey, gint64 value
</FUNCTION>
<FUNCTION>
<NAME>g_slice_get_config</NAME>
<DEPRECATED/>
<RETURNS>gint64    </RETURNS>
GSliceConfig ckey
</FUNCTION>
<FUNCTION>
<NAME>g_slice_get_config_state</NAME>
<DEPRECATED/>
<RETURNS>gint64 *  </RETURNS>
GSliceConfig ckey, gint64 address, guint *n_values
</FUNCTION>
<FUNCTION>
<NAME>g_slice_debug_tree_statistics</NAME>
<RETURNS>void      </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GSList</NAME>
struct _GSList
{
  gpointer data;
  GSList *next;
};
</STRUCT>
<FUNCTION>
<NAME>g_slist_alloc</NAME>
<RETURNS>GSList *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_slist_free</NAME>
<RETURNS>void      </RETURNS>
GSList           *list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_free_1</NAME>
<RETURNS>void      </RETURNS>
GSList           *list
</FUNCTION>
<MACRO>
<NAME>g_slist_free1</NAME>
#define	 g_slist_free1		         g_slist_free_1
</MACRO>
<FUNCTION>
<NAME>g_slist_free_full</NAME>
<RETURNS>void      </RETURNS>
GSList           *list, GDestroyNotify    free_func
</FUNCTION>
<FUNCTION>
<NAME>g_slist_append</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_prepend</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_insert</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gpointer          data, gint              position
</FUNCTION>
<FUNCTION>
<NAME>g_slist_insert_sorted</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gpointer          data, GCompareFunc      func
</FUNCTION>
<FUNCTION>
<NAME>g_slist_insert_sorted_with_data</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gpointer          data, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_insert_before</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *slist, GSList           *sibling, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_concat</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list1, GSList           *list2
</FUNCTION>
<FUNCTION>
<NAME>g_slist_remove</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_remove_all</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_remove_link</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, GSList           *link_
</FUNCTION>
<FUNCTION>
<NAME>g_slist_delete_link</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, GSList           *link_
</FUNCTION>
<FUNCTION>
<NAME>g_slist_reverse</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_copy</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_copy_deep</NAME>
<RETURNS>GSList *  </RETURNS>
GSList            *list, GCopyFunc         func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_nth</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, guint             n
</FUNCTION>
<FUNCTION>
<NAME>g_slist_find</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_find_custom</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, gconstpointer     data, GCompareFunc      func
</FUNCTION>
<FUNCTION>
<NAME>g_slist_position</NAME>
<RETURNS>gint      </RETURNS>
GSList           *list, GSList           *llink
</FUNCTION>
<FUNCTION>
<NAME>g_slist_index</NAME>
<RETURNS>gint      </RETURNS>
GSList           *list, gconstpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_last</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_length</NAME>
<RETURNS>guint     </RETURNS>
GSList           *list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_foreach</NAME>
<RETURNS>void      </RETURNS>
GSList           *list, GFunc             func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_sort</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, GCompareFunc      compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_slist_sort_with_data</NAME>
<RETURNS>GSList *  </RETURNS>
GSList           *list, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_nth_data</NAME>
<RETURNS>gpointer  </RETURNS>
GSList           *list, guint             n
</FUNCTION>
<MACRO>
<NAME>g_slist_next</NAME>
#define  g_slist_next(slist)	         ((slist) ? (((GSList *)(slist))->next) : NULL)
</MACRO>
<MACRO>
<NAME>G_SPAWN_ERROR</NAME>
#define G_SPAWN_ERROR g_spawn_error_quark ()
</MACRO>
<ENUM>
<NAME>GSpawnError</NAME>
typedef enum
{
  G_SPAWN_ERROR_FORK,   /* fork failed due to lack of memory */
  G_SPAWN_ERROR_READ,   /* read or select on pipes failed */
  G_SPAWN_ERROR_CHDIR,  /* changing to working dir failed */
  G_SPAWN_ERROR_ACCES,  /* execv() returned EACCES */
  G_SPAWN_ERROR_PERM,   /* execv() returned EPERM */
  G_SPAWN_ERROR_TOO_BIG,/* execv() returned E2BIG */
#ifndef G_DISABLE_DEPRECATED
  G_SPAWN_ERROR_2BIG = G_SPAWN_ERROR_TOO_BIG,
#endif
  G_SPAWN_ERROR_NOEXEC, /* execv() returned ENOEXEC */
  G_SPAWN_ERROR_NAMETOOLONG, /* ""  "" ENAMETOOLONG */
  G_SPAWN_ERROR_NOENT,       /* ""  "" ENOENT */
  G_SPAWN_ERROR_NOMEM,       /* ""  "" ENOMEM */
  G_SPAWN_ERROR_NOTDIR,      /* ""  "" ENOTDIR */
  G_SPAWN_ERROR_LOOP,        /* ""  "" ELOOP   */
  G_SPAWN_ERROR_TXTBUSY,     /* ""  "" ETXTBUSY */
  G_SPAWN_ERROR_IO,          /* ""  "" EIO */
  G_SPAWN_ERROR_NFILE,       /* ""  "" ENFILE */
  G_SPAWN_ERROR_MFILE,       /* ""  "" EMFLE */
  G_SPAWN_ERROR_INVAL,       /* ""  "" EINVAL */
  G_SPAWN_ERROR_ISDIR,       /* ""  "" EISDIR */
  G_SPAWN_ERROR_LIBBAD,      /* ""  "" ELIBBAD */
  G_SPAWN_ERROR_FAILED       /* other fatal failure, error->message
                              * should explain
                              */
} GSpawnError;
</ENUM>
<MACRO>
<NAME>G_SPAWN_EXIT_ERROR</NAME>
#define G_SPAWN_EXIT_ERROR g_spawn_exit_error_quark ()
</MACRO>
<USER_FUNCTION>
<NAME>GSpawnChildSetupFunc</NAME>
<RETURNS>void </RETURNS>
gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GSpawnFlags</NAME>
typedef enum
{
  G_SPAWN_DEFAULT                = 0,
  G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0,
  G_SPAWN_DO_NOT_REAP_CHILD      = 1 << 1,
  /* look for argv[0] in the path i.e. use execvp() */
  G_SPAWN_SEARCH_PATH            = 1 << 2,
  /* Dump output to /dev/null */
  G_SPAWN_STDOUT_TO_DEV_NULL     = 1 << 3,
  G_SPAWN_STDERR_TO_DEV_NULL     = 1 << 4,
  G_SPAWN_CHILD_INHERITS_STDIN   = 1 << 5,
  G_SPAWN_FILE_AND_ARGV_ZERO     = 1 << 6,
  G_SPAWN_SEARCH_PATH_FROM_ENVP  = 1 << 7,
  G_SPAWN_CLOEXEC_PIPES          = 1 << 8
} GSpawnFlags;
</ENUM>
<FUNCTION>
<NAME>g_spawn_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_exit_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_async</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar           *working_directory, gchar                **argv, gchar                **envp, GSpawnFlags            flags, GSpawnChildSetupFunc   child_setup, gpointer               user_data, GPid                  *child_pid, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_async_with_pipes</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar          *working_directory, gchar               **argv, gchar               **envp, GSpawnFlags           flags, GSpawnChildSetupFunc  child_setup, gpointer              user_data, GPid                 *child_pid, gint                 *standard_input, gint                 *standard_output, gint                 *standard_error, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_sync</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar          *working_directory, gchar               **argv, gchar               **envp, GSpawnFlags           flags, GSpawnChildSetupFunc  child_setup, gpointer              user_data, gchar               **standard_output, gchar               **standard_error, gint                 *exit_status, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_command_line_sync</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar          *command_line, gchar               **standard_output, gchar               **standard_error, gint                 *exit_status, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_command_line_async</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar          *command_line, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_check_exit_status</NAME>
<RETURNS>gboolean  </RETURNS>
gint      exit_status, GError  **error
</FUNCTION>
<FUNCTION>
<NAME>g_spawn_close_pid</NAME>
<RETURNS>void  </RETURNS>
GPid pid
</FUNCTION>
<TYPEDEF>
<NAME>GStatBuf</NAME>
typedef struct _stat32 GStatBuf;
</TYPEDEF>
<FUNCTION>
<NAME>g_access</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, int          mode
</FUNCTION>
<FUNCTION>
<NAME>g_chdir</NAME>
<RETURNS>int  </RETURNS>
const gchar *path
</FUNCTION>
<FUNCTION>
<NAME>g_unlink</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>g_rmdir</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>g_chmod</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, int          mode
</FUNCTION>
<FUNCTION>
<NAME>g_open</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, int          flags, int          mode
</FUNCTION>
<FUNCTION>
<NAME>g_creat</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, int          mode
</FUNCTION>
<FUNCTION>
<NAME>g_rename</NAME>
<RETURNS>int  </RETURNS>
const gchar *oldfilename, const gchar *newfilename
</FUNCTION>
<FUNCTION>
<NAME>g_mkdir</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, int          mode
</FUNCTION>
<FUNCTION>
<NAME>g_stat</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, GStatBuf    *buf
</FUNCTION>
<FUNCTION>
<NAME>g_lstat</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, GStatBuf    *buf
</FUNCTION>
<FUNCTION>
<NAME>g_remove</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>g_fopen</NAME>
<RETURNS>FILE  *</RETURNS>
const gchar *filename, const gchar *mode
</FUNCTION>
<FUNCTION>
<NAME>g_freopen</NAME>
<RETURNS>FILE  *</RETURNS>
const gchar *filename, const gchar *mode, FILE        *stream
</FUNCTION>
<FUNCTION>
<NAME>g_utime</NAME>
<RETURNS>int  </RETURNS>
const gchar    *filename, struct utimbuf *utb
</FUNCTION>
<FUNCTION>
<NAME>g_close</NAME>
<RETURNS>gboolean  </RETURNS>
gint       fd, GError   **error
</FUNCTION>
<STRUCT>
<NAME>utimbuf</NAME>
struct utimbuf;			/* Don't need the real definition of struct utimbuf when just
</STRUCT>
<STRUCT>
<NAME>GWin32PrivateStat</NAME>
struct _GWin32PrivateStat
{
  guint32 volume_serial;
  guint64 file_index;
  guint64 attributes;
  guint64 allocated_size;
  guint32 reparse_tag;

  guint32 st_dev;
  guint32 st_ino;
  guint16 st_mode;
  guint16 st_uid;
  guint16 st_gid;
  guint32 st_nlink;
  guint64 st_size;
  guint64 st_ctime;
  guint64 st_atime;
  guint64 st_mtime;
};
</STRUCT>
<FUNCTION>
<NAME>g_win32_stat_utf8</NAME>
<RETURNS>int  </RETURNS>
const gchar       *filename, GWin32PrivateStat *buf
</FUNCTION>
<FUNCTION>
<NAME>g_win32_lstat_utf8</NAME>
<RETURNS>int  </RETURNS>
const gchar       *filename, GWin32PrivateStat *buf
</FUNCTION>
<FUNCTION>
<NAME>g_win32_readlink_utf8</NAME>
<RETURNS>int  </RETURNS>
const gchar *filename, gchar       *buf, gsize        buf_size
</FUNCTION>
<FUNCTION>
<NAME>g_win32_fstat</NAME>
<RETURNS>int  </RETURNS>
int                fd, GWin32PrivateStat *buf
</FUNCTION>
<STRUCT>
<NAME>GWin32PrivateStat</NAME>
</STRUCT>
<ENUM>
<NAME>GAsciiType</NAME>
typedef enum {
  G_ASCII_ALNUM  = 1 << 0,
  G_ASCII_ALPHA  = 1 << 1,
  G_ASCII_CNTRL  = 1 << 2,
  G_ASCII_DIGIT  = 1 << 3,
  G_ASCII_GRAPH  = 1 << 4,
  G_ASCII_LOWER  = 1 << 5,
  G_ASCII_PRINT  = 1 << 6,
  G_ASCII_PUNCT  = 1 << 7,
  G_ASCII_SPACE  = 1 << 8,
  G_ASCII_UPPER  = 1 << 9,
  G_ASCII_XDIGIT = 1 << 10
} GAsciiType;
</ENUM>
<VARIABLE>
<NAME>g_ascii_table</NAME>
extern const guint16 * const g_ascii_table;
</VARIABLE>
<MACRO>
<NAME>g_ascii_isalnum</NAME>
#define g_ascii_isalnum(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_ALNUM) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_isalpha</NAME>
#define g_ascii_isalpha(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_ALPHA) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_iscntrl</NAME>
#define g_ascii_iscntrl(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_CNTRL) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_isdigit</NAME>
#define g_ascii_isdigit(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_DIGIT) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_isgraph</NAME>
#define g_ascii_isgraph(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_GRAPH) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_islower</NAME>
#define g_ascii_islower(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_LOWER) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_isprint</NAME>
#define g_ascii_isprint(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_PRINT) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_ispunct</NAME>
#define g_ascii_ispunct(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_PUNCT) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_isspace</NAME>
#define g_ascii_isspace(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_SPACE) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_isupper</NAME>
#define g_ascii_isupper(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_UPPER) != 0)
</MACRO>
<MACRO>
<NAME>g_ascii_isxdigit</NAME>
#define g_ascii_isxdigit(c) \
  ((g_ascii_table[(guchar) (c)] & G_ASCII_XDIGIT) != 0)
</MACRO>
<FUNCTION>
<NAME>g_ascii_tolower</NAME>
<RETURNS>gchar                  </RETURNS>
gchar        c
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_toupper</NAME>
<RETURNS>gchar                  </RETURNS>
gchar        c
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_digit_value</NAME>
<RETURNS>gint                   </RETURNS>
gchar    c
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_xdigit_value</NAME>
<RETURNS>gint                   </RETURNS>
gchar    c
</FUNCTION>
<MACRO>
<NAME>G_STR_DELIMITERS</NAME>
#define	 G_STR_DELIMITERS	"_-|> <."
</MACRO>
<FUNCTION>
<NAME>g_strdelimit</NAME>
<RETURNS>gchar *	              </RETURNS>
gchar	     *string, const gchar  *delimiters, gchar	      new_delimiter
</FUNCTION>
<FUNCTION>
<NAME>g_strcanon</NAME>
<RETURNS>gchar *	              </RETURNS>
gchar        *string, const gchar  *valid_chars, gchar         substitutor
</FUNCTION>
<FUNCTION>
<NAME>g_strerror</NAME>
<RETURNS>const gchar  *         </RETURNS>
gint	      errnum
</FUNCTION>
<FUNCTION>
<NAME>g_strsignal</NAME>
<RETURNS>const gchar  *         </RETURNS>
gint	      signum
</FUNCTION>
<FUNCTION>
<NAME>g_strreverse</NAME>
<RETURNS>gchar  *	              </RETURNS>
gchar	     *string
</FUNCTION>
<FUNCTION>
<NAME>g_strlcpy</NAME>
<RETURNS>gsize 	              </RETURNS>
gchar	     *dest, const gchar  *src, gsize         dest_size
</FUNCTION>
<FUNCTION>
<NAME>g_strlcat</NAME>
<RETURNS>gsize 	              </RETURNS>
gchar	     *dest, const gchar  *src, gsize         dest_size
</FUNCTION>
<FUNCTION>
<NAME>g_strstr_len</NAME>
<RETURNS>gchar  *               </RETURNS>
const gchar  *haystack, gssize        haystack_len, const gchar  *needle
</FUNCTION>
<FUNCTION>
<NAME>g_strrstr</NAME>
<RETURNS>gchar  *               </RETURNS>
const gchar  *haystack, const gchar  *needle
</FUNCTION>
<FUNCTION>
<NAME>g_strrstr_len</NAME>
<RETURNS>gchar  *               </RETURNS>
const gchar  *haystack, gssize        haystack_len, const gchar  *needle
</FUNCTION>
<FUNCTION>
<NAME>g_str_has_suffix</NAME>
<RETURNS>gboolean               </RETURNS>
const gchar  *str, const gchar  *suffix
</FUNCTION>
<FUNCTION>
<NAME>g_str_has_prefix</NAME>
<RETURNS>gboolean               </RETURNS>
const gchar  *str, const gchar  *prefix
</FUNCTION>
<FUNCTION>
<NAME>g_strtod</NAME>
<RETURNS>gdouble 	              </RETURNS>
const gchar  *nptr, gchar	    **endptr
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_strtod</NAME>
<RETURNS>gdouble 	              </RETURNS>
const gchar  *nptr, gchar	    **endptr
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_strtoull</NAME>
<RETURNS>guint64 		      </RETURNS>
const gchar *nptr, gchar      **endptr, guint        base
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_strtoll</NAME>
<RETURNS>gint64 		      </RETURNS>
const gchar *nptr, gchar      **endptr, guint        base
</FUNCTION>
<MACRO>
<NAME>G_ASCII_DTOSTR_BUF_SIZE</NAME>
#define G_ASCII_DTOSTR_BUF_SIZE (29 + 10)
</MACRO>
<FUNCTION>
<NAME>g_ascii_dtostr</NAME>
<RETURNS>gchar  *               </RETURNS>
gchar        *buffer, gint          buf_len, gdouble       d
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_formatd</NAME>
<RETURNS>gchar  *               </RETURNS>
gchar        *buffer, gint          buf_len, const gchar  *format, gdouble       d
</FUNCTION>
<FUNCTION>
<NAME>g_strchug</NAME>
<RETURNS>gchar *                </RETURNS>
gchar        *string
</FUNCTION>
<FUNCTION>
<NAME>g_strchomp</NAME>
<RETURNS>gchar *                </RETURNS>
gchar        *string
</FUNCTION>
<MACRO>
<NAME>g_strstrip</NAME>
#define g_strstrip( string )	g_strchomp (g_strchug (string))
</MACRO>
<FUNCTION>
<NAME>g_ascii_strcasecmp</NAME>
<RETURNS>gint                   </RETURNS>
const gchar *s1, const gchar *s2
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_strncasecmp</NAME>
<RETURNS>gint                   </RETURNS>
const gchar *s1, const gchar *s2, gsize        n
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_strdown</NAME>
<RETURNS>gchar *                </RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_strup</NAME>
<RETURNS>gchar *                </RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<FUNCTION>
<NAME>g_str_is_ascii</NAME>
<RETURNS>gboolean               </RETURNS>
const gchar *str
</FUNCTION>
<FUNCTION>
<NAME>g_strcasecmp</NAME>
<DEPRECATED/>
<RETURNS>gint                   </RETURNS>
const gchar *s1, const gchar *s2
</FUNCTION>
<FUNCTION>
<NAME>g_strncasecmp</NAME>
<DEPRECATED/>
<RETURNS>gint                   </RETURNS>
const gchar *s1, const gchar *s2, guint        n
</FUNCTION>
<FUNCTION>
<NAME>g_strdown</NAME>
<DEPRECATED/>
<RETURNS>gchar *                </RETURNS>
gchar       *string
</FUNCTION>
<FUNCTION>
<NAME>g_strup</NAME>
<DEPRECATED/>
<RETURNS>gchar *                </RETURNS>
gchar       *string
</FUNCTION>
<FUNCTION>
<NAME>g_strdup</NAME>
<RETURNS>gchar *	              </RETURNS>
const gchar *str
</FUNCTION>
<FUNCTION>
<NAME>g_strdup_printf</NAME>
<RETURNS>gchar *	              </RETURNS>
const gchar *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_strdup_vprintf</NAME>
<RETURNS>gchar *	              </RETURNS>
const gchar *format, va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_strndup</NAME>
<RETURNS>gchar *	              </RETURNS>
const gchar *str, gsize        n
</FUNCTION>
<FUNCTION>
<NAME>g_strnfill</NAME>
<RETURNS>gchar *	              </RETURNS>
gsize        length, gchar        fill_char
</FUNCTION>
<FUNCTION>
<NAME>g_strconcat</NAME>
<RETURNS>gchar *	              </RETURNS>
const gchar *string1, ...
</FUNCTION>
<FUNCTION>
<NAME>g_strjoin</NAME>
<RETURNS>gchar *                </RETURNS>
const gchar  *separator, ...
</FUNCTION>
<FUNCTION>
<NAME>g_strcompress</NAME>
<RETURNS>gchar *                </RETURNS>
const gchar *source
</FUNCTION>
<FUNCTION>
<NAME>g_strescape</NAME>
<RETURNS>gchar *                </RETURNS>
const gchar *source, const gchar *exceptions
</FUNCTION>
<FUNCTION>
<NAME>g_memdup</NAME>
<RETURNS>gpointer               </RETURNS>
gconstpointer mem, guint	       byte_size
</FUNCTION>
<TYPEDEF>
<NAME>GStrv</NAME>
typedef gchar** GStrv;
</TYPEDEF>
<FUNCTION>
<NAME>g_strsplit</NAME>
<RETURNS>gchar **	              </RETURNS>
const gchar  *string, const gchar  *delimiter, gint          max_tokens
</FUNCTION>
<FUNCTION>
<NAME>g_strsplit_set</NAME>
<RETURNS>gchar  **	      </RETURNS>
const gchar *string, const gchar *delimiters, gint         max_tokens
</FUNCTION>
<FUNCTION>
<NAME>g_strjoinv</NAME>
<RETURNS>gchar *                </RETURNS>
const gchar  *separator, gchar       **str_array
</FUNCTION>
<FUNCTION>
<NAME>g_strfreev</NAME>
<RETURNS>void                   </RETURNS>
gchar       **str_array
</FUNCTION>
<FUNCTION>
<NAME>g_strdupv</NAME>
<RETURNS>gchar **               </RETURNS>
gchar       **str_array
</FUNCTION>
<FUNCTION>
<NAME>g_strv_length</NAME>
<RETURNS>guint                  </RETURNS>
gchar       **str_array
</FUNCTION>
<FUNCTION>
<NAME>g_stpcpy</NAME>
<RETURNS>gchar *                </RETURNS>
gchar        *dest, const char   *src
</FUNCTION>
<FUNCTION>
<NAME>g_str_to_ascii</NAME>
<RETURNS>gchar  *                 </RETURNS>
const gchar   *str, const gchar   *from_locale
</FUNCTION>
<FUNCTION>
<NAME>g_str_tokenize_and_fold</NAME>
<RETURNS>gchar  **                </RETURNS>
const gchar   *string, const gchar   *translit_locale, gchar       ***ascii_alternates
</FUNCTION>
<FUNCTION>
<NAME>g_str_match_string</NAME>
<RETURNS>gboolean                 </RETURNS>
const gchar   *search_term, const gchar   *potential_hit, gboolean       accept_alternates
</FUNCTION>
<FUNCTION>
<NAME>g_strv_contains</NAME>
<RETURNS>gboolean               </RETURNS>
const gchar * const *strv, const gchar         *str
</FUNCTION>
<ENUM>
<NAME>GNumberParserError</NAME>
typedef enum
  {
    G_NUMBER_PARSER_ERROR_INVALID,
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS,
  } GNumberParserError;
</ENUM>
<MACRO>
<NAME>G_NUMBER_PARSER_ERROR</NAME>
#define G_NUMBER_PARSER_ERROR (g_number_parser_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_number_parser_error_quark</NAME>
<RETURNS>GQuark                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_string_to_signed</NAME>
<RETURNS>gboolean               </RETURNS>
const gchar  *str, guint         base, gint64        min, gint64        max, gint64       *out_num, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_ascii_string_to_unsigned</NAME>
<RETURNS>gboolean               </RETURNS>
const gchar  *str, guint         base, guint64       min, guint64       max, guint64      *out_num, GError      **error
</FUNCTION>
<STRUCT>
<NAME>GString</NAME>
struct _GString
{
  gchar  *str;
  gsize len;
  gsize allocated_len;
};
</STRUCT>
<FUNCTION>
<NAME>g_string_new</NAME>
<RETURNS>GString *     </RETURNS>
const gchar     *init
</FUNCTION>
<FUNCTION>
<NAME>g_string_new_len</NAME>
<RETURNS>GString *     </RETURNS>
const gchar     *init, gssize           len
</FUNCTION>
<FUNCTION>
<NAME>g_string_sized_new</NAME>
<RETURNS>GString *     </RETURNS>
gsize            dfl_size
</FUNCTION>
<FUNCTION>
<NAME>g_string_free</NAME>
<RETURNS>gchar *       </RETURNS>
GString         *string, gboolean         free_segment
</FUNCTION>
<FUNCTION>
<NAME>g_string_free_to_bytes</NAME>
<RETURNS>GBytes *      </RETURNS>
GString         *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_equal</NAME>
<RETURNS>gboolean      </RETURNS>
const GString   *v, const GString   *v2
</FUNCTION>
<FUNCTION>
<NAME>g_string_hash</NAME>
<RETURNS>guint         </RETURNS>
const GString   *str
</FUNCTION>
<FUNCTION>
<NAME>g_string_assign</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, const gchar     *rval
</FUNCTION>
<FUNCTION>
<NAME>g_string_truncate</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gsize            len
</FUNCTION>
<FUNCTION>
<NAME>g_string_set_size</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gsize            len
</FUNCTION>
<FUNCTION>
<NAME>g_string_insert_len</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gssize           pos, const gchar     *val, gssize           len
</FUNCTION>
<FUNCTION>
<NAME>g_string_append</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, const gchar     *val
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_len</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, const gchar     *val, gssize           len
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_c</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gchar            c
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_unichar</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gunichar         wc
</FUNCTION>
<FUNCTION>
<NAME>g_string_prepend</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, const gchar     *val
</FUNCTION>
<FUNCTION>
<NAME>g_string_prepend_c</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gchar            c
</FUNCTION>
<FUNCTION>
<NAME>g_string_prepend_unichar</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gunichar         wc
</FUNCTION>
<FUNCTION>
<NAME>g_string_prepend_len</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, const gchar     *val, gssize           len
</FUNCTION>
<FUNCTION>
<NAME>g_string_insert</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gssize           pos, const gchar     *val
</FUNCTION>
<FUNCTION>
<NAME>g_string_insert_c</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gssize           pos, gchar            c
</FUNCTION>
<FUNCTION>
<NAME>g_string_insert_unichar</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gssize           pos, gunichar         wc
</FUNCTION>
<FUNCTION>
<NAME>g_string_overwrite</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gsize            pos, const gchar     *val
</FUNCTION>
<FUNCTION>
<NAME>g_string_overwrite_len</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gsize            pos, const gchar     *val, gssize           len
</FUNCTION>
<FUNCTION>
<NAME>g_string_erase</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, gssize           pos, gssize           len
</FUNCTION>
<FUNCTION>
<NAME>g_string_ascii_down</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_ascii_up</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_vprintf</NAME>
<RETURNS>void          </RETURNS>
GString         *string, const gchar     *format, va_list          args
</FUNCTION>
<FUNCTION>
<NAME>g_string_printf</NAME>
<RETURNS>void          </RETURNS>
GString         *string, const gchar     *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_vprintf</NAME>
<RETURNS>void          </RETURNS>
GString         *string, const gchar     *format, va_list          args
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_printf</NAME>
<RETURNS>void          </RETURNS>
GString         *string, const gchar     *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_uri_escaped</NAME>
<RETURNS>GString *     </RETURNS>
GString         *string, const gchar     *unescaped, const gchar     *reserved_chars_allowed, gboolean         allow_utf8
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_c_inline</NAME>
<RETURNS>GString *</RETURNS>
GString *gstring, gchar    c
</FUNCTION>
<FUNCTION>
<NAME>g_string_down</NAME>
<DEPRECATED/>
<RETURNS>GString  *</RETURNS>
GString *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_up</NAME>
<DEPRECATED/>
<RETURNS>GString  *</RETURNS>
GString *string
</FUNCTION>
<MACRO>
<NAME>g_string_sprintf</NAME>
<DEPRECATED/>
#define  g_string_sprintf  g_string_printf
</MACRO>
<MACRO>
<NAME>g_string_sprintfa</NAME>
<DEPRECATED/>
#define  g_string_sprintfa g_string_append_printf
</MACRO>
<FUNCTION>
<NAME>g_string_chunk_new</NAME>
<RETURNS>GStringChunk * </RETURNS>
gsize size
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_free</NAME>
<RETURNS>void           </RETURNS>
GStringChunk *chunk
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_clear</NAME>
<RETURNS>void           </RETURNS>
GStringChunk *chunk
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_insert</NAME>
<RETURNS>gchar *        </RETURNS>
GStringChunk *chunk, const gchar  *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_insert_len</NAME>
<RETURNS>gchar *        </RETURNS>
GStringChunk *chunk, const gchar  *string, gssize        len
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_insert_const</NAME>
<RETURNS>gchar *        </RETURNS>
GStringChunk *chunk, const gchar  *string
</FUNCTION>
<STRUCT>
<NAME>GStringChunk</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GTestCase</NAME>
typedef struct GTestCase  GTestCase;
</TYPEDEF>
<TYPEDEF>
<NAME>GTestSuite</NAME>
typedef struct GTestSuite GTestSuite;
</TYPEDEF>
<USER_FUNCTION>
<NAME>GTestFunc</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTestDataFunc</NAME>
<RETURNS>void </RETURNS>
gconstpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTestFixtureFunc</NAME>
<RETURNS>void </RETURNS>
gpointer      fixture,
                                  gconstpointer user_data
</USER_FUNCTION>
<MACRO>
<NAME>g_assert_cmpstr</NAME>
#define g_assert_cmpstr(s1, cmp, s2)    G_STMT_START { \
                                             const char *__s1 = (s1), *__s2 = (s2); \
                                             if (g_strcmp0 (__s1, __s2) cmp 0) ; else \
                                               g_assertion_message_cmpstr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                 #s1 " " #cmp " " #s2, __s1, #cmp, __s2); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_cmpint</NAME>
#define g_assert_cmpint(n1, cmp, n2)    G_STMT_START { \
                                             gint64 __n1 = (n1), __n2 = (n2); \
                                             if (__n1 cmp __n2) ; else \
                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                 #n1 " " #cmp " " #n2, (long double) __n1, #cmp, (long double) __n2, 'i'); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_cmpuint</NAME>
#define g_assert_cmpuint(n1, cmp, n2)   G_STMT_START { \
                                             guint64 __n1 = (n1), __n2 = (n2); \
                                             if (__n1 cmp __n2) ; else \
                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                 #n1 " " #cmp " " #n2, (long double) __n1, #cmp, (long double) __n2, 'i'); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_cmphex</NAME>
#define g_assert_cmphex(n1, cmp, n2)    G_STMT_START {\
                                             guint64 __n1 = (n1), __n2 = (n2); \
                                             if (__n1 cmp __n2) ; else \
                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                 #n1 " " #cmp " " #n2, (long double) __n1, #cmp, (long double) __n2, 'x'); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_cmpfloat</NAME>
#define g_assert_cmpfloat(n1,cmp,n2)    G_STMT_START { \
                                             long double __n1 = (n1), __n2 = (n2); \
                                             if (__n1 cmp __n2) ; else \
                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                 #n1 " " #cmp " " #n2, (long double) __n1, #cmp, (long double) __n2, 'f'); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_cmpmem</NAME>
#define g_assert_cmpmem(m1, l1, m2, l2) G_STMT_START {\
                                             gconstpointer __m1 = m1, __m2 = m2; \
                                             int __l1 = l1, __l2 = l2; \
                                             if (__l1 != __l2) \
                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                                           #l1 " (len(" #m1 ")) == " #l2 " (len(" #m2 "))", \
                                                                           (long double) __l1, "==", (long double) __l2, 'i'); \
                                             else if (__l1 != 0 && memcmp (__m1, __m2, __l1) != 0) \
                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                                    "assertion failed (" #m1 " == " #m2 ")"); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_no_error</NAME>
#define g_assert_no_error(err)          G_STMT_START { \
                                             if (err) \
                                               g_assertion_message_error (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                 #err, err, 0, 0); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_error</NAME>
#define g_assert_error(err, dom, c)     G_STMT_START { \
                                               if (!err || (err)->domain != dom || (err)->code != c) \
                                               g_assertion_message_error (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                 #err, err, dom, c); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_true</NAME>
#define g_assert_true(expr)             G_STMT_START { \
                                             if G_LIKELY (expr) ; else \
                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                                    "'" #expr "' should be TRUE"); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_false</NAME>
#define g_assert_false(expr)            G_STMT_START { \
                                             if G_LIKELY (!(expr)) ; else \
                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                                    "'" #expr "' should be FALSE"); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_null</NAME>
#define g_assert_null(expr)             G_STMT_START { if G_LIKELY ((expr) == NULL) ; else \
                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                                    "'" #expr "' should be NULL"); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_nonnull</NAME>
#define g_assert_nonnull(expr)          G_STMT_START { \
                                             if G_LIKELY ((expr) != NULL) ; else \
                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
                                                                    "'" #expr "' should not be NULL"); \
                                        } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_not_reached</NAME>
#define g_assert_not_reached()          G_STMT_START { (void) 0; } G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert</NAME>
#define g_assert(expr)                  G_STMT_START { (void) 0; } G_STMT_END
</MACRO>
<FUNCTION>
<NAME>g_strcmp0</NAME>
<RETURNS>int      </RETURNS>
const char     *str1, const char     *str2
</FUNCTION>
<FUNCTION>
<NAME>g_test_minimized_result</NAME>
<RETURNS>void     </RETURNS>
double          minimized_quantity, const char     *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_test_maximized_result</NAME>
<RETURNS>void     </RETURNS>
double          maximized_quantity, const char     *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_test_init</NAME>
<RETURNS>void     </RETURNS>
int            *argc, char         ***argv, ...
</FUNCTION>
<MACRO>
<NAME>g_test_initialized</NAME>
#define g_test_initialized()            (g_test_config_vars->test_initialized)
</MACRO>
<MACRO>
<NAME>g_test_quick</NAME>
#define g_test_quick()                  (g_test_config_vars->test_quick)
</MACRO>
<MACRO>
<NAME>g_test_slow</NAME>
#define g_test_slow()                   (!g_test_config_vars->test_quick)
</MACRO>
<MACRO>
<NAME>g_test_thorough</NAME>
#define g_test_thorough()               (!g_test_config_vars->test_quick)
</MACRO>
<MACRO>
<NAME>g_test_perf</NAME>
#define g_test_perf()                   (g_test_config_vars->test_perf)
</MACRO>
<MACRO>
<NAME>g_test_verbose</NAME>
#define g_test_verbose()                (g_test_config_vars->test_verbose)
</MACRO>
<MACRO>
<NAME>g_test_quiet</NAME>
#define g_test_quiet()                  (g_test_config_vars->test_quiet)
</MACRO>
<MACRO>
<NAME>g_test_undefined</NAME>
#define g_test_undefined()              (g_test_config_vars->test_undefined)
</MACRO>
<FUNCTION>
<NAME>g_test_subprocess</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_run</NAME>
<RETURNS>int      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_add_func</NAME>
<RETURNS>void     </RETURNS>
const char     *testpath, GTestFunc       test_func
</FUNCTION>
<FUNCTION>
<NAME>g_test_add_data_func</NAME>
<RETURNS>void     </RETURNS>
const char     *testpath, gconstpointer   test_data, GTestDataFunc   test_func
</FUNCTION>
<FUNCTION>
<NAME>g_test_add_data_func_full</NAME>
<RETURNS>void     </RETURNS>
const char     *testpath, gpointer        test_data, GTestDataFunc   test_func, GDestroyNotify  data_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_test_fail</NAME>
<RETURNS>void     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_incomplete</NAME>
<RETURNS>void     </RETURNS>
const gchar *msg
</FUNCTION>
<FUNCTION>
<NAME>g_test_skip</NAME>
<RETURNS>void     </RETURNS>
const gchar *msg
</FUNCTION>
<FUNCTION>
<NAME>g_test_failed</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_set_nonfatal_assertions</NAME>
<RETURNS>void     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>g_test_add</NAME>
#define g_test_add(testpath, Fixture, tdata, fsetup, ftest, fteardown) \
					G_STMT_START {			\
                                         void (*add_vtable) (const char*,       \
                                                    gsize,             \
                                                    gconstpointer,     \
                                                    void (*) (Fixture*, gconstpointer),   \
                                                    void (*) (Fixture*, gconstpointer),   \
                                                    void (*) (Fixture*, gconstpointer)) =  (void (*) (const gchar *, gsize, gconstpointer, void (*) (Fixture*, gconstpointer), void (*) (Fixture*, gconstpointer), void (*) (Fixture*, gconstpointer))) g_test_add_vtable; \
                                         add_vtable \
                                          (testpath, sizeof (Fixture), tdata, fsetup, ftest, fteardown); \
					} G_STMT_END
</MACRO>
<FUNCTION>
<NAME>g_test_message</NAME>
<RETURNS>void     </RETURNS>
const char *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_test_bug_base</NAME>
<RETURNS>void     </RETURNS>
const char *uri_pattern
</FUNCTION>
<FUNCTION>
<NAME>g_test_bug</NAME>
<RETURNS>void     </RETURNS>
const char *bug_uri_snippet
</FUNCTION>
<FUNCTION>
<NAME>g_test_timer_start</NAME>
<RETURNS>void     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_timer_elapsed</NAME>
<RETURNS>double   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_timer_last</NAME>
<RETURNS>double   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_queue_free</NAME>
<RETURNS>void     </RETURNS>
gpointer gfree_pointer
</FUNCTION>
<FUNCTION>
<NAME>g_test_queue_destroy</NAME>
<RETURNS>void     </RETURNS>
GDestroyNotify destroy_func, gpointer       destroy_data
</FUNCTION>
<MACRO>
<NAME>g_test_queue_unref</NAME>
#define g_test_queue_unref(gobject)     g_test_queue_destroy (g_object_unref, gobject)
</MACRO>
<ENUM>
<NAME>GTestTrapFlags</NAME>
typedef enum {
  G_TEST_TRAP_SILENCE_STDOUT    = 1 << 7,
  G_TEST_TRAP_SILENCE_STDERR    = 1 << 8,
  G_TEST_TRAP_INHERIT_STDIN     = 1 << 9
} GTestTrapFlags;
</ENUM>
<FUNCTION>
<NAME>g_test_trap_fork</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
guint64              usec_timeout, GTestTrapFlags       test_trap_flags
</FUNCTION>
<ENUM>
<NAME>GTestSubprocessFlags</NAME>
typedef enum {
  G_TEST_SUBPROCESS_INHERIT_STDIN  = 1 << 0,
  G_TEST_SUBPROCESS_INHERIT_STDOUT = 1 << 1,
  G_TEST_SUBPROCESS_INHERIT_STDERR = 1 << 2
} GTestSubprocessFlags;
</ENUM>
<FUNCTION>
<NAME>g_test_trap_subprocess</NAME>
<RETURNS>void      </RETURNS>
const char           *test_path, guint64               usec_timeout, GTestSubprocessFlags  test_flags
</FUNCTION>
<FUNCTION>
<NAME>g_test_trap_has_passed</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_trap_reached_timeout</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>g_test_trap_assert_passed</NAME>
#define  g_test_trap_assert_passed()                      g_test_trap_assertions (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, 0, 0)
</MACRO>
<MACRO>
<NAME>g_test_trap_assert_failed</NAME>
#define  g_test_trap_assert_failed()                      g_test_trap_assertions (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, 1, 0)
</MACRO>
<MACRO>
<NAME>g_test_trap_assert_stdout</NAME>
#define  g_test_trap_assert_stdout(soutpattern)           g_test_trap_assertions (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, 2, soutpattern)
</MACRO>
<MACRO>
<NAME>g_test_trap_assert_stdout_unmatched</NAME>
#define  g_test_trap_assert_stdout_unmatched(soutpattern) g_test_trap_assertions (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, 3, soutpattern)
</MACRO>
<MACRO>
<NAME>g_test_trap_assert_stderr</NAME>
#define  g_test_trap_assert_stderr(serrpattern)           g_test_trap_assertions (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, 4, serrpattern)
</MACRO>
<MACRO>
<NAME>g_test_trap_assert_stderr_unmatched</NAME>
#define  g_test_trap_assert_stderr_unmatched(serrpattern) g_test_trap_assertions (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, 5, serrpattern)
</MACRO>
<MACRO>
<NAME>g_test_rand_bit</NAME>
#define  g_test_rand_bit()              (0 != (g_test_rand_int() & (1 << 15)))
</MACRO>
<FUNCTION>
<NAME>g_test_rand_int</NAME>
<RETURNS>gint32    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_rand_int_range</NAME>
<RETURNS>gint32    </RETURNS>
gint32          begin, gint32          end
</FUNCTION>
<FUNCTION>
<NAME>g_test_rand_double</NAME>
<RETURNS>double    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_rand_double_range</NAME>
<RETURNS>double    </RETURNS>
double          range_start, double          range_end
</FUNCTION>
<FUNCTION>
<NAME>g_test_create_case</NAME>
<RETURNS>GTestCase *    </RETURNS>
const char       *test_name, gsize             data_size, gconstpointer     test_data, GTestFixtureFunc  data_setup, GTestFixtureFunc  data_test, GTestFixtureFunc  data_teardown
</FUNCTION>
<FUNCTION>
<NAME>g_test_create_suite</NAME>
<RETURNS>GTestSuite *   </RETURNS>
const char       *suite_name
</FUNCTION>
<FUNCTION>
<NAME>g_test_get_root</NAME>
<RETURNS>GTestSuite *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_suite_add</NAME>
<RETURNS>void           </RETURNS>
GTestSuite     *suite, GTestCase      *test_case
</FUNCTION>
<FUNCTION>
<NAME>g_test_suite_add_suite</NAME>
<RETURNS>void           </RETURNS>
GTestSuite     *suite, GTestSuite     *nestedsuite
</FUNCTION>
<FUNCTION>
<NAME>g_test_run_suite</NAME>
<RETURNS>int            </RETURNS>
GTestSuite     *suite
</FUNCTION>
<FUNCTION>
<NAME>g_test_trap_assertions</NAME>
<RETURNS>void     </RETURNS>
const char     *domain, const char     *file, int             line, const char     *func, guint64         assertion_flags, const char     *pattern
</FUNCTION>
<FUNCTION>
<NAME>g_assertion_message</NAME>
<RETURNS>void     </RETURNS>
const char     *domain, const char     *file, int             line, const char     *func, const char     *message
</FUNCTION>
<FUNCTION>
<NAME>g_assertion_message_expr</NAME>
<RETURNS>void     </RETURNS>
const char     *domain, const char     *file, int             line, const char     *func, const char     *expr
</FUNCTION>
<FUNCTION>
<NAME>g_assertion_message_cmpstr</NAME>
<RETURNS>void     </RETURNS>
const char     *domain, const char     *file, int             line, const char     *func, const char     *expr, const char     *arg1, const char     *cmp, const char     *arg2
</FUNCTION>
<FUNCTION>
<NAME>g_assertion_message_cmpnum</NAME>
<RETURNS>void     </RETURNS>
const char     *domain, const char     *file, int             line, const char     *func, const char     *expr, long double     arg1, const char     *cmp, long double     arg2, char            numtype
</FUNCTION>
<FUNCTION>
<NAME>g_assertion_message_error</NAME>
<RETURNS>void     </RETURNS>
const char     *domain, const char     *file, int             line, const char     *func, const char     *expr, const GError   *error, GQuark          error_domain, int             error_code
</FUNCTION>
<FUNCTION>
<NAME>g_test_add_vtable</NAME>
<RETURNS>void     </RETURNS>
const char     *testpath, gsize           data_size, gconstpointer   test_data, GTestFixtureFunc  data_setup, GTestFixtureFunc  data_test, GTestFixtureFunc  data_teardown
</FUNCTION>
<STRUCT>
<NAME>GTestConfig</NAME>
typedef struct {
  gboolean      test_initialized;
  gboolean      test_quick;     /* disable thorough tests */
  gboolean      test_perf;      /* run performance tests */
  gboolean      test_verbose;   /* extra info */
  gboolean      test_quiet;     /* reduce output */
  gboolean      test_undefined; /* run tests that are meant to assert */
} GTestConfig;
</STRUCT>
<VARIABLE>
<NAME>g_test_config_vars</NAME>
extern const GTestConfig * const g_test_config_vars;
</VARIABLE>
<ENUM>
<NAME>GTestResult</NAME>
typedef enum {
  G_TEST_RUN_SUCCESS,
  G_TEST_RUN_SKIPPED,
  G_TEST_RUN_FAILURE,
  G_TEST_RUN_INCOMPLETE
} GTestResult;
</ENUM>
<ENUM>
<NAME>GTestLogType</NAME>
typedef enum {
  G_TEST_LOG_NONE,
  G_TEST_LOG_ERROR,             /* s:msg */
  G_TEST_LOG_START_BINARY,      /* s:binaryname s:seed */
  G_TEST_LOG_LIST_CASE,         /* s:testpath */
  G_TEST_LOG_SKIP_CASE,         /* s:testpath */
  G_TEST_LOG_START_CASE,        /* s:testpath */
  G_TEST_LOG_STOP_CASE,         /* d:status d:nforks d:elapsed */
  G_TEST_LOG_MIN_RESULT,        /* s:blurb d:result */
  G_TEST_LOG_MAX_RESULT,        /* s:blurb d:result */
  G_TEST_LOG_MESSAGE,           /* s:blurb */
  G_TEST_LOG_START_SUITE,
  G_TEST_LOG_STOP_SUITE
} GTestLogType;
</ENUM>
<STRUCT>
<NAME>GTestLogMsg</NAME>
typedef struct {
  GTestLogType  log_type;
  guint         n_strings;
  gchar       **strings; /* NULL terminated */
  guint         n_nums;
  long double  *nums;
} GTestLogMsg;
</STRUCT>
<STRUCT>
<NAME>GTestLogBuffer</NAME>
typedef struct {
  /*< private >*/
  GString     *data;
  GSList      *msgs;
} GTestLogBuffer;
</STRUCT>
<FUNCTION>
<NAME>g_test_log_type_name</NAME>
<RETURNS>const char *     </RETURNS>
GTestLogType    log_type
</FUNCTION>
<FUNCTION>
<NAME>g_test_log_buffer_new</NAME>
<RETURNS>GTestLogBuffer * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_log_buffer_free</NAME>
<RETURNS>void             </RETURNS>
GTestLogBuffer *tbuffer
</FUNCTION>
<FUNCTION>
<NAME>g_test_log_buffer_push</NAME>
<RETURNS>void             </RETURNS>
GTestLogBuffer *tbuffer, guint           n_bytes, const guint8   *bytes
</FUNCTION>
<FUNCTION>
<NAME>g_test_log_buffer_pop</NAME>
<RETURNS>GTestLogMsg *    </RETURNS>
GTestLogBuffer *tbuffer
</FUNCTION>
<FUNCTION>
<NAME>g_test_log_msg_free</NAME>
<RETURNS>void             </RETURNS>
GTestLogMsg    *tmsg
</FUNCTION>
<USER_FUNCTION>
<NAME>GTestLogFatalFunc</NAME>
<RETURNS>gboolean </RETURNS>
const gchar    *log_domain,
                                                 GLogLevelFlags  log_level,
                                                 const gchar    *message,
                                                 gpointer        user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_test_log_set_fatal_handler</NAME>
<RETURNS>void</RETURNS>
GTestLogFatalFunc log_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_test_expect_message</NAME>
<RETURNS>void     </RETURNS>
const gchar    *log_domain, GLogLevelFlags  log_level, const gchar    *pattern
</FUNCTION>
<FUNCTION>
<NAME>g_test_assert_expected_messages_internal</NAME>
<RETURNS>void     </RETURNS>
const char     *domain, const char     *file, int             line, const char     *func
</FUNCTION>
<ENUM>
<NAME>GTestFileType</NAME>
typedef enum
{
  G_TEST_DIST,
  G_TEST_BUILT
} GTestFileType;
</ENUM>
<FUNCTION>
<NAME>g_test_build_filename</NAME>
<RETURNS>gchar  * </RETURNS>
GTestFileType   file_type, const gchar    *first_path, ...
</FUNCTION>
<FUNCTION>
<NAME>g_test_get_dir</NAME>
<RETURNS>const gchar  *</RETURNS>
GTestFileType   file_type
</FUNCTION>
<FUNCTION>
<NAME>g_test_get_filename</NAME>
<RETURNS>const gchar  *</RETURNS>
GTestFileType   file_type, const gchar    *first_path, ...
</FUNCTION>
<MACRO>
<NAME>g_test_assert_expected_messages</NAME>
#define g_test_assert_expected_messages() g_test_assert_expected_messages_internal (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC)
</MACRO>
<MACRO>
<NAME>G_THREAD_ERROR</NAME>
#define G_THREAD_ERROR g_thread_error_quark ()
</MACRO>
<FUNCTION>
<NAME>g_thread_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GThreadError</NAME>
typedef enum
{
  G_THREAD_ERROR_AGAIN /* Resource temporarily unavailable */
} GThreadError;
</ENUM>
<USER_FUNCTION>
<NAME>GThreadFunc</NAME>
<RETURNS>gpointer </RETURNS>
gpointer data
</USER_FUNCTION>
<UNION>
<NAME>GMutex</NAME>
union _GMutex
{
  /*< private >*/
  gpointer p;
  guint i[2];
};
</UNION>
<STRUCT>
<NAME>GRWLock</NAME>
struct _GRWLock
{
  /*< private >*/
  gpointer p;
  guint i[2];
};
</STRUCT>
<STRUCT>
<NAME>GCond</NAME>
struct _GCond
{
  /*< private >*/
  gpointer p;
  guint i[2];
};
</STRUCT>
<STRUCT>
<NAME>GRecMutex</NAME>
struct _GRecMutex
{
  /*< private >*/
  gpointer p;
  guint i[2];
};
</STRUCT>
<MACRO>
<NAME>G_PRIVATE_INIT</NAME>
#define G_PRIVATE_INIT(notify) { NULL, (notify), { NULL, NULL } }
</MACRO>
<STRUCT>
<NAME>GPrivate</NAME>
struct _GPrivate
{
  /*< private >*/
  gpointer       p;
  GDestroyNotify notify;
  gpointer future[2];
};
</STRUCT>
<ENUM>
<NAME>GOnceStatus</NAME>
typedef enum
{
  G_ONCE_STATUS_NOTCALLED,
  G_ONCE_STATUS_PROGRESS,
  G_ONCE_STATUS_READY
} GOnceStatus;
</ENUM>
<MACRO>
<NAME>G_ONCE_INIT</NAME>
#define G_ONCE_INIT { G_ONCE_STATUS_NOTCALLED, NULL }
</MACRO>
<STRUCT>
<NAME>GOnce</NAME>
struct _GOnce
{
  volatile GOnceStatus status;
  volatile gpointer retval;
};
</STRUCT>
<MACRO>
<NAME>G_LOCK_NAME</NAME>
#define G_LOCK_NAME(name)             g__ ## name ## _lock
</MACRO>
<MACRO>
<NAME>G_LOCK_DEFINE_STATIC</NAME>
#define G_LOCK_DEFINE_STATIC(name)    static G_LOCK_DEFINE (name)
</MACRO>
<MACRO>
<NAME>G_LOCK_DEFINE</NAME>
#define G_LOCK_DEFINE(name)           GMutex G_LOCK_NAME (name)
</MACRO>
<MACRO>
<NAME>G_LOCK_EXTERN</NAME>
#define G_LOCK_EXTERN(name)           extern GMutex G_LOCK_NAME (name)
</MACRO>
<MACRO>
<NAME>G_LOCK</NAME>
#  define G_LOCK(name)                G_STMT_START{             \
      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                   \
             "file %s: line %d (%s): locking: %s ",             \
             __FILE__,        __LINE__, G_STRFUNC,              \
             #name);                                            \
      g_mutex_lock (&G_LOCK_NAME (name));                       \
   }G_STMT_END
</MACRO>
<MACRO>
<NAME>G_UNLOCK</NAME>
#  define G_UNLOCK(name)              G_STMT_START{             \
      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                   \
             "file %s: line %d (%s): unlocking: %s ",           \
             __FILE__,        __LINE__, G_STRFUNC,              \
             #name);                                            \
     g_mutex_unlock (&G_LOCK_NAME (name));                      \
   }G_STMT_END
</MACRO>
<MACRO>
<NAME>G_TRYLOCK</NAME>
#  define G_TRYLOCK(name)                                       \
      (g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                  \
             "file %s: line %d (%s): try locking: %s ",         \
             __FILE__,        __LINE__, G_STRFUNC,              \
             #name), g_mutex_trylock (&G_LOCK_NAME (name)))
</MACRO>
<FUNCTION>
<NAME>g_thread_ref</NAME>
<RETURNS>GThread  *       </RETURNS>
GThread        *thread
</FUNCTION>
<FUNCTION>
<NAME>g_thread_unref</NAME>
<RETURNS>void             </RETURNS>
GThread        *thread
</FUNCTION>
<FUNCTION>
<NAME>g_thread_new</NAME>
<RETURNS>GThread  *       </RETURNS>
const gchar    *name, GThreadFunc     func, gpointer        data
</FUNCTION>
<FUNCTION>
<NAME>g_thread_try_new</NAME>
<RETURNS>GThread  *       </RETURNS>
const gchar    *name, GThreadFunc     func, gpointer        data, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_self</NAME>
<RETURNS>GThread  *       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_thread_exit</NAME>
<RETURNS>void             </RETURNS>
gpointer        retval
</FUNCTION>
<FUNCTION>
<NAME>g_thread_join</NAME>
<RETURNS>gpointer         </RETURNS>
GThread        *thread
</FUNCTION>
<FUNCTION>
<NAME>g_thread_yield</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_mutex_init</NAME>
<RETURNS>void             </RETURNS>
GMutex         *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_mutex_clear</NAME>
<RETURNS>void             </RETURNS>
GMutex         *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_mutex_lock</NAME>
<RETURNS>void             </RETURNS>
GMutex         *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_mutex_trylock</NAME>
<RETURNS>gboolean         </RETURNS>
GMutex         *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_mutex_unlock</NAME>
<RETURNS>void             </RETURNS>
GMutex         *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_init</NAME>
<RETURNS>void             </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_clear</NAME>
<RETURNS>void             </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_writer_lock</NAME>
<RETURNS>void             </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_writer_trylock</NAME>
<RETURNS>gboolean         </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_writer_unlock</NAME>
<RETURNS>void             </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_reader_lock</NAME>
<RETURNS>void             </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_reader_trylock</NAME>
<RETURNS>gboolean         </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rw_lock_reader_unlock</NAME>
<RETURNS>void             </RETURNS>
GRWLock        *rw_lock
</FUNCTION>
<FUNCTION>
<NAME>g_rec_mutex_init</NAME>
<RETURNS>void             </RETURNS>
GRecMutex      *rec_mutex
</FUNCTION>
<FUNCTION>
<NAME>g_rec_mutex_clear</NAME>
<RETURNS>void             </RETURNS>
GRecMutex      *rec_mutex
</FUNCTION>
<FUNCTION>
<NAME>g_rec_mutex_lock</NAME>
<RETURNS>void             </RETURNS>
GRecMutex      *rec_mutex
</FUNCTION>
<FUNCTION>
<NAME>g_rec_mutex_trylock</NAME>
<RETURNS>gboolean         </RETURNS>
GRecMutex      *rec_mutex
</FUNCTION>
<FUNCTION>
<NAME>g_rec_mutex_unlock</NAME>
<RETURNS>void             </RETURNS>
GRecMutex      *rec_mutex
</FUNCTION>
<FUNCTION>
<NAME>g_cond_init</NAME>
<RETURNS>void             </RETURNS>
GCond          *cond
</FUNCTION>
<FUNCTION>
<NAME>g_cond_clear</NAME>
<RETURNS>void             </RETURNS>
GCond          *cond
</FUNCTION>
<FUNCTION>
<NAME>g_cond_wait</NAME>
<RETURNS>void             </RETURNS>
GCond          *cond, GMutex         *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_cond_signal</NAME>
<RETURNS>void             </RETURNS>
GCond          *cond
</FUNCTION>
<FUNCTION>
<NAME>g_cond_broadcast</NAME>
<RETURNS>void             </RETURNS>
GCond          *cond
</FUNCTION>
<FUNCTION>
<NAME>g_cond_wait_until</NAME>
<RETURNS>gboolean         </RETURNS>
GCond          *cond, GMutex         *mutex, gint64          end_time
</FUNCTION>
<FUNCTION>
<NAME>g_private_get</NAME>
<RETURNS>gpointer         </RETURNS>
GPrivate       *key
</FUNCTION>
<FUNCTION>
<NAME>g_private_set</NAME>
<RETURNS>void             </RETURNS>
GPrivate       *key, gpointer        value
</FUNCTION>
<FUNCTION>
<NAME>g_private_replace</NAME>
<RETURNS>void             </RETURNS>
GPrivate       *key, gpointer        value
</FUNCTION>
<FUNCTION>
<NAME>g_once_impl</NAME>
<RETURNS>gpointer         </RETURNS>
GOnce          *once, GThreadFunc     func, gpointer        arg
</FUNCTION>
<FUNCTION>
<NAME>g_once_init_enter</NAME>
<RETURNS>gboolean         </RETURNS>
volatile void  *location
</FUNCTION>
<FUNCTION>
<NAME>g_once_init_leave</NAME>
<RETURNS>void             </RETURNS>
volatile void  *location, gsize           result
</FUNCTION>
<MACRO>
<NAME>g_once</NAME>
# define g_once(once, func, arg) g_once_impl ((once), (func), (arg))
</MACRO>
<FUNCTION>
<NAME>g_get_num_processors</NAME>
<RETURNS>guint           </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>GMutexLocker</NAME>
typedef void GMutexLocker;
</TYPEDEF>
<FUNCTION>
<NAME>g_mutex_locker_new</NAME>
<RETURNS>GMutexLocker  *</RETURNS>
GMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_mutex_locker_free</NAME>
<RETURNS>void</RETURNS>
GMutexLocker *locker
</FUNCTION>
<STRUCT>
<NAME>GThread</NAME>
</STRUCT>
<STRUCT>
<NAME>GThreadPool</NAME>
struct _GThreadPool
{
  GFunc func;
  gpointer user_data;
  gboolean exclusive;
};
</STRUCT>
<FUNCTION>
<NAME>g_thread_pool_new</NAME>
<RETURNS>GThreadPool  *   </RETURNS>
GFunc            func, gpointer         user_data, gint             max_threads, gboolean         exclusive, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_free</NAME>
<RETURNS>void             </RETURNS>
GThreadPool     *pool, gboolean         immediate, gboolean         wait_
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_push</NAME>
<RETURNS>gboolean         </RETURNS>
GThreadPool     *pool, gpointer         data, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_unprocessed</NAME>
<RETURNS>guint            </RETURNS>
GThreadPool     *pool
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_set_sort_function</NAME>
<RETURNS>void             </RETURNS>
GThreadPool      *pool, GCompareDataFunc  func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_move_to_front</NAME>
<RETURNS>gboolean         </RETURNS>
GThreadPool      *pool, gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_set_max_threads</NAME>
<RETURNS>gboolean         </RETURNS>
GThreadPool     *pool, gint             max_threads, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_max_threads</NAME>
<RETURNS>gint             </RETURNS>
GThreadPool     *pool
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_num_threads</NAME>
<RETURNS>guint            </RETURNS>
GThreadPool     *pool
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_set_max_unused_threads</NAME>
<RETURNS>void             </RETURNS>
gint  max_threads
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_max_unused_threads</NAME>
<RETURNS>gint             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_num_unused_threads</NAME>
<RETURNS>guint            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_stop_unused_threads</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_set_max_idle_time</NAME>
<RETURNS>void             </RETURNS>
guint interval
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_max_idle_time</NAME>
<RETURNS>guint            </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_USEC_PER_SEC</NAME>
#define G_USEC_PER_SEC 1000000
</MACRO>
<FUNCTION>
<NAME>g_timer_new</NAME>
<RETURNS>GTimer *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_timer_destroy</NAME>
<RETURNS>void 	 </RETURNS>
GTimer      *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_start</NAME>
<RETURNS>void 	 </RETURNS>
GTimer      *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_stop</NAME>
<RETURNS>void 	 </RETURNS>
GTimer      *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_reset</NAME>
<RETURNS>void 	 </RETURNS>
GTimer      *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_continue</NAME>
<RETURNS>void 	 </RETURNS>
GTimer      *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_elapsed</NAME>
<RETURNS>gdouble   </RETURNS>
GTimer      *timer, gulong      *microseconds
</FUNCTION>
<FUNCTION>
<NAME>g_usleep</NAME>
<RETURNS>void      </RETURNS>
gulong       microseconds
</FUNCTION>
<FUNCTION>
<NAME>g_time_val_add</NAME>
<RETURNS>void      </RETURNS>
GTimeVal    *time_, glong        microseconds
</FUNCTION>
<FUNCTION>
<NAME>g_time_val_from_iso8601</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *iso_date, GTimeVal    *time_
</FUNCTION>
<FUNCTION>
<NAME>g_time_val_to_iso8601</NAME>
<RETURNS>gchar *   </RETURNS>
GTimeVal    *time_
</FUNCTION>
<STRUCT>
<NAME>GTimer</NAME>
</STRUCT>
<ENUM>
<NAME>GTimeType</NAME>
typedef enum
{
  G_TIME_TYPE_STANDARD,
  G_TIME_TYPE_DAYLIGHT,
  G_TIME_TYPE_UNIVERSAL
} GTimeType;
</ENUM>
<FUNCTION>
<NAME>g_time_zone_new</NAME>
<RETURNS>GTimeZone  *             </RETURNS>
const gchar *identifier
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_new_utc</NAME>
<RETURNS>GTimeZone  *             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_new_local</NAME>
<RETURNS>GTimeZone  *             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_ref</NAME>
<RETURNS>GTimeZone  *             </RETURNS>
GTimeZone   *tz
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_unref</NAME>
<RETURNS>void                     </RETURNS>
GTimeZone   *tz
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_find_interval</NAME>
<RETURNS>gint                     </RETURNS>
GTimeZone   *tz, GTimeType    type, gint64       time_
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_adjust_time</NAME>
<RETURNS>gint                     </RETURNS>
GTimeZone   *tz, GTimeType    type, gint64      *time_
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_get_abbreviation</NAME>
<RETURNS>const gchar  *           </RETURNS>
GTimeZone   *tz, gint         interval
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_get_offset</NAME>
<RETURNS>gint32                   </RETURNS>
GTimeZone   *tz, gint         interval
</FUNCTION>
<FUNCTION>
<NAME>g_time_zone_is_dst</NAME>
<RETURNS>gboolean                 </RETURNS>
GTimeZone   *tz, gint         interval
</FUNCTION>
<STRUCT>
<NAME>GTimeZone</NAME>
</STRUCT>
<STRUCT>
<NAME>GTrashStack</NAME>
struct _GTrashStack
{
  GTrashStack *next;
};
</STRUCT>
<FUNCTION>
<NAME>g_trash_stack_push</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GTrashStack **stack_p, gpointer      data_p
</FUNCTION>
<FUNCTION>
<NAME>g_trash_stack_pop</NAME>
<DEPRECATED/>
<RETURNS>gpointer   </RETURNS>
GTrashStack **stack_p
</FUNCTION>
<FUNCTION>
<NAME>g_trash_stack_peek</NAME>
<DEPRECATED/>
<RETURNS>gpointer   </RETURNS>
GTrashStack **stack_p
</FUNCTION>
<FUNCTION>
<NAME>g_trash_stack_height</NAME>
<DEPRECATED/>
<RETURNS>guint      </RETURNS>
GTrashStack **stack_p
</FUNCTION>
<USER_FUNCTION>
<NAME>GTraverseFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer  key,
                                   gpointer  value,
                                   gpointer  data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_tree_new</NAME>
<RETURNS>GTree *   </RETURNS>
GCompareFunc      key_compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_tree_new_with_data</NAME>
<RETURNS>GTree *   </RETURNS>
GCompareDataFunc  key_compare_func, gpointer          key_compare_data
</FUNCTION>
<FUNCTION>
<NAME>g_tree_new_full</NAME>
<RETURNS>GTree *   </RETURNS>
GCompareDataFunc  key_compare_func, gpointer          key_compare_data, GDestroyNotify    key_destroy_func, GDestroyNotify    value_destroy_func
</FUNCTION>
<FUNCTION>
<NAME>g_tree_ref</NAME>
<RETURNS>GTree *   </RETURNS>
GTree            *tree
</FUNCTION>
<FUNCTION>
<NAME>g_tree_unref</NAME>
<RETURNS>void      </RETURNS>
GTree            *tree
</FUNCTION>
<FUNCTION>
<NAME>g_tree_destroy</NAME>
<RETURNS>void      </RETURNS>
GTree            *tree
</FUNCTION>
<FUNCTION>
<NAME>g_tree_insert</NAME>
<RETURNS>void      </RETURNS>
GTree            *tree, gpointer          key, gpointer          value
</FUNCTION>
<FUNCTION>
<NAME>g_tree_replace</NAME>
<RETURNS>void      </RETURNS>
GTree            *tree, gpointer          key, gpointer          value
</FUNCTION>
<FUNCTION>
<NAME>g_tree_remove</NAME>
<RETURNS>gboolean  </RETURNS>
GTree            *tree, gconstpointer     key
</FUNCTION>
<FUNCTION>
<NAME>g_tree_steal</NAME>
<RETURNS>gboolean  </RETURNS>
GTree            *tree, gconstpointer     key
</FUNCTION>
<FUNCTION>
<NAME>g_tree_lookup</NAME>
<RETURNS>gpointer  </RETURNS>
GTree            *tree, gconstpointer     key
</FUNCTION>
<FUNCTION>
<NAME>g_tree_lookup_extended</NAME>
<RETURNS>gboolean  </RETURNS>
GTree            *tree, gconstpointer     lookup_key, gpointer         *orig_key, gpointer         *value
</FUNCTION>
<FUNCTION>
<NAME>g_tree_foreach</NAME>
<RETURNS>void      </RETURNS>
GTree            *tree, GTraverseFunc	   func, gpointer	   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tree_traverse</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GTree            *tree, GTraverseFunc     traverse_func, GTraverseType     traverse_type, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tree_search</NAME>
<RETURNS>gpointer  </RETURNS>
GTree            *tree, GCompareFunc      search_func, gconstpointer     user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tree_height</NAME>
<RETURNS>gint      </RETURNS>
GTree            *tree
</FUNCTION>
<FUNCTION>
<NAME>g_tree_nnodes</NAME>
<RETURNS>gint      </RETURNS>
GTree            *tree
</FUNCTION>
<STRUCT>
<NAME>GTree</NAME>
</STRUCT>
<TYPEDEF>
<NAME>gchar</NAME>
typedef char   gchar;
</TYPEDEF>
<TYPEDEF>
<NAME>gshort</NAME>
typedef short  gshort;
</TYPEDEF>
<TYPEDEF>
<NAME>glong</NAME>
typedef long   glong;
</TYPEDEF>
<TYPEDEF>
<NAME>gint</NAME>
typedef int    gint;
</TYPEDEF>
<TYPEDEF>
<NAME>gboolean</NAME>
typedef gint   gboolean;
</TYPEDEF>
<TYPEDEF>
<NAME>guchar</NAME>
typedef unsigned char   guchar;
</TYPEDEF>
<TYPEDEF>
<NAME>gushort</NAME>
typedef unsigned short  gushort;
</TYPEDEF>
<TYPEDEF>
<NAME>gulong</NAME>
typedef unsigned long   gulong;
</TYPEDEF>
<TYPEDEF>
<NAME>guint</NAME>
typedef unsigned int    guint;
</TYPEDEF>
<TYPEDEF>
<NAME>gfloat</NAME>
typedef float   gfloat;
</TYPEDEF>
<TYPEDEF>
<NAME>gdouble</NAME>
typedef double  gdouble;
</TYPEDEF>
<MACRO>
<NAME>G_MININT8</NAME>
#define G_MININT8	((gint8) -0x80)
</MACRO>
<MACRO>
<NAME>G_MAXINT8</NAME>
#define G_MAXINT8	((gint8)  0x7f)
</MACRO>
<MACRO>
<NAME>G_MAXUINT8</NAME>
#define G_MAXUINT8	((guint8) 0xff)
</MACRO>
<MACRO>
<NAME>G_MININT16</NAME>
#define G_MININT16	((gint16) -0x8000)
</MACRO>
<MACRO>
<NAME>G_MAXINT16</NAME>
#define G_MAXINT16	((gint16)  0x7fff)
</MACRO>
<MACRO>
<NAME>G_MAXUINT16</NAME>
#define G_MAXUINT16	((guint16) 0xffff)
</MACRO>
<MACRO>
<NAME>G_MININT32</NAME>
#define G_MININT32	((gint32) -0x80000000)
</MACRO>
<MACRO>
<NAME>G_MAXINT32</NAME>
#define G_MAXINT32	((gint32)  0x7fffffff)
</MACRO>
<MACRO>
<NAME>G_MAXUINT32</NAME>
#define G_MAXUINT32	((guint32) 0xffffffff)
</MACRO>
<MACRO>
<NAME>G_MININT64</NAME>
#define G_MININT64	((gint64) G_GINT64_CONSTANT(-0x8000000000000000))
</MACRO>
<MACRO>
<NAME>G_MAXINT64</NAME>
#define G_MAXINT64	G_GINT64_CONSTANT(0x7fffffffffffffff)
</MACRO>
<MACRO>
<NAME>G_MAXUINT64</NAME>
#define G_MAXUINT64	G_GUINT64_CONSTANT(0xffffffffffffffff)
</MACRO>
<TYPEDEF>
<NAME>gpointer</NAME>
typedef void* gpointer;
</TYPEDEF>
<TYPEDEF>
<NAME>gconstpointer</NAME>
typedef const void *gconstpointer;
</TYPEDEF>
<USER_FUNCTION>
<NAME>GCompareFunc</NAME>
<RETURNS>gint </RETURNS>
gconstpointer  a,
                                                 gconstpointer  b
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCompareDataFunc</NAME>
<RETURNS>gint </RETURNS>
gconstpointer  a,
                                                 gconstpointer  b,
						 gpointer       user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GEqualFunc</NAME>
<RETURNS>gboolean </RETURNS>
gconstpointer  a,
                                                 gconstpointer  b
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDestroyNotify</NAME>
<RETURNS>void </RETURNS>
gpointer       data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GFunc</NAME>
<RETURNS>void </RETURNS>
gpointer       data,
                                                 gpointer       user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHashFunc</NAME>
<RETURNS>guint </RETURNS>
gconstpointer  key
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHFunc</NAME>
<RETURNS>void </RETURNS>
gpointer       key,
                                                 gpointer       value,
                                                 gpointer       user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GFreeFunc</NAME>
<RETURNS>void </RETURNS>
gpointer       data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTranslateFunc</NAME>
<RETURNS>const gchar *</RETURNS>
const gchar   *str,
						 gpointer       data
</USER_FUNCTION>
<MACRO>
<NAME>G_E</NAME>
#define G_E     2.7182818284590452353602874713526624977572470937000
</MACRO>
<MACRO>
<NAME>G_LN2</NAME>
#define G_LN2   0.69314718055994530941723212145817656807550013436026
</MACRO>
<MACRO>
<NAME>G_LN10</NAME>
#define G_LN10  2.3025850929940456840179914546843642076011014886288
</MACRO>
<MACRO>
<NAME>G_PI</NAME>
#define G_PI    3.1415926535897932384626433832795028841971693993751
</MACRO>
<MACRO>
<NAME>G_PI_2</NAME>
#define G_PI_2  1.5707963267948966192313216916397514420985846996876
</MACRO>
<MACRO>
<NAME>G_PI_4</NAME>
#define G_PI_4  0.78539816339744830961566084581987572104929234984378
</MACRO>
<MACRO>
<NAME>G_SQRT2</NAME>
#define G_SQRT2 1.4142135623730950488016887242096980785696718753769
</MACRO>
<MACRO>
<NAME>G_LITTLE_ENDIAN</NAME>
#define G_LITTLE_ENDIAN 1234
</MACRO>
<MACRO>
<NAME>G_BIG_ENDIAN</NAME>
#define G_BIG_ENDIAN    4321
</MACRO>
<MACRO>
<NAME>G_PDP_ENDIAN</NAME>
#define G_PDP_ENDIAN    3412		/* unused, need specific PDP check */	
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE_CONSTANT</NAME>
#define GUINT16_SWAP_LE_BE_CONSTANT(val)	((guint16) ( \
    (guint16) ((guint16) (val) >> 8) |	\
    (guint16) ((guint16) (val) << 8)))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE_CONSTANT</NAME>
#define GUINT32_SWAP_LE_BE_CONSTANT(val)	((guint32) ( \
    (((guint32) (val) & (guint32) 0x000000ffU) << 24) | \
    (((guint32) (val) & (guint32) 0x0000ff00U) <<  8) | \
    (((guint32) (val) & (guint32) 0x00ff0000U) >>  8) | \
    (((guint32) (val) & (guint32) 0xff000000U) >> 24)))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE_CONSTANT</NAME>
#define GUINT64_SWAP_LE_BE_CONSTANT(val)	((guint64) ( \
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0x00000000000000ffU)) << 56) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0x000000000000ff00U)) << 40) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0x0000000000ff0000U)) << 24) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0x00000000ff000000U)) <<  8) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0x000000ff00000000U)) >>  8) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0x0000ff0000000000U)) >> 24) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0x00ff000000000000U)) >> 40) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT (0xff00000000000000U)) >> 56)))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE</NAME>
#    define GUINT32_SWAP_LE_BE(val) ((guint32) __builtin_bswap32 ((guint32) (val)))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE</NAME>
#    define GUINT64_SWAP_LE_BE(val) ((guint64) __builtin_bswap64 ((guint64) (val)))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE_IA32</NAME>
#    define GUINT16_SWAP_LE_BE_IA32(val) \
       (G_GNUC_EXTENSION					\
	({ guint16 __v, __x = ((guint16) (val));		\
	   if (__builtin_constant_p (__x))			\
	     __v = GUINT16_SWAP_LE_BE_CONSTANT (__x);		\
	   else							\
	     __asm__ ("rorw $8, %w0"				\
		      : "=r" (__v)				\
		      : "0" (__x)				\
		      : "cc");					\
	    __v; }))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE_IA32</NAME>
#       define GUINT32_SWAP_LE_BE_IA32(val) \
	  (G_GNUC_EXTENSION					\
	   ({ guint32 __v, __x = ((guint32) (val));		\
	      if (__builtin_constant_p (__x))			\
		__v = GUINT32_SWAP_LE_BE_CONSTANT (__x);	\
	      else						\
		__asm__ ("rorw $8, %w0\n\t"			\
			 "rorl $16, %0\n\t"			\
			 "rorw $8, %w0"				\
			 : "=r" (__v)				\
			 : "0" (__x)				\
			 : "cc");				\
	      __v; }))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE_IA32</NAME>
#    define GUINT64_SWAP_LE_BE_IA32(val) \
       (G_GNUC_EXTENSION						\
	({ union { guint64 __ll;					\
		   guint32 __l[2]; } __w, __r;				\
	   __w.__ll = ((guint64) (val));				\
	   if (__builtin_constant_p (__w.__ll))				\
	     __r.__ll = GUINT64_SWAP_LE_BE_CONSTANT (__w.__ll);		\
	   else								\
	     {								\
	       __r.__l[0] = GUINT32_SWAP_LE_BE (__w.__l[1]);		\
	       __r.__l[1] = GUINT32_SWAP_LE_BE (__w.__l[0]);		\
	     }								\
	   __r.__ll; }))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE</NAME>
#    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_IA32 (val))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE_IA64</NAME>
#    define GUINT16_SWAP_LE_BE_IA64(val) \
       (G_GNUC_EXTENSION					\
	({ guint16 __v, __x = ((guint16) (val));		\
	   if (__builtin_constant_p (__x))			\
	     __v = GUINT16_SWAP_LE_BE_CONSTANT (__x);		\
	   else							\
	     __asm__ __volatile__ ("shl %0 = %1, 48 ;;"		\
				   "mux1 %0 = %0, @rev ;;"	\
				    : "=r" (__v)		\
				    : "r" (__x));		\
	    __v; }))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE_IA64</NAME>
#    define GUINT32_SWAP_LE_BE_IA64(val) \
       (G_GNUC_EXTENSION					\
	 ({ guint32 __v, __x = ((guint32) (val));		\
	    if (__builtin_constant_p (__x))			\
	      __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);		\
	    else						\
	     __asm__ __volatile__ ("shl %0 = %1, 32 ;;"		\
				   "mux1 %0 = %0, @rev ;;"	\
				    : "=r" (__v)		\
				    : "r" (__x));		\
	    __v; }))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE_IA64</NAME>
#    define GUINT64_SWAP_LE_BE_IA64(val) \
       (G_GNUC_EXTENSION					\
	({ guint64 __v, __x = ((guint64) (val));		\
	   if (__builtin_constant_p (__x))			\
	     __v = GUINT64_SWAP_LE_BE_CONSTANT (__x);		\
	   else							\
	     __asm__ __volatile__ ("mux1 %0 = %1, @rev ;;"	\
				   : "=r" (__v)			\
				   : "r" (__x));		\
	   __v; }))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE_X86_64</NAME>
#    define GUINT32_SWAP_LE_BE_X86_64(val) \
       (G_GNUC_EXTENSION					\
	 ({ guint32 __v, __x = ((guint32) (val));		\
	    if (__builtin_constant_p (__x))			\
	      __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);		\
	    else						\
	     __asm__ ("bswapl %0"				\
		      : "=r" (__v)				\
		      : "0" (__x));				\
	    __v; }))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE_X86_64</NAME>
#    define GUINT64_SWAP_LE_BE_X86_64(val) \
       (G_GNUC_EXTENSION					\
	({ guint64 __v, __x = ((guint64) (val));		\
	   if (__builtin_constant_p (__x))			\
	     __v = GUINT64_SWAP_LE_BE_CONSTANT (__x);		\
	   else							\
	     __asm__ ("bswapq %0"				\
		      : "=r" (__v)				\
		      : "0" (__x));				\
	   __v; }))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_PDP</NAME>
#define GUINT16_SWAP_LE_PDP(val)	((guint16) (val))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_BE_PDP</NAME>
#define GUINT16_SWAP_BE_PDP(val)	(GUINT16_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_PDP</NAME>
#define GUINT32_SWAP_LE_PDP(val)	((guint32) ( \
    (((guint32) (val) & (guint32) 0x0000ffffU) << 16) | \
    (((guint32) (val) & (guint32) 0xffff0000U) >> 16)))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_BE_PDP</NAME>
#define GUINT32_SWAP_BE_PDP(val)	((guint32) ( \
    (((guint32) (val) & (guint32) 0x00ff00ffU) << 8) | \
    (((guint32) (val) & (guint32) 0xff00ff00U) >> 8)))
</MACRO>
<MACRO>
<NAME>GINT16_FROM_LE</NAME>
#define GINT16_FROM_LE(val)	(GINT16_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT16_FROM_LE</NAME>
#define GUINT16_FROM_LE(val)	(GUINT16_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT16_FROM_BE</NAME>
#define GINT16_FROM_BE(val)	(GINT16_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT16_FROM_BE</NAME>
#define GUINT16_FROM_BE(val)	(GUINT16_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT32_FROM_LE</NAME>
#define GINT32_FROM_LE(val)	(GINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_FROM_LE</NAME>
#define GUINT32_FROM_LE(val)	(GUINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT32_FROM_BE</NAME>
#define GINT32_FROM_BE(val)	(GINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_FROM_BE</NAME>
#define GUINT32_FROM_BE(val)	(GUINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT64_FROM_LE</NAME>
#define GINT64_FROM_LE(val)	(GINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT64_FROM_LE</NAME>
#define GUINT64_FROM_LE(val)	(GUINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT64_FROM_BE</NAME>
#define GINT64_FROM_BE(val)	(GINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT64_FROM_BE</NAME>
#define GUINT64_FROM_BE(val)	(GUINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GLONG_FROM_LE</NAME>
#define GLONG_FROM_LE(val)	(GLONG_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GULONG_FROM_LE</NAME>
#define GULONG_FROM_LE(val)	(GULONG_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GLONG_FROM_BE</NAME>
#define GLONG_FROM_BE(val)	(GLONG_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GULONG_FROM_BE</NAME>
#define GULONG_FROM_BE(val)	(GULONG_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT_FROM_LE</NAME>
#define GINT_FROM_LE(val)	(GINT_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT_FROM_LE</NAME>
#define GUINT_FROM_LE(val)	(GUINT_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT_FROM_BE</NAME>
#define GINT_FROM_BE(val)	(GINT_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT_FROM_BE</NAME>
#define GUINT_FROM_BE(val)	(GUINT_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GSIZE_FROM_LE</NAME>
#define GSIZE_FROM_LE(val)	(GSIZE_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GSSIZE_FROM_LE</NAME>
#define GSSIZE_FROM_LE(val)	(GSSIZE_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GSIZE_FROM_BE</NAME>
#define GSIZE_FROM_BE(val)	(GSIZE_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GSSIZE_FROM_BE</NAME>
#define GSSIZE_FROM_BE(val)	(GSSIZE_TO_BE (val))
</MACRO>
<MACRO>
<NAME>g_ntohl</NAME>
#define g_ntohl(val) (GUINT32_FROM_BE (val))
</MACRO>
<MACRO>
<NAME>g_ntohs</NAME>
#define g_ntohs(val) (GUINT16_FROM_BE (val))
</MACRO>
<MACRO>
<NAME>g_htonl</NAME>
#define g_htonl(val) (GUINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>g_htons</NAME>
#define g_htons(val) (GUINT16_TO_BE (val))
</MACRO>
<MACRO>
<NAME>g_uint_checked_add</NAME>
#define g_uint_checked_add(dest, a, b) \
    _GLIB_CHECKED_ADD_U32(dest, a, b)
</MACRO>
<MACRO>
<NAME>g_uint_checked_mul</NAME>
#define g_uint_checked_mul(dest, a, b) \
    _GLIB_CHECKED_MUL_U32(dest, a, b)
</MACRO>
<MACRO>
<NAME>g_uint64_checked_add</NAME>
#define g_uint64_checked_add(dest, a, b) \
    _GLIB_CHECKED_ADD_U64(dest, a, b)
</MACRO>
<MACRO>
<NAME>g_uint64_checked_mul</NAME>
#define g_uint64_checked_mul(dest, a, b) \
    _GLIB_CHECKED_MUL_U64(dest, a, b)
</MACRO>
<MACRO>
<NAME>g_size_checked_add</NAME>
#define g_size_checked_add(dest, a, b) \
    _GLIB_CHECKED_ADD_U64(dest, a, b)
</MACRO>
<MACRO>
<NAME>g_size_checked_mul</NAME>
#define g_size_checked_mul(dest, a, b) \
    _GLIB_CHECKED_MUL_U64(dest, a, b)
</MACRO>
<MACRO>
<NAME>G_IEEE754_FLOAT_BIAS</NAME>
#define G_IEEE754_FLOAT_BIAS	(127)
</MACRO>
<MACRO>
<NAME>G_IEEE754_DOUBLE_BIAS</NAME>
#define G_IEEE754_DOUBLE_BIAS	(1023)
</MACRO>
<MACRO>
<NAME>G_LOG_2_BASE_10</NAME>
#define G_LOG_2_BASE_10		(0.30102999566398119521)
</MACRO>
<UNION>
<NAME>GFloatIEEE754</NAME>
union _GFloatIEEE754
;union _GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint mantissa_low : 32;
    guint mantissa_high : 20;
    guint biased_exponent : 11;
    guint sign : 1;
  } mpn;
};
</UNION>
<UNION>
<NAME>GDoubleIEEE754</NAME>
union _GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint sign : 1;
    guint biased_exponent : 11;
    guint mantissa_high : 20;
    guint mantissa_low : 32;
  } mpn;
};
</UNION>
<STRUCT>
<NAME>GTimeVal</NAME>
struct _GTimeVal
{
  glong tv_sec;
  glong tv_usec;
};
</STRUCT>
<MACRO>
<NAME>GLIB_VAR</NAME>
#      define GLIB_VAR extern
</MACRO>
<TYPEDEF>
<NAME>gunichar</NAME>
typedef guint32 gunichar;
</TYPEDEF>
<TYPEDEF>
<NAME>gunichar2</NAME>
typedef guint16 gunichar2;
</TYPEDEF>
<ENUM>
<NAME>GUnicodeType</NAME>
typedef enum
{
  G_UNICODE_CONTROL,
  G_UNICODE_FORMAT,
  G_UNICODE_UNASSIGNED,
  G_UNICODE_PRIVATE_USE,
  G_UNICODE_SURROGATE,
  G_UNICODE_LOWERCASE_LETTER,
  G_UNICODE_MODIFIER_LETTER,
  G_UNICODE_OTHER_LETTER,
  G_UNICODE_TITLECASE_LETTER,
  G_UNICODE_UPPERCASE_LETTER,
  G_UNICODE_SPACING_MARK,
  G_UNICODE_ENCLOSING_MARK,
  G_UNICODE_NON_SPACING_MARK,
  G_UNICODE_DECIMAL_NUMBER,
  G_UNICODE_LETTER_NUMBER,
  G_UNICODE_OTHER_NUMBER,
  G_UNICODE_CONNECT_PUNCTUATION,
  G_UNICODE_DASH_PUNCTUATION,
  G_UNICODE_CLOSE_PUNCTUATION,
  G_UNICODE_FINAL_PUNCTUATION,
  G_UNICODE_INITIAL_PUNCTUATION,
  G_UNICODE_OTHER_PUNCTUATION,
  G_UNICODE_OPEN_PUNCTUATION,
  G_UNICODE_CURRENCY_SYMBOL,
  G_UNICODE_MODIFIER_SYMBOL,
  G_UNICODE_MATH_SYMBOL,
  G_UNICODE_OTHER_SYMBOL,
  G_UNICODE_LINE_SEPARATOR,
  G_UNICODE_PARAGRAPH_SEPARATOR,
  G_UNICODE_SPACE_SEPARATOR
} GUnicodeType;
</ENUM>
<MACRO>
<NAME>G_UNICODE_COMBINING_MARK</NAME>
<DEPRECATED/>
#define G_UNICODE_COMBINING_MARK G_UNICODE_SPACING_MARK
</MACRO>
<ENUM>
<NAME>GUnicodeBreakType</NAME>
typedef enum
{
  G_UNICODE_BREAK_MANDATORY,
  G_UNICODE_BREAK_CARRIAGE_RETURN,
  G_UNICODE_BREAK_LINE_FEED,
  G_UNICODE_BREAK_COMBINING_MARK,
  G_UNICODE_BREAK_SURROGATE,
  G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
  G_UNICODE_BREAK_INSEPARABLE,
  G_UNICODE_BREAK_NON_BREAKING_GLUE,
  G_UNICODE_BREAK_CONTINGENT,
  G_UNICODE_BREAK_SPACE,
  G_UNICODE_BREAK_AFTER,
  G_UNICODE_BREAK_BEFORE,
  G_UNICODE_BREAK_BEFORE_AND_AFTER,
  G_UNICODE_BREAK_HYPHEN,
  G_UNICODE_BREAK_NON_STARTER,
  G_UNICODE_BREAK_OPEN_PUNCTUATION,
  G_UNICODE_BREAK_CLOSE_PUNCTUATION,
  G_UNICODE_BREAK_QUOTATION,
  G_UNICODE_BREAK_EXCLAMATION,
  G_UNICODE_BREAK_IDEOGRAPHIC,
  G_UNICODE_BREAK_NUMERIC,
  G_UNICODE_BREAK_INFIX_SEPARATOR,
  G_UNICODE_BREAK_SYMBOL,
  G_UNICODE_BREAK_ALPHABETIC,
  G_UNICODE_BREAK_PREFIX,
  G_UNICODE_BREAK_POSTFIX,
  G_UNICODE_BREAK_COMPLEX_CONTEXT,
  G_UNICODE_BREAK_AMBIGUOUS,
  G_UNICODE_BREAK_UNKNOWN,
  G_UNICODE_BREAK_NEXT_LINE,
  G_UNICODE_BREAK_WORD_JOINER,
  G_UNICODE_BREAK_HANGUL_L_JAMO,
  G_UNICODE_BREAK_HANGUL_V_JAMO,
  G_UNICODE_BREAK_HANGUL_T_JAMO,
  G_UNICODE_BREAK_HANGUL_LV_SYLLABLE,
  G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,
  G_UNICODE_BREAK_CLOSE_PARANTHESIS,
  G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER,
  G_UNICODE_BREAK_HEBREW_LETTER,
  G_UNICODE_BREAK_REGIONAL_INDICATOR,
  G_UNICODE_BREAK_EMOJI_BASE,
  G_UNICODE_BREAK_EMOJI_MODIFIER,
  G_UNICODE_BREAK_ZERO_WIDTH_JOINER
} GUnicodeBreakType;
</ENUM>
<ENUM>
<NAME>GUnicodeScript</NAME>
typedef enum
{                         /* ISO 15924 code */
  G_UNICODE_SCRIPT_INVALID_CODE = -1,
  G_UNICODE_SCRIPT_COMMON       = 0,   /* Zyyy */
  G_UNICODE_SCRIPT_INHERITED,          /* Zinh (Qaai) */
  G_UNICODE_SCRIPT_ARABIC,             /* Arab */
  G_UNICODE_SCRIPT_ARMENIAN,           /* Armn */
  G_UNICODE_SCRIPT_BENGALI,            /* Beng */
  G_UNICODE_SCRIPT_BOPOMOFO,           /* Bopo */
  G_UNICODE_SCRIPT_CHEROKEE,           /* Cher */
  G_UNICODE_SCRIPT_COPTIC,             /* Copt (Qaac) */
  G_UNICODE_SCRIPT_CYRILLIC,           /* Cyrl (Cyrs) */
  G_UNICODE_SCRIPT_DESERET,            /* Dsrt */
  G_UNICODE_SCRIPT_DEVANAGARI,         /* Deva */
  G_UNICODE_SCRIPT_ETHIOPIC,           /* Ethi */
  G_UNICODE_SCRIPT_GEORGIAN,           /* Geor (Geon, Geoa) */
  G_UNICODE_SCRIPT_GOTHIC,             /* Goth */
  G_UNICODE_SCRIPT_GREEK,              /* Grek */
  G_UNICODE_SCRIPT_GUJARATI,           /* Gujr */
  G_UNICODE_SCRIPT_GURMUKHI,           /* Guru */
  G_UNICODE_SCRIPT_HAN,                /* Hani */
  G_UNICODE_SCRIPT_HANGUL,             /* Hang */
  G_UNICODE_SCRIPT_HEBREW,             /* Hebr */
  G_UNICODE_SCRIPT_HIRAGANA,           /* Hira */
  G_UNICODE_SCRIPT_KANNADA,            /* Knda */
  G_UNICODE_SCRIPT_KATAKANA,           /* Kana */
  G_UNICODE_SCRIPT_KHMER,              /* Khmr */
  G_UNICODE_SCRIPT_LAO,                /* Laoo */
  G_UNICODE_SCRIPT_LATIN,              /* Latn (Latf, Latg) */
  G_UNICODE_SCRIPT_MALAYALAM,          /* Mlym */
  G_UNICODE_SCRIPT_MONGOLIAN,          /* Mong */
  G_UNICODE_SCRIPT_MYANMAR,            /* Mymr */
  G_UNICODE_SCRIPT_OGHAM,              /* Ogam */
  G_UNICODE_SCRIPT_OLD_ITALIC,         /* Ital */
  G_UNICODE_SCRIPT_ORIYA,              /* Orya */
  G_UNICODE_SCRIPT_RUNIC,              /* Runr */
  G_UNICODE_SCRIPT_SINHALA,            /* Sinh */
  G_UNICODE_SCRIPT_SYRIAC,             /* Syrc (Syrj, Syrn, Syre) */
  G_UNICODE_SCRIPT_TAMIL,              /* Taml */
  G_UNICODE_SCRIPT_TELUGU,             /* Telu */
  G_UNICODE_SCRIPT_THAANA,             /* Thaa */
  G_UNICODE_SCRIPT_THAI,               /* Thai */
  G_UNICODE_SCRIPT_TIBETAN,            /* Tibt */
  G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL, /* Cans */
  G_UNICODE_SCRIPT_YI,                 /* Yiii */
  G_UNICODE_SCRIPT_TAGALOG,            /* Tglg */
  G_UNICODE_SCRIPT_HANUNOO,            /* Hano */
  G_UNICODE_SCRIPT_BUHID,              /* Buhd */
  G_UNICODE_SCRIPT_TAGBANWA,           /* Tagb */

  /* Unicode-4.0 additions */
  G_UNICODE_SCRIPT_BRAILLE,            /* Brai */
  G_UNICODE_SCRIPT_CYPRIOT,            /* Cprt */
  G_UNICODE_SCRIPT_LIMBU,              /* Limb */
  G_UNICODE_SCRIPT_OSMANYA,            /* Osma */
  G_UNICODE_SCRIPT_SHAVIAN,            /* Shaw */
  G_UNICODE_SCRIPT_LINEAR_B,           /* Linb */
  G_UNICODE_SCRIPT_TAI_LE,             /* Tale */
  G_UNICODE_SCRIPT_UGARITIC,           /* Ugar */

  /* Unicode-4.1 additions */
  G_UNICODE_SCRIPT_NEW_TAI_LUE,        /* Talu */
  G_UNICODE_SCRIPT_BUGINESE,           /* Bugi */
  G_UNICODE_SCRIPT_GLAGOLITIC,         /* Glag */
  G_UNICODE_SCRIPT_TIFINAGH,           /* Tfng */
  G_UNICODE_SCRIPT_SYLOTI_NAGRI,       /* Sylo */
  G_UNICODE_SCRIPT_OLD_PERSIAN,        /* Xpeo */
  G_UNICODE_SCRIPT_KHAROSHTHI,         /* Khar */

  /* Unicode-5.0 additions */
  G_UNICODE_SCRIPT_UNKNOWN,            /* Zzzz */
  G_UNICODE_SCRIPT_BALINESE,           /* Bali */
  G_UNICODE_SCRIPT_CUNEIFORM,          /* Xsux */
  G_UNICODE_SCRIPT_PHOENICIAN,         /* Phnx */
  G_UNICODE_SCRIPT_PHAGS_PA,           /* Phag */
  G_UNICODE_SCRIPT_NKO,                /* Nkoo */

  /* Unicode-5.1 additions */
  G_UNICODE_SCRIPT_KAYAH_LI,           /* Kali */
  G_UNICODE_SCRIPT_LEPCHA,             /* Lepc */
  G_UNICODE_SCRIPT_REJANG,             /* Rjng */
  G_UNICODE_SCRIPT_SUNDANESE,          /* Sund */
  G_UNICODE_SCRIPT_SAURASHTRA,         /* Saur */
  G_UNICODE_SCRIPT_CHAM,               /* Cham */
  G_UNICODE_SCRIPT_OL_CHIKI,           /* Olck */
  G_UNICODE_SCRIPT_VAI,                /* Vaii */
  G_UNICODE_SCRIPT_CARIAN,             /* Cari */
  G_UNICODE_SCRIPT_LYCIAN,             /* Lyci */
  G_UNICODE_SCRIPT_LYDIAN,             /* Lydi */

  /* Unicode-5.2 additions */
  G_UNICODE_SCRIPT_AVESTAN,                /* Avst */
  G_UNICODE_SCRIPT_BAMUM,                  /* Bamu */
  G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS,   /* Egyp */
  G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC,       /* Armi */
  G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI,  /* Phli */
  G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN, /* Prti */
  G_UNICODE_SCRIPT_JAVANESE,               /* Java */
  G_UNICODE_SCRIPT_KAITHI,                 /* Kthi */
  G_UNICODE_SCRIPT_LISU,                   /* Lisu */
  G_UNICODE_SCRIPT_MEETEI_MAYEK,           /* Mtei */
  G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN,      /* Sarb */
  G_UNICODE_SCRIPT_OLD_TURKIC,             /* Orkh */
  G_UNICODE_SCRIPT_SAMARITAN,              /* Samr */
  G_UNICODE_SCRIPT_TAI_THAM,               /* Lana */
  G_UNICODE_SCRIPT_TAI_VIET,               /* Tavt */

  /* Unicode-6.0 additions */
  G_UNICODE_SCRIPT_BATAK,                  /* Batk */
  G_UNICODE_SCRIPT_BRAHMI,                 /* Brah */
  G_UNICODE_SCRIPT_MANDAIC,                /* Mand */

  /* Unicode-6.1 additions */
  G_UNICODE_SCRIPT_CHAKMA,                 /* Cakm */
  G_UNICODE_SCRIPT_MEROITIC_CURSIVE,       /* Merc */
  G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS,   /* Mero */
  G_UNICODE_SCRIPT_MIAO,                   /* Plrd */
  G_UNICODE_SCRIPT_SHARADA,                /* Shrd */
  G_UNICODE_SCRIPT_SORA_SOMPENG,           /* Sora */
  G_UNICODE_SCRIPT_TAKRI,                  /* Takr */

  /* Unicode 7.0 additions */
  G_UNICODE_SCRIPT_BASSA_VAH,              /* Bass */
  G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN,     /* Aghb */
  G_UNICODE_SCRIPT_DUPLOYAN,               /* Dupl */
  G_UNICODE_SCRIPT_ELBASAN,                /* Elba */
  G_UNICODE_SCRIPT_GRANTHA,                /* Gran */
  G_UNICODE_SCRIPT_KHOJKI,                 /* Khoj */
  G_UNICODE_SCRIPT_KHUDAWADI,              /* Sind */
  G_UNICODE_SCRIPT_LINEAR_A,               /* Lina */
  G_UNICODE_SCRIPT_MAHAJANI,               /* Mahj */
  G_UNICODE_SCRIPT_MANICHAEAN,             /* Manu */
  G_UNICODE_SCRIPT_MENDE_KIKAKUI,          /* Mend */
  G_UNICODE_SCRIPT_MODI,                   /* Modi */
  G_UNICODE_SCRIPT_MRO,                    /* Mroo */
  G_UNICODE_SCRIPT_NABATAEAN,              /* Nbat */
  G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN,      /* Narb */
  G_UNICODE_SCRIPT_OLD_PERMIC,             /* Perm */
  G_UNICODE_SCRIPT_PAHAWH_HMONG,           /* Hmng */
  G_UNICODE_SCRIPT_PALMYRENE,              /* Palm */
  G_UNICODE_SCRIPT_PAU_CIN_HAU,            /* Pauc */
  G_UNICODE_SCRIPT_PSALTER_PAHLAVI,        /* Phlp */
  G_UNICODE_SCRIPT_SIDDHAM,                /* Sidd */
  G_UNICODE_SCRIPT_TIRHUTA,                /* Tirh */
  G_UNICODE_SCRIPT_WARANG_CITI,            /* Wara */

  /* Unicode 8.0 additions */
  G_UNICODE_SCRIPT_AHOM,                   /* Ahom */
  G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS,  /* Hluw */
  G_UNICODE_SCRIPT_HATRAN,                 /* Hatr */
  G_UNICODE_SCRIPT_MULTANI,                /* Mult */
  G_UNICODE_SCRIPT_OLD_HUNGARIAN,          /* Hung */
  G_UNICODE_SCRIPT_SIGNWRITING,            /* Sgnw */

  /* Unicode 9.0 additions */
  G_UNICODE_SCRIPT_ADLAM,                  /* Adlm */
  G_UNICODE_SCRIPT_BHAIKSUKI,              /* Bhks */
  G_UNICODE_SCRIPT_MARCHEN,                /* Marc */
  G_UNICODE_SCRIPT_NEWA,                   /* Newa */
  G_UNICODE_SCRIPT_OSAGE,                  /* Osge */
  G_UNICODE_SCRIPT_TANGUT,                 /* Tang */

  /* Unicode 10.0 additions */
  G_UNICODE_SCRIPT_MASARAM_GONDI,          /* Gonm */
  G_UNICODE_SCRIPT_NUSHU,                  /* Nshu */
  G_UNICODE_SCRIPT_SOYOMBO,                /* Soyo */
  G_UNICODE_SCRIPT_ZANABAZAR_SQUARE        /* Zanb */
} GUnicodeScript;
</ENUM>
<FUNCTION>
<NAME>g_unicode_script_to_iso15924</NAME>
<RETURNS>guint32         </RETURNS>
GUnicodeScript script
</FUNCTION>
<FUNCTION>
<NAME>g_unicode_script_from_iso15924</NAME>
<RETURNS>GUnicodeScript  </RETURNS>
guint32        iso15924
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isalnum</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isalpha</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_iscntrl</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isdigit</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isgraph</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_islower</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isprint</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_ispunct</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isspace</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isupper</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isxdigit</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_istitle</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isdefined</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_iswide</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_iswide_cjk</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_iszerowidth</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_ismark</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_toupper</NAME>
<RETURNS>gunichar  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_tolower</NAME>
<RETURNS>gunichar  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_totitle</NAME>
<RETURNS>gunichar  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_digit_value</NAME>
<RETURNS>gint  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_xdigit_value</NAME>
<RETURNS>gint  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_type</NAME>
<RETURNS>GUnicodeType  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_break_type</NAME>
<RETURNS>GUnicodeBreakType  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_combining_class</NAME>
<RETURNS>gint  </RETURNS>
gunichar uc
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_get_mirror_char</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar ch, gunichar *mirrored_ch
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_get_script</NAME>
<RETURNS>GUnicodeScript  </RETURNS>
gunichar ch
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_validate</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar ch
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_compose</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar  a, gunichar  b, gunichar *ch
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_decompose</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar  ch, gunichar *a, gunichar *b
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_fully_decompose</NAME>
<RETURNS>gsize  </RETURNS>
gunichar  ch, gboolean  compat, gunichar *result, gsize     result_len
</FUNCTION>
<MACRO>
<NAME>G_UNICHAR_MAX_DECOMPOSITION_LENGTH</NAME>
#define G_UNICHAR_MAX_DECOMPOSITION_LENGTH 18 /* codepoints */
</MACRO>
<FUNCTION>
<NAME>g_unicode_canonical_ordering</NAME>
<RETURNS>void  </RETURNS>
gunichar *string, gsize     len
</FUNCTION>
<FUNCTION>
<NAME>g_unicode_canonical_decomposition</NAME>
<DEPRECATED/>
<RETURNS>gunichar  *</RETURNS>
gunichar  ch, gsize    *result_len
</FUNCTION>
<VARIABLE>
<NAME>g_utf8_skip</NAME>
extern const gchar * const g_utf8_skip;
</VARIABLE>
<MACRO>
<NAME>g_utf8_next_char</NAME>
#define g_utf8_next_char(p) (char *)((p) + g_utf8_skip[*(const guchar *)(p)])
</MACRO>
<FUNCTION>
<NAME>g_utf8_get_char</NAME>
<RETURNS>gunichar  </RETURNS>
const gchar  *p
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_get_char_validated</NAME>
<RETURNS>gunichar  </RETURNS>
const  gchar *p, gssize        max_len
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_offset_to_pointer</NAME>
<RETURNS>gchar *   </RETURNS>
const gchar *str, glong        offset
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_pointer_to_offset</NAME>
<RETURNS>glong     </RETURNS>
const gchar *str, const gchar *pos
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_prev_char</NAME>
<RETURNS>gchar *   </RETURNS>
const gchar *p
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_find_next_char</NAME>
<RETURNS>gchar *   </RETURNS>
const gchar *p, const gchar *end
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_find_prev_char</NAME>
<RETURNS>gchar *   </RETURNS>
const gchar *str, const gchar *p
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strlen</NAME>
<RETURNS>glong     </RETURNS>
const gchar *p, gssize       max
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_substring</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar *str, glong        start_pos, glong        end_pos
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strncpy</NAME>
<RETURNS>gchar    *</RETURNS>
gchar       *dest, const gchar *src, gsize        n
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strchr</NAME>
<RETURNS>gchar * </RETURNS>
const gchar *p, gssize       len, gunichar     c
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strrchr</NAME>
<RETURNS>gchar * </RETURNS>
const gchar *p, gssize       len, gunichar     c
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strreverse</NAME>
<RETURNS>gchar * </RETURNS>
const gchar *str, gssize len
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_to_utf16</NAME>
<RETURNS>gunichar2  *</RETURNS>
const gchar      *str, glong             len, glong            *items_read, glong            *items_written, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_to_ucs4</NAME>
<RETURNS>gunichar  * </RETURNS>
const gchar      *str, glong             len, glong            *items_read, glong            *items_written, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_to_ucs4_fast</NAME>
<RETURNS>gunichar  * </RETURNS>
const gchar      *str, glong             len, glong            *items_written
</FUNCTION>
<FUNCTION>
<NAME>g_utf16_to_ucs4</NAME>
<RETURNS>gunichar  * </RETURNS>
const gunichar2  *str, glong             len, glong            *items_read, glong            *items_written, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_utf16_to_utf8</NAME>
<RETURNS>gchar *     </RETURNS>
const gunichar2  *str, glong             len, glong            *items_read, glong            *items_written, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_ucs4_to_utf16</NAME>
<RETURNS>gunichar2  *</RETURNS>
const gunichar   *str, glong             len, glong            *items_read, glong            *items_written, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_ucs4_to_utf8</NAME>
<RETURNS>gchar *     </RETURNS>
const gunichar   *str, glong             len, glong            *items_read, glong            *items_written, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_to_utf8</NAME>
<RETURNS>gint       </RETURNS>
gunichar    c, gchar      *outbuf
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_validate</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *str, gssize        max_len, const gchar **end
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strup</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strdown</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_casefold</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<ENUM>
<NAME>GNormalizeMode</NAME>
typedef enum {
  G_NORMALIZE_DEFAULT,
  G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
  G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_ALL,
  G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
  G_NORMALIZE_ALL_COMPOSE,
  G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE
} GNormalizeMode;
</ENUM>
<FUNCTION>
<NAME>g_utf8_normalize</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar   *str, gssize         len, GNormalizeMode mode
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_collate</NAME>
<RETURNS>gint    </RETURNS>
const gchar *str1, const gchar *str2
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_collate_key</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_collate_key_for_filename</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_make_valid</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str, gssize       len
</FUNCTION>
<MACRO>
<NAME>G_URI_RESERVED_CHARS_GENERIC_DELIMITERS</NAME>
#define G_URI_RESERVED_CHARS_GENERIC_DELIMITERS ":/?#[]@"
</MACRO>
<MACRO>
<NAME>G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS</NAME>
#define G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS "!$&'()*+,;="
</MACRO>
<MACRO>
<NAME>G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT</NAME>
#define G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS ":@"
</MACRO>
<MACRO>
<NAME>G_URI_RESERVED_CHARS_ALLOWED_IN_PATH</NAME>
#define G_URI_RESERVED_CHARS_ALLOWED_IN_PATH G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT "/"
</MACRO>
<MACRO>
<NAME>G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO</NAME>
#define G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS ":"
</MACRO>
<FUNCTION>
<NAME>g_uri_unescape_string</NAME>
<RETURNS>char  *   </RETURNS>
const char *escaped_string, const char *illegal_characters
</FUNCTION>
<FUNCTION>
<NAME>g_uri_unescape_segment</NAME>
<RETURNS>char  *   </RETURNS>
const char *escaped_string, const char *escaped_string_end, const char *illegal_characters
</FUNCTION>
<FUNCTION>
<NAME>g_uri_parse_scheme</NAME>
<RETURNS>char  *   </RETURNS>
const char *uri
</FUNCTION>
<FUNCTION>
<NAME>g_uri_escape_string</NAME>
<RETURNS>char  *   </RETURNS>
const char *unescaped, const char *reserved_chars_allowed, gboolean    allow_utf8
</FUNCTION>
<MACRO>
<NAME>G_VA_COPY</NAME>
#    define G_VA_COPY(ap1, ap2)	  (*(ap1) = *(ap2))
</MACRO>
<FUNCTION>
<NAME>g_get_user_name</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_real_name</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_home_dir</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_tmp_dir</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_host_name</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_prgname</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_set_prgname</NAME>
<RETURNS>void                   </RETURNS>
const gchar *prgname
</FUNCTION>
<FUNCTION>
<NAME>g_get_application_name</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_set_application_name</NAME>
<RETURNS>void                   </RETURNS>
const gchar *application_name
</FUNCTION>
<FUNCTION>
<NAME>g_reload_user_special_dirs_cache</NAME>
<RETURNS>void       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_user_data_dir</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_user_config_dir</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_user_cache_dir</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_system_data_dirs</NAME>
<RETURNS>const gchar  * const *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_win32_get_system_data_dirs_for_module</NAME>
<RETURNS>const gchar  * const *</RETURNS>
void (*address_of_function)(void)
</FUNCTION>
<FUNCTION>
<NAME>g_get_system_config_dirs</NAME>
<RETURNS>const gchar  * const *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_user_runtime_dir</NAME>
<RETURNS>const gchar  * </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GUserDirectory</NAME>
typedef enum {
  G_USER_DIRECTORY_DESKTOP,
  G_USER_DIRECTORY_DOCUMENTS,
  G_USER_DIRECTORY_DOWNLOAD,
  G_USER_DIRECTORY_MUSIC,
  G_USER_DIRECTORY_PICTURES,
  G_USER_DIRECTORY_PUBLIC_SHARE,
  G_USER_DIRECTORY_TEMPLATES,
  G_USER_DIRECTORY_VIDEOS,

  G_USER_N_DIRECTORIES
} GUserDirectory;
</ENUM>
<FUNCTION>
<NAME>g_get_user_special_dir</NAME>
<RETURNS>const gchar  * </RETURNS>
GUserDirectory directory
</FUNCTION>
<STRUCT>
<NAME>GDebugKey</NAME>
struct _GDebugKey
{
  const gchar *key;
  guint	       value;
};
</STRUCT>
<FUNCTION>
<NAME>g_parse_debug_string</NAME>
<RETURNS>guint                  </RETURNS>
const gchar     *string, const GDebugKey *keys, guint            nkeys
</FUNCTION>
<FUNCTION>
<NAME>g_snprintf</NAME>
<RETURNS>gint                   </RETURNS>
gchar       *string, gulong       n, gchar const *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_vsnprintf</NAME>
<RETURNS>gint                   </RETURNS>
gchar       *string, gulong       n, gchar const *format, va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_nullify_pointer</NAME>
<RETURNS>void                   </RETURNS>
gpointer    *nullify_location
</FUNCTION>
<ENUM>
<NAME>GFormatSizeFlags</NAME>
typedef enum
{
  G_FORMAT_SIZE_DEFAULT     = 0,
  G_FORMAT_SIZE_LONG_FORMAT = 1 << 0,
  G_FORMAT_SIZE_IEC_UNITS   = 1 << 1,
  G_FORMAT_SIZE_BITS        = 1 << 2
} GFormatSizeFlags;
</ENUM>
<FUNCTION>
<NAME>g_format_size_full</NAME>
<RETURNS>gchar  *</RETURNS>
guint64          size, GFormatSizeFlags flags
</FUNCTION>
<FUNCTION>
<NAME>g_format_size</NAME>
<RETURNS>gchar  *</RETURNS>
guint64          size
</FUNCTION>
<FUNCTION>
<NAME>g_format_size_for_display</NAME>
<DEPRECATED/>
<RETURNS>gchar  *</RETURNS>
goffset size
</FUNCTION>
<USER_FUNCTION>
<NAME>GVoidFunc</NAME>
<DEPRECATED/>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<MACRO>
<NAME>ATEXIT</NAME>
<DEPRECATED/>
#define ATEXIT(proc) g_ATEXIT(proc)
</MACRO>
<FUNCTION>
<NAME>g_atexit</NAME>
<DEPRECATED/>
<RETURNS>void 	</RETURNS>
GVoidFunc    func
</FUNCTION>
<FUNCTION>
<NAME>atexit</NAME>
<DEPRECATED/>
<RETURNS>int  </RETURNS>
void (*)(void)
</FUNCTION>
<FUNCTION>
<NAME>g_find_program_in_path</NAME>
<RETURNS>gchar *  </RETURNS>
const gchar *program
</FUNCTION>
<MACRO>
<NAME>g_bit_nth_lsf</NAME>
#define g_bit_nth_lsf(mask, nth_bit) g_bit_nth_lsf_impl(mask, nth_bit)
</MACRO>
<MACRO>
<NAME>g_bit_nth_msf</NAME>
#define g_bit_nth_msf(mask, nth_bit) g_bit_nth_msf_impl(mask, nth_bit)
</MACRO>
<MACRO>
<NAME>g_bit_storage</NAME>
#define g_bit_storage(number)        g_bit_storage_impl(number)
</MACRO>
<FUNCTION>
<NAME>gint</NAME>
<RETURNS>GLIB_AVAILABLE_IN_ALL</RETURNS>
g_bit_nth_lsf)         (gulong mask, gint   nth_bit
</FUNCTION>
<FUNCTION>
<NAME>guint</NAME>
<RETURNS>GLIB_AVAILABLE_IN_ALL</RETURNS>
g_bit_storage)         (gulong number
</FUNCTION>
<FUNCTION>
<NAME>g_bit_nth_lsf_impl</NAME>
<RETURNS>gint</RETURNS>
gulong mask, gint   nth_bit
</FUNCTION>
<FUNCTION>
<NAME>g_bit_nth_msf_impl</NAME>
<RETURNS>gint</RETURNS>
gulong mask, gint   nth_bit
</FUNCTION>
<FUNCTION>
<NAME>g_bit_storage_impl</NAME>
<RETURNS>guint</RETURNS>
gulong number
</FUNCTION>
<MACRO>
<NAME>g_abort</NAME>
#  define g_abort() abort ()
</MACRO>
<MACRO>
<NAME>G_WIN32_DLLMAIN_FOR_DLL_NAME</NAME>
<DEPRECATED/>
# define G_WIN32_DLLMAIN_FOR_DLL_NAME(static, dll_name)
</MACRO>
<FUNCTION>
<NAME>g_uuid_string_is_valid</NAME>
<RETURNS>gboolean       </RETURNS>
const gchar   *str
</FUNCTION>
<FUNCTION>
<NAME>g_uuid_string_random</NAME>
<RETURNS>gchar  *       </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GVariantClass</NAME>
typedef enum
{
  G_VARIANT_CLASS_BOOLEAN       = 'b',
  G_VARIANT_CLASS_BYTE          = 'y',
  G_VARIANT_CLASS_INT16         = 'n',
  G_VARIANT_CLASS_UINT16        = 'q',
  G_VARIANT_CLASS_INT32         = 'i',
  G_VARIANT_CLASS_UINT32        = 'u',
  G_VARIANT_CLASS_INT64         = 'x',
  G_VARIANT_CLASS_UINT64        = 't',
  G_VARIANT_CLASS_HANDLE        = 'h',
  G_VARIANT_CLASS_DOUBLE        = 'd',
  G_VARIANT_CLASS_STRING        = 's',
  G_VARIANT_CLASS_OBJECT_PATH   = 'o',
  G_VARIANT_CLASS_SIGNATURE     = 'g',
  G_VARIANT_CLASS_VARIANT       = 'v',
  G_VARIANT_CLASS_MAYBE         = 'm',
  G_VARIANT_CLASS_ARRAY         = 'a',
  G_VARIANT_CLASS_TUPLE         = '(',
  G_VARIANT_CLASS_DICT_ENTRY    = '{'
} GVariantClass;
</ENUM>
<FUNCTION>
<NAME>g_variant_unref</NAME>
<RETURNS>void                             </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_ref</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_ref_sink</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_is_floating</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_take_ref</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_type</NAME>
<RETURNS>const GVariantType  *            </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_type_string</NAME>
<RETURNS>const gchar  *                   </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_is_of_type</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariant             *value, const GVariantType   *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_is_container</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_classify</NAME>
<RETURNS>GVariantClass                    </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_boolean</NAME>
<RETURNS>GVariant  *                      </RETURNS>
gboolean              value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_byte</NAME>
<RETURNS>GVariant  *                      </RETURNS>
guchar                value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_int16</NAME>
<RETURNS>GVariant  *                      </RETURNS>
gint16                value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_uint16</NAME>
<RETURNS>GVariant  *                      </RETURNS>
guint16               value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_int32</NAME>
<RETURNS>GVariant  *                      </RETURNS>
gint32                value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_uint32</NAME>
<RETURNS>GVariant  *                      </RETURNS>
guint32               value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_int64</NAME>
<RETURNS>GVariant  *                      </RETURNS>
gint64                value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_uint64</NAME>
<RETURNS>GVariant  *                      </RETURNS>
guint64               value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_handle</NAME>
<RETURNS>GVariant  *                      </RETURNS>
gint32                value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_double</NAME>
<RETURNS>GVariant  *                      </RETURNS>
gdouble               value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_string</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *string
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_take_string</NAME>
<RETURNS>GVariant  *                      </RETURNS>
gchar                *string
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_printf</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_object_path</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *object_path
</FUNCTION>
<FUNCTION>
<NAME>g_variant_is_object_path</NAME>
<RETURNS>gboolean                         </RETURNS>
const gchar          *string
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_signature</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *signature
</FUNCTION>
<FUNCTION>
<NAME>g_variant_is_signature</NAME>
<RETURNS>gboolean                         </RETURNS>
const gchar          *string
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_variant</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_strv</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar * const  *strv, gssize                length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_objv</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar * const  *strv, gssize                length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_bytestring</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *string
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_bytestring_array</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar * const  *strv, gssize                length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_fixed_array</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const GVariantType   *element_type, gconstpointer         elements, gsize                 n_elements, gsize                 element_size
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_boolean</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_byte</NAME>
<RETURNS>guchar                           </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_int16</NAME>
<RETURNS>gint16                           </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_uint16</NAME>
<RETURNS>guint16                          </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_int32</NAME>
<RETURNS>gint32                           </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_uint32</NAME>
<RETURNS>guint32                          </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_int64</NAME>
<RETURNS>gint64                           </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_uint64</NAME>
<RETURNS>guint64                          </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_handle</NAME>
<RETURNS>gint32                           </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_double</NAME>
<RETURNS>gdouble                          </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_variant</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_string</NAME>
<RETURNS>const gchar  *                   </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dup_string</NAME>
<RETURNS>gchar  *                         </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_strv</NAME>
<RETURNS>const gchar  **                  </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dup_strv</NAME>
<RETURNS>gchar  **                        </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_objv</NAME>
<RETURNS>const gchar  **                  </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dup_objv</NAME>
<RETURNS>gchar  **                        </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_bytestring</NAME>
<RETURNS>const gchar  *                   </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dup_bytestring</NAME>
<RETURNS>gchar  *                         </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_bytestring_array</NAME>
<RETURNS>const gchar  **                  </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dup_bytestring_array</NAME>
<RETURNS>gchar  **                        </RETURNS>
GVariant             *value, gsize                *length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_maybe</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const GVariantType   *child_type, GVariant             *child
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_array</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const GVariantType   *child_type, GVariant * const     *children, gsize                 n_children
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_tuple</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant * const     *children, gsize                 n_children
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_dict_entry</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *key, GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_maybe</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_n_children</NAME>
<RETURNS>gsize                            </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_child</NAME>
<RETURNS>void                             </RETURNS>
GVariant             *value, gsize                 index_, const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_child_value</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value, gsize                 index_
</FUNCTION>
<FUNCTION>
<NAME>g_variant_lookup</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariant             *dictionary, const gchar          *key, const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_lookup_value</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *dictionary, const gchar          *key, const GVariantType   *expected_type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_fixed_array</NAME>
<RETURNS>gconstpointer                    </RETURNS>
GVariant             *value, gsize                *n_elements, gsize                 element_size
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_size</NAME>
<RETURNS>gsize                            </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_data</NAME>
<RETURNS>gconstpointer                    </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_data_as_bytes</NAME>
<RETURNS>GBytes  *                        </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_store</NAME>
<RETURNS>void                             </RETURNS>
GVariant             *value, gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>g_variant_print</NAME>
<RETURNS>gchar  *                         </RETURNS>
GVariant             *value, gboolean              type_annotate
</FUNCTION>
<FUNCTION>
<NAME>g_variant_print_string</NAME>
<RETURNS>GString  *                       </RETURNS>
GVariant             *value, GString              *string, gboolean              type_annotate
</FUNCTION>
<FUNCTION>
<NAME>g_variant_hash</NAME>
<RETURNS>guint                            </RETURNS>
gconstpointer         value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_equal</NAME>
<RETURNS>gboolean                         </RETURNS>
gconstpointer         one, gconstpointer         two
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_normal_form</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_is_normal_form</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_byteswap</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_from_bytes</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const GVariantType   *type, GBytes               *bytes, gboolean              trusted
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_from_data</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const GVariantType   *type, gconstpointer         data, gsize                 size, gboolean              trusted, GDestroyNotify        notify, gpointer              user_data
</FUNCTION>
<STRUCT>
<NAME>GVariantIter</NAME>
struct _GVariantIter {
  /*< private >*/
  gsize x[16];
};
</STRUCT>
<FUNCTION>
<NAME>g_variant_iter_new</NAME>
<RETURNS>GVariantIter  *                  </RETURNS>
GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_iter_init</NAME>
<RETURNS>gsize                            </RETURNS>
GVariantIter         *iter, GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_iter_copy</NAME>
<RETURNS>GVariantIter  *                  </RETURNS>
GVariantIter         *iter
</FUNCTION>
<FUNCTION>
<NAME>g_variant_iter_n_children</NAME>
<RETURNS>gsize                            </RETURNS>
GVariantIter         *iter
</FUNCTION>
<FUNCTION>
<NAME>g_variant_iter_free</NAME>
<RETURNS>void                             </RETURNS>
GVariantIter         *iter
</FUNCTION>
<FUNCTION>
<NAME>g_variant_iter_next_value</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariantIter         *iter
</FUNCTION>
<FUNCTION>
<NAME>g_variant_iter_next</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariantIter         *iter, const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_iter_loop</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariantIter         *iter, const gchar          *format_string, ...
</FUNCTION>
<STRUCT>
<NAME>GVariantBuilder</NAME>
struct _GVariantBuilder {
  /*< private >*/
  union
  {
    struct {
      gsize partial_magic;
      const GVariantType *type;
      gsize y[14];
    } s;
    gsize x[16];
  } u;
};
</STRUCT>
<ENUM>
<NAME>GVariantParseError</NAME>
typedef enum
{
  G_VARIANT_PARSE_ERROR_FAILED,
  G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED,
  G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE,
  G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED,
  G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END,
  G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
  G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING,
  G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH,
  G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE,
  G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING,
  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
  G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE,
  G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG,
  G_VARIANT_PARSE_ERROR_TYPE_ERROR,
  G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN,
  G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD,
  G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
  G_VARIANT_PARSE_ERROR_VALUE_EXPECTED
} GVariantParseError;
</ENUM>
<MACRO>
<NAME>G_VARIANT_PARSE_ERROR</NAME>
#define G_VARIANT_PARSE_ERROR (g_variant_parse_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_variant_parser_get_error_quark</NAME>
<DEPRECATED/>
<RETURNS>GQuark                           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_variant_parse_error_quark</NAME>
<RETURNS>GQuark                           </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_VARIANT_BUILDER_INIT</NAME>
#define G_VARIANT_BUILDER_INIT(variant_type) { { { 2942751021u, variant_type, { 0, } } } }
</MACRO>
<FUNCTION>
<NAME>g_variant_builder_new</NAME>
<RETURNS>GVariantBuilder  *               </RETURNS>
const GVariantType   *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_unref</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_ref</NAME>
<RETURNS>GVariantBuilder  *               </RETURNS>
GVariantBuilder      *builder
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_init</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder, const GVariantType   *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_end</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariantBuilder      *builder
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_clear</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_open</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder, const GVariantType   *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_close</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_add_value</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder, GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_add</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder, const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_builder_add_parsed</NAME>
<RETURNS>void                             </RETURNS>
GVariantBuilder      *builder, const gchar          *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get</NAME>
<RETURNS>void                             </RETURNS>
GVariant             *value, const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_va</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *format_string, const gchar         **endptr, va_list              *app
</FUNCTION>
<FUNCTION>
<NAME>g_variant_get_va</NAME>
<RETURNS>void                             </RETURNS>
GVariant             *value, const gchar          *format_string, const gchar         **endptr, va_list              *app
</FUNCTION>
<FUNCTION>
<NAME>g_variant_check_format_string</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariant             *value, const gchar          *format_string, gboolean              copy_only
</FUNCTION>
<FUNCTION>
<NAME>g_variant_parse</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const GVariantType   *type, const gchar          *text, const gchar          *limit, const gchar         **endptr, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_parsed</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_new_parsed_va</NAME>
<RETURNS>GVariant  *                      </RETURNS>
const gchar          *format, va_list              *app
</FUNCTION>
<FUNCTION>
<NAME>g_variant_parse_error_print_context</NAME>
<RETURNS>gchar  *                         </RETURNS>
GError               *error, const gchar          *source_str
</FUNCTION>
<FUNCTION>
<NAME>g_variant_compare</NAME>
<RETURNS>gint                             </RETURNS>
gconstpointer one, gconstpointer two
</FUNCTION>
<STRUCT>
<NAME>GVariantDict</NAME>
struct _GVariantDict {
  /*< private >*/
  union
  {
    struct {
      GVariant *asv;
      gsize partial_magic;
      gsize y[14];
    } s;
    gsize x[16];
  } u;
};
</STRUCT>
<MACRO>
<NAME>G_VARIANT_DICT_INIT</NAME>
#define G_VARIANT_DICT_INIT(asv) { { { asv, 3488698669u, { 0, } } } }
</MACRO>
<FUNCTION>
<NAME>g_variant_dict_new</NAME>
<RETURNS>GVariantDict  *                  </RETURNS>
GVariant             *from_asv
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_init</NAME>
<RETURNS>void                             </RETURNS>
GVariantDict         *dict, GVariant             *from_asv
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_lookup</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariantDict         *dict, const gchar          *key, const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_lookup_value</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariantDict         *dict, const gchar          *key, const GVariantType   *expected_type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_contains</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariantDict         *dict, const gchar          *key
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_insert</NAME>
<RETURNS>void                             </RETURNS>
GVariantDict         *dict, const gchar          *key, const gchar          *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_insert_value</NAME>
<RETURNS>void                             </RETURNS>
GVariantDict         *dict, const gchar          *key, GVariant             *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_remove</NAME>
<RETURNS>gboolean                         </RETURNS>
GVariantDict         *dict, const gchar          *key
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_clear</NAME>
<RETURNS>void                             </RETURNS>
GVariantDict         *dict
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_end</NAME>
<RETURNS>GVariant  *                      </RETURNS>
GVariantDict         *dict
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_ref</NAME>
<RETURNS>GVariantDict  *                  </RETURNS>
GVariantDict         *dict
</FUNCTION>
<FUNCTION>
<NAME>g_variant_dict_unref</NAME>
<RETURNS>void                             </RETURNS>
GVariantDict         *dict
</FUNCTION>
<STRUCT>
<NAME>GVariant</NAME>
</STRUCT>
<MACRO>
<NAME>G_VARIANT_TYPE_BOOLEAN</NAME>
#define G_VARIANT_TYPE_BOOLEAN              ((const GVariantType *) "b")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_BYTE</NAME>
#define G_VARIANT_TYPE_BYTE                 ((const GVariantType *) "y")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_INT16</NAME>
#define G_VARIANT_TYPE_INT16                ((const GVariantType *) "n")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_UINT16</NAME>
#define G_VARIANT_TYPE_UINT16               ((const GVariantType *) "q")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_INT32</NAME>
#define G_VARIANT_TYPE_INT32                ((const GVariantType *) "i")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_UINT32</NAME>
#define G_VARIANT_TYPE_UINT32               ((const GVariantType *) "u")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_INT64</NAME>
#define G_VARIANT_TYPE_INT64                ((const GVariantType *) "x")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_UINT64</NAME>
#define G_VARIANT_TYPE_UINT64               ((const GVariantType *) "t")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_DOUBLE</NAME>
#define G_VARIANT_TYPE_DOUBLE               ((const GVariantType *) "d")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_STRING</NAME>
#define G_VARIANT_TYPE_STRING               ((const GVariantType *) "s")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_OBJECT_PATH</NAME>
#define G_VARIANT_TYPE_OBJECT_PATH          ((const GVariantType *) "o")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_SIGNATURE</NAME>
#define G_VARIANT_TYPE_SIGNATURE            ((const GVariantType *) "g")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_VARIANT</NAME>
#define G_VARIANT_TYPE_VARIANT              ((const GVariantType *) "v")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_HANDLE</NAME>
#define G_VARIANT_TYPE_HANDLE               ((const GVariantType *) "h")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_UNIT</NAME>
#define G_VARIANT_TYPE_UNIT                 ((const GVariantType *) "()")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_ANY</NAME>
#define G_VARIANT_TYPE_ANY                  ((const GVariantType *) "*")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_BASIC</NAME>
#define G_VARIANT_TYPE_BASIC                ((const GVariantType *) "?")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_MAYBE</NAME>
#define G_VARIANT_TYPE_MAYBE                ((const GVariantType *) "m*")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_ARRAY</NAME>
#define G_VARIANT_TYPE_ARRAY                ((const GVariantType *) "a*")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_TUPLE</NAME>
#define G_VARIANT_TYPE_TUPLE                ((const GVariantType *) "r")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_DICT_ENTRY</NAME>
#define G_VARIANT_TYPE_DICT_ENTRY           ((const GVariantType *) "{?*}")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_DICTIONARY</NAME>
#define G_VARIANT_TYPE_DICTIONARY           ((const GVariantType *) "a{?*}")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_STRING_ARRAY</NAME>
#define G_VARIANT_TYPE_STRING_ARRAY         ((const GVariantType *) "as")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_OBJECT_PATH_ARRAY</NAME>
#define G_VARIANT_TYPE_OBJECT_PATH_ARRAY    ((const GVariantType *) "ao")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_BYTESTRING</NAME>
#define G_VARIANT_TYPE_BYTESTRING           ((const GVariantType *) "ay")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_BYTESTRING_ARRAY</NAME>
#define G_VARIANT_TYPE_BYTESTRING_ARRAY     ((const GVariantType *) "aay")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE_VARDICT</NAME>
#define G_VARIANT_TYPE_VARDICT              ((const GVariantType *) "a{sv}")
</MACRO>
<MACRO>
<NAME>G_VARIANT_TYPE</NAME>
# define G_VARIANT_TYPE(type_string)            (g_variant_type_checked_ ((type_string)))
</MACRO>
<FUNCTION>
<NAME>g_variant_type_string_is_valid</NAME>
<RETURNS>gboolean                         </RETURNS>
const gchar         *type_string
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_string_scan</NAME>
<RETURNS>gboolean                         </RETURNS>
const gchar         *string, const gchar         *limit, const gchar        **endptr
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_free</NAME>
<RETURNS>void                             </RETURNS>
GVariantType        *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_copy</NAME>
<RETURNS>GVariantType  *                  </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_new</NAME>
<RETURNS>GVariantType  *                  </RETURNS>
const gchar         *type_string
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_get_string_length</NAME>
<RETURNS>gsize                            </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_peek_string</NAME>
<RETURNS>const gchar  *                   </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_dup_string</NAME>
<RETURNS>gchar  *                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_definite</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_container</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_basic</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_maybe</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_array</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_tuple</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_dict_entry</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_variant</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_hash</NAME>
<RETURNS>guint                            </RETURNS>
gconstpointer        type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_equal</NAME>
<RETURNS>gboolean                         </RETURNS>
gconstpointer        type1, gconstpointer        type2
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_is_subtype_of</NAME>
<RETURNS>gboolean                         </RETURNS>
const GVariantType  *type, const GVariantType  *supertype
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_element</NAME>
<RETURNS>const GVariantType  *            </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_first</NAME>
<RETURNS>const GVariantType  *            </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_next</NAME>
<RETURNS>const GVariantType  *            </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_n_items</NAME>
<RETURNS>gsize                            </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_key</NAME>
<RETURNS>const GVariantType  *            </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_value</NAME>
<RETURNS>const GVariantType  *            </RETURNS>
const GVariantType  *type
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_new_array</NAME>
<RETURNS>GVariantType  *                  </RETURNS>
const GVariantType  *element
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_new_maybe</NAME>
<RETURNS>GVariantType  *                  </RETURNS>
const GVariantType  *element
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_new_tuple</NAME>
<RETURNS>GVariantType  *                  </RETURNS>
const GVariantType * const *items, gint                 length
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_new_dict_entry</NAME>
<RETURNS>GVariantType  *                  </RETURNS>
const GVariantType  *key, const GVariantType  *value
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_checked_</NAME>
<RETURNS>const GVariantType  *            </RETURNS>
const gchar *
</FUNCTION>
<FUNCTION>
<NAME>g_variant_type_string_get_depth_</NAME>
<RETURNS>gsize                            </RETURNS>
const gchar *type_string
</FUNCTION>
<STRUCT>
<NAME>GVariantType</NAME>
</STRUCT>
<VARIABLE>
<NAME>glib_major_version</NAME>
extern const guint glib_major_version;
</VARIABLE>
<VARIABLE>
<NAME>glib_minor_version</NAME>
extern const guint glib_minor_version;
</VARIABLE>
<VARIABLE>
<NAME>glib_micro_version</NAME>
extern const guint glib_micro_version;
</VARIABLE>
<VARIABLE>
<NAME>glib_interface_age</NAME>
extern const guint glib_interface_age;
</VARIABLE>
<VARIABLE>
<NAME>glib_binary_age</NAME>
extern const guint glib_binary_age;
</VARIABLE>
<FUNCTION>
<NAME>glib_check_version</NAME>
<RETURNS>const gchar  * </RETURNS>
guint required_major, guint required_minor, guint required_micro
</FUNCTION>
<MACRO>
<NAME>GLIB_CHECK_VERSION</NAME>
#define GLIB_CHECK_VERSION(major,minor,micro)    \
    (GLIB_MAJOR_VERSION > (major) || \
     (GLIB_MAJOR_VERSION == (major) && GLIB_MINOR_VERSION > (minor)) || \
     (GLIB_MAJOR_VERSION == (major) && GLIB_MINOR_VERSION == (minor) && \
      GLIB_MICRO_VERSION >= (micro)))
</MACRO>
<MACRO>
<NAME>G_ENCODE_VERSION</NAME>
#define G_ENCODE_VERSION(major,minor)   ((major) << 16 | (minor) << 8)
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_26</NAME>
#define GLIB_VERSION_2_26       (G_ENCODE_VERSION (2, 26))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_28</NAME>
#define GLIB_VERSION_2_28       (G_ENCODE_VERSION (2, 28))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_30</NAME>
#define GLIB_VERSION_2_30       (G_ENCODE_VERSION (2, 30))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_32</NAME>
#define GLIB_VERSION_2_32       (G_ENCODE_VERSION (2, 32))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_34</NAME>
#define GLIB_VERSION_2_34       (G_ENCODE_VERSION (2, 34))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_36</NAME>
#define GLIB_VERSION_2_36       (G_ENCODE_VERSION (2, 36))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_38</NAME>
#define GLIB_VERSION_2_38       (G_ENCODE_VERSION (2, 38))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_40</NAME>
#define GLIB_VERSION_2_40       (G_ENCODE_VERSION (2, 40))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_42</NAME>
#define GLIB_VERSION_2_42       (G_ENCODE_VERSION (2, 42))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_44</NAME>
#define GLIB_VERSION_2_44       (G_ENCODE_VERSION (2, 44))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_46</NAME>
#define GLIB_VERSION_2_46       (G_ENCODE_VERSION (2, 46))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_48</NAME>
#define GLIB_VERSION_2_48       (G_ENCODE_VERSION (2, 48))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_50</NAME>
#define GLIB_VERSION_2_50       (G_ENCODE_VERSION (2, 50))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_52</NAME>
#define GLIB_VERSION_2_52       (G_ENCODE_VERSION (2, 52))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_54</NAME>
#define GLIB_VERSION_2_54       (G_ENCODE_VERSION (2, 54))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_2_56</NAME>
#define GLIB_VERSION_2_56       (G_ENCODE_VERSION (2, 56))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_CUR_STABLE</NAME>
#define GLIB_VERSION_CUR_STABLE         (G_ENCODE_VERSION (GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION + 1))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_PREV_STABLE</NAME>
#define GLIB_VERSION_PREV_STABLE        (G_ENCODE_VERSION (GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION - 1))
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_MIN_REQUIRED</NAME>
# define GLIB_VERSION_MIN_REQUIRED      (GLIB_VERSION_CUR_STABLE)
</MACRO>
<MACRO>
<NAME>GLIB_VERSION_MAX_ALLOWED</NAME>
# define GLIB_VERSION_MAX_ALLOWED      (GLIB_VERSION_CUR_STABLE)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_ALL</NAME>
#define GLIB_AVAILABLE_IN_ALL                   _GLIB_EXTERN
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_26</NAME>
# define GLIB_DEPRECATED_IN_2_26                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_26_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_26_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_26</NAME>
# define GLIB_AVAILABLE_IN_2_26                 GLIB_UNAVAILABLE(2, 26)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_28</NAME>
# define GLIB_DEPRECATED_IN_2_28                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_28_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_28_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_28</NAME>
# define GLIB_AVAILABLE_IN_2_28                 GLIB_UNAVAILABLE(2, 28)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_30</NAME>
# define GLIB_DEPRECATED_IN_2_30                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_30_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_30_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_30</NAME>
# define GLIB_AVAILABLE_IN_2_30                 GLIB_UNAVAILABLE(2, 30)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_32</NAME>
# define GLIB_DEPRECATED_IN_2_32                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_32_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_32_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_32</NAME>
# define GLIB_AVAILABLE_IN_2_32                 GLIB_UNAVAILABLE(2, 32)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_34</NAME>
# define GLIB_DEPRECATED_IN_2_34                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_34_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_34_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_34</NAME>
# define GLIB_AVAILABLE_IN_2_34                 GLIB_UNAVAILABLE(2, 34)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_36</NAME>
# define GLIB_DEPRECATED_IN_2_36                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_36_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_36_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_36</NAME>
# define GLIB_AVAILABLE_IN_2_36                 GLIB_UNAVAILABLE(2, 36)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_38</NAME>
# define GLIB_DEPRECATED_IN_2_38                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_38_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_38_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_38</NAME>
# define GLIB_AVAILABLE_IN_2_38                 GLIB_UNAVAILABLE(2, 38)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_40</NAME>
# define GLIB_DEPRECATED_IN_2_40                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_40_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_40_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_40</NAME>
# define GLIB_AVAILABLE_IN_2_40                 GLIB_UNAVAILABLE(2, 40)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_42</NAME>
# define GLIB_DEPRECATED_IN_2_42                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_42_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_42_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_42</NAME>
# define GLIB_AVAILABLE_IN_2_42                 GLIB_UNAVAILABLE(2, 42)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_44</NAME>
# define GLIB_DEPRECATED_IN_2_44                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_44_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_44_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_44</NAME>
# define GLIB_AVAILABLE_IN_2_44                 GLIB_UNAVAILABLE(2, 44)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_46</NAME>
# define GLIB_DEPRECATED_IN_2_46                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_46_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_46_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_46</NAME>
# define GLIB_AVAILABLE_IN_2_46                 GLIB_UNAVAILABLE(2, 46)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_48</NAME>
# define GLIB_DEPRECATED_IN_2_48                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_48_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_48_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_48</NAME>
# define GLIB_AVAILABLE_IN_2_48                 GLIB_UNAVAILABLE(2, 48)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_50</NAME>
# define GLIB_DEPRECATED_IN_2_50                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_50_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_50_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_50</NAME>
# define GLIB_AVAILABLE_IN_2_50                 GLIB_UNAVAILABLE(2, 50)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_52</NAME>
# define GLIB_DEPRECATED_IN_2_52                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_52_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_52_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_52</NAME>
# define GLIB_AVAILABLE_IN_2_52                 GLIB_UNAVAILABLE(2, 52)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_54</NAME>
# define GLIB_DEPRECATED_IN_2_54                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_54_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_54_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_54</NAME>
# define GLIB_AVAILABLE_IN_2_54                 GLIB_UNAVAILABLE(2, 54)
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_56</NAME>
# define GLIB_DEPRECATED_IN_2_56                GLIB_DEPRECATED
</MACRO>
<MACRO>
<NAME>GLIB_DEPRECATED_IN_2_56_FOR</NAME>
# define GLIB_DEPRECATED_IN_2_56_FOR(f)         GLIB_DEPRECATED_FOR(f)
</MACRO>
<MACRO>
<NAME>GLIB_AVAILABLE_IN_2_56</NAME>
# define GLIB_AVAILABLE_IN_2_56                 GLIB_UNAVAILABLE(2, 56)
</MACRO>
<MACRO>
<NAME>MAXPATHLEN</NAME>
#define MAXPATHLEN 1024
</MACRO>
<FUNCTION>
<NAME>g_win32_ftruncate</NAME>
<RETURNS>gint 		</RETURNS>
gint		 f, guint		 size
</FUNCTION>
<FUNCTION>
<NAME>g_win32_getlocale</NAME>
<RETURNS>gchar * 		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_win32_error_message</NAME>
<RETURNS>gchar *          </RETURNS>
gint error
</FUNCTION>
<FUNCTION>
<NAME>g_win32_get_package_installation_directory</NAME>
<DEPRECATED/>
<RETURNS>gchar *          </RETURNS>
const gchar *package, const gchar *dll_name
</FUNCTION>
<FUNCTION>
<NAME>g_win32_get_package_installation_subdirectory</NAME>
<DEPRECATED/>
<RETURNS>gchar *          </RETURNS>
const gchar *package, const gchar *dll_name, const gchar *subdir
</FUNCTION>
<FUNCTION>
<NAME>g_win32_get_package_installation_directory_of_module</NAME>
<RETURNS>gchar *          </RETURNS>
gpointer hmodule
</FUNCTION>
<FUNCTION>
<NAME>g_win32_get_windows_version</NAME>
<DEPRECATED/>
<RETURNS>guint 		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_win32_locale_filename_from_utf8</NAME>
<RETURNS>gchar *          </RETURNS>
const gchar *utf8filename
</FUNCTION>
<FUNCTION>
<NAME>g_win32_get_command_line</NAME>
<RETURNS>gchar  **        </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_WIN32_IS_NT_BASED</NAME>
#define G_WIN32_IS_NT_BASED() TRUE
</MACRO>
<MACRO>
<NAME>G_WIN32_HAVE_WIDECHAR_API</NAME>
#define G_WIN32_HAVE_WIDECHAR_API() TRUE
</MACRO>
<ENUM>
<NAME>GWin32OSType</NAME>
typedef enum
{
  G_WIN32_OS_ANY,
  G_WIN32_OS_WORKSTATION,
  G_WIN32_OS_SERVER,
} GWin32OSType;
</ENUM>
<FUNCTION>
<NAME>g_win32_check_windows_version</NAME>
<RETURNS>gboolean  </RETURNS>
const gint major, const gint minor, const gint spver, const GWin32OSType os_type
</FUNCTION>
<USER_FUNCTION>
<NAME>GCacheNewFunc</NAME>
<DEPRECATED/>
<RETURNS>gpointer </RETURNS>
gpointer       key
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCacheDupFunc</NAME>
<DEPRECATED/>
<RETURNS>gpointer </RETURNS>
gpointer       value
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCacheDestroyFunc</NAME>
<DEPRECATED/>
<RETURNS>void </RETURNS>
gpointer       value
</USER_FUNCTION>
<FUNCTION>
<NAME>g_cache_new</NAME>
<DEPRECATED/>
<RETURNS>GCache *  </RETURNS>
GCacheNewFunc      value_new_func, GCacheDestroyFunc  value_destroy_func, GCacheDupFunc      key_dup_func, GCacheDestroyFunc  key_destroy_func, GHashFunc          hash_key_func, GHashFunc          hash_value_func, GEqualFunc         key_equal_func
</FUNCTION>
<FUNCTION>
<NAME>g_cache_destroy</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GCache            *cache
</FUNCTION>
<FUNCTION>
<NAME>g_cache_insert</NAME>
<DEPRECATED/>
<RETURNS>gpointer  </RETURNS>
GCache            *cache, gpointer           key
</FUNCTION>
<FUNCTION>
<NAME>g_cache_remove</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GCache            *cache, gconstpointer      value
</FUNCTION>
<FUNCTION>
<NAME>g_cache_key_foreach</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GCache            *cache, GHFunc             func, gpointer           user_data
</FUNCTION>
<FUNCTION>
<NAME>g_cache_value_foreach</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GCache            *cache, GHFunc             func, gpointer           user_data
</FUNCTION>
<STRUCT>
<NAME>GCache</NAME>
<DEPRECATED/>
</STRUCT>
<USER_FUNCTION>
<NAME>GCompletionFunc</NAME>
<RETURNS>gchar *</RETURNS>
gpointer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCompletionStrncmpFunc</NAME>
<RETURNS>gint </RETURNS>
const gchar *s1,
                                        const gchar *s2,
                                        gsize        n
</USER_FUNCTION>
<STRUCT>
<NAME>GCompletion</NAME>
struct _GCompletion
{
  GList* items;
  GCompletionFunc func;
 
  gchar* prefix;
  GList* cache;
  GCompletionStrncmpFunc strncmp_func;
};
</STRUCT>
<FUNCTION>
<NAME>g_completion_new</NAME>
<DEPRECATED/>
<RETURNS>GCompletion * </RETURNS>
GCompletionFunc func
</FUNCTION>
<FUNCTION>
<NAME>g_completion_add_items</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GCompletion*    cmp, GList*          items
</FUNCTION>
<FUNCTION>
<NAME>g_completion_remove_items</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GCompletion*    cmp, GList*          items
</FUNCTION>
<FUNCTION>
<NAME>g_completion_clear_items</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GCompletion*    cmp
</FUNCTION>
<FUNCTION>
<NAME>g_completion_complete</NAME>
<DEPRECATED/>
<RETURNS>GList *       </RETURNS>
GCompletion*    cmp, const gchar*    prefix, gchar**         new_prefix
</FUNCTION>
<FUNCTION>
<NAME>g_completion_complete_utf8</NAME>
<DEPRECATED/>
<RETURNS>GList *       </RETURNS>
GCompletion  *cmp, const gchar*    prefix, gchar**         new_prefix
</FUNCTION>
<FUNCTION>
<NAME>g_completion_set_compare</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GCompletion *cmp, GCompletionStrncmpFunc strncmp_func
</FUNCTION>
<FUNCTION>
<NAME>g_completion_free</NAME>
<DEPRECATED/>
<RETURNS>void          </RETURNS>
GCompletion*    cmp
</FUNCTION>
<MACRO>
<NAME>g_main_new</NAME>
<DEPRECATED/>
#define         g_main_new(is_running)  g_main_loop_new (NULL, is_running)
</MACRO>
<MACRO>
<NAME>g_main_run</NAME>
<DEPRECATED/>
#define         g_main_run(loop)        g_main_loop_run(loop)
</MACRO>
<MACRO>
<NAME>g_main_quit</NAME>
<DEPRECATED/>
#define g_main_quit(loop)       g_main_loop_quit(loop)
</MACRO>
<MACRO>
<NAME>g_main_destroy</NAME>
<DEPRECATED/>
#define g_main_destroy(loop)    g_main_loop_unref(loop)
</MACRO>
<MACRO>
<NAME>g_main_is_running</NAME>
<DEPRECATED/>
#define g_main_is_running(loop) g_main_loop_is_running(loop)
</MACRO>
<MACRO>
<NAME>g_main_iteration</NAME>
<DEPRECATED/>
#define g_main_iteration(may_block) g_main_context_iteration (NULL, may_block)
</MACRO>
<MACRO>
<NAME>g_main_pending</NAME>
<DEPRECATED/>
#define g_main_pending()            g_main_context_pending (NULL)
</MACRO>
<MACRO>
<NAME>g_main_set_poll_func</NAME>
<DEPRECATED/>
#define g_main_set_poll_func(func)  g_main_context_set_poll_func (NULL, func)
</MACRO>
<STRUCT>
<NAME>GTuples</NAME>
struct _GTuples
{
  guint len;
};
</STRUCT>
<FUNCTION>
<NAME>g_relation_new</NAME>
<DEPRECATED/>
<RETURNS>GRelation * </RETURNS>
gint         fields
</FUNCTION>
<FUNCTION>
<NAME>g_relation_destroy</NAME>
<DEPRECATED/>
<RETURNS>void        </RETURNS>
GRelation   *relation
</FUNCTION>
<FUNCTION>
<NAME>g_relation_index</NAME>
<DEPRECATED/>
<RETURNS>void        </RETURNS>
GRelation   *relation, gint         field, GHashFunc    hash_func, GEqualFunc   key_equal_func
</FUNCTION>
<FUNCTION>
<NAME>g_relation_insert</NAME>
<DEPRECATED/>
<RETURNS>void        </RETURNS>
GRelation   *relation, ...
</FUNCTION>
<FUNCTION>
<NAME>g_relation_delete</NAME>
<DEPRECATED/>
<RETURNS>gint        </RETURNS>
GRelation   *relation, gconstpointer  key, gint         field
</FUNCTION>
<FUNCTION>
<NAME>g_relation_select</NAME>
<DEPRECATED/>
<RETURNS>GTuples *   </RETURNS>
GRelation   *relation, gconstpointer  key, gint         field
</FUNCTION>
<FUNCTION>
<NAME>g_relation_count</NAME>
<DEPRECATED/>
<RETURNS>gint        </RETURNS>
GRelation   *relation, gconstpointer  key, gint         field
</FUNCTION>
<FUNCTION>
<NAME>g_relation_exists</NAME>
<DEPRECATED/>
<RETURNS>gboolean    </RETURNS>
GRelation   *relation, ...
</FUNCTION>
<FUNCTION>
<NAME>g_relation_print</NAME>
<DEPRECATED/>
<RETURNS>void        </RETURNS>
GRelation   *relation
</FUNCTION>
<FUNCTION>
<NAME>g_tuples_destroy</NAME>
<DEPRECATED/>
<RETURNS>void        </RETURNS>
GTuples     *tuples
</FUNCTION>
<FUNCTION>
<NAME>g_tuples_index</NAME>
<DEPRECATED/>
<RETURNS>gpointer    </RETURNS>
GTuples     *tuples, gint         index_, gint         field
</FUNCTION>
<STRUCT>
<NAME>GRelation</NAME>
</STRUCT>
<ENUM>
<NAME>GThreadPriority</NAME>
<DEPRECATED/>
typedef enum
{
  G_THREAD_PRIORITY_LOW,
  G_THREAD_PRIORITY_NORMAL,
  G_THREAD_PRIORITY_HIGH,
  G_THREAD_PRIORITY_URGENT
} GThreadPriority;
</ENUM>
<STRUCT>
<NAME>GThread</NAME>
struct  _GThread
{
  /*< private >*/
  GThreadFunc func;
  gpointer data;
  gboolean joinable;
  GThreadPriority priority;
};
</STRUCT>
<STRUCT>
<NAME>GThreadFunctions</NAME>
<DEPRECATED/>
struct _GThreadFunctions
{
  GMutex*  (*mutex_new)           (void);
  void     (*mutex_lock)          (GMutex               *mutex);
  gboolean (*mutex_trylock)       (GMutex               *mutex);
  void     (*mutex_unlock)        (GMutex               *mutex);
  void     (*mutex_free)          (GMutex               *mutex);
  GCond*   (*cond_new)            (void);
  void     (*cond_signal)         (GCond                *cond);
  void     (*cond_broadcast)      (GCond                *cond);
  void     (*cond_wait)           (GCond                *cond,
                                   GMutex               *mutex);
  gboolean (*cond_timed_wait)     (GCond                *cond,
                                   GMutex               *mutex,
                                   GTimeVal             *end_time);
  void      (*cond_free)          (GCond                *cond);
  GPrivate* (*private_new)        (GDestroyNotify        destructor);
  gpointer  (*private_get)        (GPrivate             *private_key);
  void      (*private_set)        (GPrivate             *private_key,
                                   gpointer              data);
  void      (*thread_create)      (GThreadFunc           func,
                                   gpointer              data,
                                   gulong                stack_size,
                                   gboolean              joinable,
                                   gboolean              bound,
                                   GThreadPriority       priority,
                                   gpointer              thread,
                                   GError              **error);
  void      (*thread_yield)       (void);
  void      (*thread_join)        (gpointer              thread);
  void      (*thread_exit)        (void);
  void      (*thread_set_priority)(gpointer              thread,
                                   GThreadPriority       priority);
  void      (*thread_self)        (gpointer              thread);
  gboolean  (*thread_equal)       (gpointer              thread1,
                                   gpointer              thread2);
};
</STRUCT>
<VARIABLE>
<NAME>g_thread_functions_for_glib_use</NAME>
<DEPRECATED/>
extern GThreadFunctions       g_thread_functions_for_glib_use;
</VARIABLE>
<VARIABLE>
<NAME>g_thread_use_default_impl</NAME>
<DEPRECATED/>
extern gboolean               g_thread_use_default_impl;
</VARIABLE>
<USER_FUNCTION>
<NAME>g_thread_gettime</NAME>
<DEPRECATED/>
<RETURNS>guint64 </RETURNS>
void
</USER_FUNCTION>
<FUNCTION>
<NAME>g_thread_create</NAME>
<DEPRECATED/>
<RETURNS>GThread  *</RETURNS>
GThreadFunc       func, gpointer          data, gboolean          joinable, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_create_full</NAME>
<DEPRECATED/>
<RETURNS>GThread  *</RETURNS>
GThreadFunc       func, gpointer          data, gulong            stack_size, gboolean          joinable, gboolean          bound, GThreadPriority   priority, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_set_priority</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GThread          *thread, GThreadPriority   priority
</FUNCTION>
<FUNCTION>
<NAME>g_thread_foreach</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GFunc             thread_func, gpointer          user_data
</FUNCTION>
<MACRO>
<NAME>g_static_mutex_get_mutex</NAME>
<DEPRECATED/>
#define g_static_mutex_get_mutex g_static_mutex_get_mutex_impl
</MACRO>
<MACRO>
<NAME>G_STATIC_MUTEX_INIT</NAME>
<DEPRECATED/>
#define G_STATIC_MUTEX_INIT { NULL }
</MACRO>
<MACRO>
<NAME>g_static_mutex_lock</NAME>
<DEPRECATED/>
#define g_static_mutex_lock(mutex) \
    g_mutex_lock (g_static_mutex_get_mutex (mutex))
</MACRO>
<MACRO>
<NAME>g_static_mutex_trylock</NAME>
<DEPRECATED/>
#define g_static_mutex_trylock(mutex) \
    g_mutex_trylock (g_static_mutex_get_mutex (mutex))
</MACRO>
<MACRO>
<NAME>g_static_mutex_unlock</NAME>
<DEPRECATED/>
#define g_static_mutex_unlock(mutex) \
    g_mutex_unlock (g_static_mutex_get_mutex (mutex))
</MACRO>
<FUNCTION>
<NAME>g_static_mutex_init</NAME>
<DEPRECATED/>
<RETURNS>void     </RETURNS>
GStaticMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_mutex_free</NAME>
<DEPRECATED/>
<RETURNS>void     </RETURNS>
GStaticMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_mutex_get_mutex_impl</NAME>
<DEPRECATED/>
<RETURNS>GMutex  *</RETURNS>
GStaticMutex *mutex
</FUNCTION>
<STRUCT>
<NAME>GStaticRecMutex</NAME>
<DEPRECATED/>
struct _GStaticRecMutex
{
  /*< private >*/
  GStaticMutex mutex;
  guint depth;

  /* ABI compat only */
  union {
#ifdef G_OS_WIN32
    void *owner;
#else
    pthread_t owner;
#endif
    gdouble dummy;
  } unused;
};
</STRUCT>
<MACRO>
<NAME>G_STATIC_REC_MUTEX_INIT</NAME>
<DEPRECATED/>
#define G_STATIC_REC_MUTEX_INIT { G_STATIC_MUTEX_INIT }
</MACRO>
<FUNCTION>
<NAME>g_static_rec_mutex_init</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_lock</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_trylock</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_unlock</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_lock_full</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticRecMutex *mutex, guint            depth
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_unlock_full</NAME>
<DEPRECATED/>
<RETURNS>guint     </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_free</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<STRUCT>
<NAME>GStaticRWLock</NAME>
<DEPRECATED/>
struct _GStaticRWLock
{
  /*< private >*/
  GStaticMutex mutex;
  GCond *read_cond;
  GCond *write_cond;
  guint read_counter;
  gboolean have_writer;
  guint want_to_read;
  guint want_to_write;
};
</STRUCT>
<MACRO>
<NAME>G_STATIC_RW_LOCK_INIT</NAME>
<DEPRECATED/>
#define G_STATIC_RW_LOCK_INIT { G_STATIC_MUTEX_INIT, NULL, NULL, 0, FALSE, 0, 0 }
</MACRO>
<FUNCTION>
<NAME>g_static_rw_lock_init</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_reader_lock</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_reader_trylock</NAME>
<DEPRECATED/>
<RETURNS>gboolean   </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_reader_unlock</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_writer_lock</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_writer_trylock</NAME>
<DEPRECATED/>
<RETURNS>gboolean   </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_writer_unlock</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_free</NAME>
<DEPRECATED/>
<RETURNS>void       </RETURNS>
GStaticRWLock *lock
</FUNCTION>
<FUNCTION>
<NAME>g_private_new</NAME>
<DEPRECATED/>
<RETURNS>GPrivate  *      </RETURNS>
GDestroyNotify notify
</FUNCTION>
<STRUCT>
<NAME>GStaticPrivate</NAME>
<DEPRECATED/>
struct _GStaticPrivate
{
  /*< private >*/
  guint index;
};
</STRUCT>
<MACRO>
<NAME>G_STATIC_PRIVATE_INIT</NAME>
<DEPRECATED/>
#define G_STATIC_PRIVATE_INIT { 0 }
</MACRO>
<FUNCTION>
<NAME>g_static_private_init</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticPrivate *private_key
</FUNCTION>
<FUNCTION>
<NAME>g_static_private_get</NAME>
<DEPRECATED/>
<RETURNS>gpointer  </RETURNS>
GStaticPrivate *private_key
</FUNCTION>
<FUNCTION>
<NAME>g_static_private_set</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticPrivate *private_key, gpointer        data, GDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>g_static_private_free</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GStaticPrivate *private_key
</FUNCTION>
<FUNCTION>
<NAME>g_once_init_enter_impl</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
volatile gsize *location
</FUNCTION>
<FUNCTION>
<NAME>g_thread_init</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
gpointer vtable
</FUNCTION>
<FUNCTION>
<NAME>g_thread_init_with_errorcheck_mutexes</NAME>
<DEPRECATED/>
<RETURNS>void     </RETURNS>
gpointer vtable
</FUNCTION>
<FUNCTION>
<NAME>g_thread_get_initialized</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>g_threads_got_initialized</NAME>
<DEPRECATED/>
extern gboolean g_threads_got_initialized;
</VARIABLE>
<MACRO>
<NAME>g_thread_supported</NAME>
<DEPRECATED/>
#define g_thread_supported()     (1)
</MACRO>
<FUNCTION>
<NAME>g_mutex_new</NAME>
<DEPRECATED/>
<RETURNS>GMutex  *        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_mutex_free</NAME>
<DEPRECATED/>
<RETURNS>void             </RETURNS>
GMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_cond_new</NAME>
<DEPRECATED/>
<RETURNS>GCond  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_cond_free</NAME>
<DEPRECATED/>
<RETURNS>void             </RETURNS>
GCond  *cond
</FUNCTION>
<FUNCTION>
<NAME>g_cond_timed_wait</NAME>
<DEPRECATED/>
<RETURNS>gboolean         </RETURNS>
GCond          *cond, GMutex         *mutex, GTimeVal       *timeval
</FUNCTION>
<MACRO>
<NAME>G_MODULE_IMPORT</NAME>
#define	G_MODULE_IMPORT		extern
</MACRO>
<MACRO>
<NAME>G_MODULE_EXPORT</NAME>
#  define	G_MODULE_EXPORT		__declspec(dllexport)
</MACRO>
<ENUM>
<NAME>GModuleFlags</NAME>
typedef enum
{
  G_MODULE_BIND_LAZY	= 1 << 0,
  G_MODULE_BIND_LOCAL	= 1 << 1,
  G_MODULE_BIND_MASK	= 0x03
} GModuleFlags;
</ENUM>
<USER_FUNCTION>
<NAME>GModuleCheckInit</NAME>
<RETURNS>const gchar *</RETURNS>
GModule	*module
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GModuleUnload</NAME>
<RETURNS>void </RETURNS>
GModule	*module
</USER_FUNCTION>
<FUNCTION>
<NAME>g_module_supported</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_module_open</NAME>
<RETURNS>GModule *              </RETURNS>
const gchar  *file_name, GModuleFlags  flags
</FUNCTION>
<FUNCTION>
<NAME>g_module_close</NAME>
<RETURNS>gboolean               </RETURNS>
GModule      *module
</FUNCTION>
<FUNCTION>
<NAME>g_module_make_resident</NAME>
<RETURNS>void                   </RETURNS>
GModule      *module
</FUNCTION>
<FUNCTION>
<NAME>g_module_error</NAME>
<RETURNS>const gchar  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_module_symbol</NAME>
<RETURNS>gboolean               </RETURNS>
GModule      *module, const gchar  *symbol_name, gpointer     *symbol
</FUNCTION>
<FUNCTION>
<NAME>g_module_name</NAME>
<RETURNS>const gchar  *         </RETURNS>
GModule      *module
</FUNCTION>
<FUNCTION>
<NAME>g_module_build_path</NAME>
<RETURNS>gchar *                </RETURNS>
const gchar  *directory, const gchar  *module_name
</FUNCTION>
<STRUCT>
<NAME>GModule</NAME>
</STRUCT>
<MACRO>
<NAME>GLIB_HAVE_ALLOCA_H</NAME>
#define GLIB_HAVE_ALLOCA_H
</MACRO>
<MACRO>
<NAME>GLIB_USING_SYSTEM_PRINTF</NAME>
#define GLIB_USING_SYSTEM_PRINTF
</MACRO>
<MACRO>
<NAME>G_MINFLOAT</NAME>
#define G_MINFLOAT	FLT_MIN
</MACRO>
<MACRO>
<NAME>G_MAXFLOAT</NAME>
#define G_MAXFLOAT	FLT_MAX
</MACRO>
<MACRO>
<NAME>G_MINDOUBLE</NAME>
#define G_MINDOUBLE	DBL_MIN
</MACRO>
<MACRO>
<NAME>G_MAXDOUBLE</NAME>
#define G_MAXDOUBLE	DBL_MAX
</MACRO>
<MACRO>
<NAME>G_MINSHORT</NAME>
#define G_MINSHORT	SHRT_MIN
</MACRO>
<MACRO>
<NAME>G_MAXSHORT</NAME>
#define G_MAXSHORT	SHRT_MAX
</MACRO>
<MACRO>
<NAME>G_MAXUSHORT</NAME>
#define G_MAXUSHORT	USHRT_MAX
</MACRO>
<MACRO>
<NAME>G_MININT</NAME>
#define G_MININT	INT_MIN
</MACRO>
<MACRO>
<NAME>G_MAXINT</NAME>
#define G_MAXINT	INT_MAX
</MACRO>
<MACRO>
<NAME>G_MAXUINT</NAME>
#define G_MAXUINT	UINT_MAX
</MACRO>
<MACRO>
<NAME>G_MINLONG</NAME>
#define G_MINLONG	LONG_MIN
</MACRO>
<MACRO>
<NAME>G_MAXLONG</NAME>
#define G_MAXLONG	LONG_MAX
</MACRO>
<MACRO>
<NAME>G_MAXULONG</NAME>
#define G_MAXULONG	ULONG_MAX
</MACRO>
<TYPEDEF>
<NAME>gint8</NAME>
typedef signed char gint8;
</TYPEDEF>
<TYPEDEF>
<NAME>guint8</NAME>
typedef unsigned char guint8;
</TYPEDEF>
<TYPEDEF>
<NAME>gint16</NAME>
typedef signed short gint16;
</TYPEDEF>
<TYPEDEF>
<NAME>guint16</NAME>
typedef unsigned short guint16;
</TYPEDEF>
<MACRO>
<NAME>G_GINT16_MODIFIER</NAME>
#define G_GINT16_MODIFIER "h"
</MACRO>
<MACRO>
<NAME>G_GINT16_FORMAT</NAME>
#define G_GINT16_FORMAT "hi"
</MACRO>
<MACRO>
<NAME>G_GUINT16_FORMAT</NAME>
#define G_GUINT16_FORMAT "hu"
</MACRO>
<TYPEDEF>
<NAME>gint32</NAME>
typedef signed int gint32;
</TYPEDEF>
<TYPEDEF>
<NAME>guint32</NAME>
typedef unsigned int guint32;
</TYPEDEF>
<MACRO>
<NAME>G_GINT32_MODIFIER</NAME>
#define G_GINT32_MODIFIER ""
</MACRO>
<MACRO>
<NAME>G_GINT32_FORMAT</NAME>
#define G_GINT32_FORMAT "i"
</MACRO>
<MACRO>
<NAME>G_GUINT32_FORMAT</NAME>
#define G_GUINT32_FORMAT "u"
</MACRO>
<MACRO>
<NAME>G_HAVE_GINT64</NAME>
#define G_HAVE_GINT64 1          /* deprecated, always true */
</MACRO>
<TYPEDEF>
<NAME>gint64</NAME>
typedef signed long gint64;
</TYPEDEF>
<TYPEDEF>
<NAME>guint64</NAME>
typedef unsigned long guint64;
</TYPEDEF>
<MACRO>
<NAME>G_GINT64_CONSTANT</NAME>
#define G_GINT64_CONSTANT(val)	(val##L)
</MACRO>
<MACRO>
<NAME>G_GUINT64_CONSTANT</NAME>
#define G_GUINT64_CONSTANT(val)	(val##UL)
</MACRO>
<MACRO>
<NAME>G_GINT64_MODIFIER</NAME>
#define G_GINT64_MODIFIER "l"
</MACRO>
<MACRO>
<NAME>G_GINT64_FORMAT</NAME>
#define G_GINT64_FORMAT "li"
</MACRO>
<MACRO>
<NAME>G_GUINT64_FORMAT</NAME>
#define G_GUINT64_FORMAT "lu"
</MACRO>
<MACRO>
<NAME>GLIB_SIZEOF_VOID_P</NAME>
#define GLIB_SIZEOF_VOID_P 8
</MACRO>
<MACRO>
<NAME>GLIB_SIZEOF_LONG</NAME>
#define GLIB_SIZEOF_LONG   8
</MACRO>
<MACRO>
<NAME>GLIB_SIZEOF_SIZE_T</NAME>
#define GLIB_SIZEOF_SIZE_T 8
</MACRO>
<MACRO>
<NAME>GLIB_SIZEOF_SSIZE_T</NAME>
#define GLIB_SIZEOF_SSIZE_T 8
</MACRO>
<TYPEDEF>
<NAME>gssize</NAME>
typedef signed long gssize;
</TYPEDEF>
<TYPEDEF>
<NAME>gsize</NAME>
typedef unsigned long gsize;
</TYPEDEF>
<MACRO>
<NAME>G_GSIZE_MODIFIER</NAME>
#define G_GSIZE_MODIFIER "l"
</MACRO>
<MACRO>
<NAME>G_GSSIZE_MODIFIER</NAME>
#define G_GSSIZE_MODIFIER "l"
</MACRO>
<MACRO>
<NAME>G_GSIZE_FORMAT</NAME>
#define G_GSIZE_FORMAT "lu"
</MACRO>
<MACRO>
<NAME>G_GSSIZE_FORMAT</NAME>
#define G_GSSIZE_FORMAT "li"
</MACRO>
<MACRO>
<NAME>G_MAXSIZE</NAME>
#define G_MAXSIZE	G_MAXULONG
</MACRO>
<MACRO>
<NAME>G_MINSSIZE</NAME>
#define G_MINSSIZE	G_MINLONG
</MACRO>
<MACRO>
<NAME>G_MAXSSIZE</NAME>
#define G_MAXSSIZE	G_MAXLONG
</MACRO>
<TYPEDEF>
<NAME>goffset</NAME>
typedef gint64 goffset;
</TYPEDEF>
<MACRO>
<NAME>G_MINOFFSET</NAME>
#define G_MINOFFSET	G_MININT64
</MACRO>
<MACRO>
<NAME>G_MAXOFFSET</NAME>
#define G_MAXOFFSET	G_MAXINT64
</MACRO>
<MACRO>
<NAME>G_GOFFSET_MODIFIER</NAME>
#define G_GOFFSET_MODIFIER      G_GINT64_MODIFIER
</MACRO>
<MACRO>
<NAME>G_GOFFSET_FORMAT</NAME>
#define G_GOFFSET_FORMAT        G_GINT64_FORMAT
</MACRO>
<MACRO>
<NAME>G_GOFFSET_CONSTANT</NAME>
#define G_GOFFSET_CONSTANT(val) G_GINT64_CONSTANT(val)
</MACRO>
<MACRO>
<NAME>G_POLLFD_FORMAT</NAME>
#define G_POLLFD_FORMAT "%d"
</MACRO>
<MACRO>
<NAME>GPOINTER_TO_INT</NAME>
#define GPOINTER_TO_INT(p)	((gint)  (glong) (p))
</MACRO>
<MACRO>
<NAME>GPOINTER_TO_UINT</NAME>
#define GPOINTER_TO_UINT(p)	((guint) (gulong) (p))
</MACRO>
<MACRO>
<NAME>GINT_TO_POINTER</NAME>
#define GINT_TO_POINTER(i)	((gpointer) (glong) (i))
</MACRO>
<MACRO>
<NAME>GUINT_TO_POINTER</NAME>
#define GUINT_TO_POINTER(u)	((gpointer) (gulong) (u))
</MACRO>
<TYPEDEF>
<NAME>gintptr</NAME>
typedef signed long gintptr;
</TYPEDEF>
<TYPEDEF>
<NAME>guintptr</NAME>
typedef unsigned long guintptr;
</TYPEDEF>
<MACRO>
<NAME>G_GINTPTR_MODIFIER</NAME>
#define G_GINTPTR_MODIFIER      "l"
</MACRO>
<MACRO>
<NAME>G_GINTPTR_FORMAT</NAME>
#define G_GINTPTR_FORMAT        "li"
</MACRO>
<MACRO>
<NAME>G_GUINTPTR_FORMAT</NAME>
#define G_GUINTPTR_FORMAT       "lu"
</MACRO>
<MACRO>
<NAME>g_ATEXIT</NAME>
<DEPRECATED/>
#define g_ATEXIT(proc)	(atexit (proc))
</MACRO>
<MACRO>
<NAME>g_memmove</NAME>
<DEPRECATED/>
#define g_memmove(dest,src,len) G_STMT_START { memmove ((dest), (src), (len)); } G_STMT_END
</MACRO>
<MACRO>
<NAME>GLIB_MAJOR_VERSION</NAME>
#define GLIB_MAJOR_VERSION 2
</MACRO>
<MACRO>
<NAME>GLIB_MINOR_VERSION</NAME>
#define GLIB_MINOR_VERSION 56
</MACRO>
<MACRO>
<NAME>GLIB_MICRO_VERSION</NAME>
#define GLIB_MICRO_VERSION 4
</MACRO>
<MACRO>
<NAME>G_OS_UNIX</NAME>
#define G_OS_UNIX
</MACRO>
<MACRO>
<NAME>G_VA_COPY</NAME>
#define G_VA_COPY	va_copy
</MACRO>
<MACRO>
<NAME>G_VA_COPY_AS_ARRAY</NAME>
#define G_VA_COPY_AS_ARRAY 1
</MACRO>
<MACRO>
<NAME>G_HAVE_ISO_VARARGS</NAME>
# define G_HAVE_ISO_VARARGS 1
</MACRO>
<MACRO>
<NAME>G_HAVE_GNUC_VARARGS</NAME>
#define G_HAVE_GNUC_VARARGS 1
</MACRO>
<MACRO>
<NAME>G_HAVE_GROWING_STACK</NAME>
#define G_HAVE_GROWING_STACK 0
</MACRO>
<MACRO>
<NAME>G_HAVE_GNUC_VISIBILITY</NAME>
#define G_HAVE_GNUC_VISIBILITY 1
</MACRO>
<MACRO>
<NAME>G_GNUC_INTERNAL</NAME>
#define G_GNUC_INTERNAL __attribute__((visibility("hidden")))
</MACRO>
<MACRO>
<NAME>G_THREADS_ENABLED</NAME>
#define G_THREADS_ENABLED
</MACRO>
<MACRO>
<NAME>G_THREADS_IMPL_POSIX</NAME>
#define G_THREADS_IMPL_POSIX
</MACRO>
<MACRO>
<NAME>G_ATOMIC_LOCK_FREE</NAME>
#define G_ATOMIC_LOCK_FREE
</MACRO>
<MACRO>
<NAME>GINT16_TO_LE</NAME>
#define GINT16_TO_LE(val)	((gint16) (val))
</MACRO>
<MACRO>
<NAME>GUINT16_TO_LE</NAME>
#define GUINT16_TO_LE(val)	((guint16) (val))
</MACRO>
<MACRO>
<NAME>GINT16_TO_BE</NAME>
#define GINT16_TO_BE(val)	((gint16) GUINT16_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT16_TO_BE</NAME>
#define GUINT16_TO_BE(val)	(GUINT16_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GINT32_TO_LE</NAME>
#define GINT32_TO_LE(val)	((gint32) (val))
</MACRO>
<MACRO>
<NAME>GUINT32_TO_LE</NAME>
#define GUINT32_TO_LE(val)	((guint32) (val))
</MACRO>
<MACRO>
<NAME>GINT32_TO_BE</NAME>
#define GINT32_TO_BE(val)	((gint32) GUINT32_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_TO_BE</NAME>
#define GUINT32_TO_BE(val)	(GUINT32_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GINT64_TO_LE</NAME>
#define GINT64_TO_LE(val)	((gint64) (val))
</MACRO>
<MACRO>
<NAME>GUINT64_TO_LE</NAME>
#define GUINT64_TO_LE(val)	((guint64) (val))
</MACRO>
<MACRO>
<NAME>GINT64_TO_BE</NAME>
#define GINT64_TO_BE(val)	((gint64) GUINT64_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT64_TO_BE</NAME>
#define GUINT64_TO_BE(val)	(GUINT64_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GLONG_TO_LE</NAME>
#define GLONG_TO_LE(val)	((glong) GINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GULONG_TO_LE</NAME>
#define GULONG_TO_LE(val)	((gulong) GUINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GLONG_TO_BE</NAME>
#define GLONG_TO_BE(val)	((glong) GINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GULONG_TO_BE</NAME>
#define GULONG_TO_BE(val)	((gulong) GUINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT_TO_LE</NAME>
#define GINT_TO_LE(val)		((gint) GINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT_TO_LE</NAME>
#define GUINT_TO_LE(val)	((guint) GUINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT_TO_BE</NAME>
#define GINT_TO_BE(val)		((gint) GINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT_TO_BE</NAME>
#define GUINT_TO_BE(val)	((guint) GUINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GSIZE_TO_LE</NAME>
#define GSIZE_TO_LE(val)	((gsize) GUINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GSSIZE_TO_LE</NAME>
#define GSSIZE_TO_LE(val)	((gssize) GINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GSIZE_TO_BE</NAME>
#define GSIZE_TO_BE(val)	((gsize) GUINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GSSIZE_TO_BE</NAME>
#define GSSIZE_TO_BE(val)	((gssize) GINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>G_BYTE_ORDER</NAME>
#define G_BYTE_ORDER G_LITTLE_ENDIAN
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLIN</NAME>
#define GLIB_SYSDEF_POLLIN =1
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLOUT</NAME>
#define GLIB_SYSDEF_POLLOUT =4
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLPRI</NAME>
#define GLIB_SYSDEF_POLLPRI =2
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLHUP</NAME>
#define GLIB_SYSDEF_POLLHUP =16
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLERR</NAME>
#define GLIB_SYSDEF_POLLERR =8
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLNVAL</NAME>
#define GLIB_SYSDEF_POLLNVAL =32
</MACRO>
<MACRO>
<NAME>G_MODULE_SUFFIX</NAME>
#define G_MODULE_SUFFIX "so"
</MACRO>
<TYPEDEF>
<NAME>GPid</NAME>
typedef int GPid;
</TYPEDEF>
<MACRO>
<NAME>G_PID_FORMAT</NAME>
#define G_PID_FORMAT "i"
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_AF_UNIX</NAME>
#define GLIB_SYSDEF_AF_UNIX 1
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_AF_INET</NAME>
#define GLIB_SYSDEF_AF_INET 2
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_AF_INET6</NAME>
#define GLIB_SYSDEF_AF_INET6 10
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_MSG_OOB</NAME>
#define GLIB_SYSDEF_MSG_OOB 1
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_MSG_PEEK</NAME>
#define GLIB_SYSDEF_MSG_PEEK 2
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_MSG_DONTROUTE</NAME>
#define GLIB_SYSDEF_MSG_DONTROUTE 4
</MACRO>
<MACRO>
<NAME>G_DIR_SEPARATOR</NAME>
#define G_DIR_SEPARATOR '/'
</MACRO>
<MACRO>
<NAME>G_DIR_SEPARATOR_S</NAME>
#define G_DIR_SEPARATOR_S "/"
</MACRO>
<MACRO>
<NAME>G_SEARCHPATH_SEPARATOR</NAME>
#define G_SEARCHPATH_SEPARATOR ':'
</MACRO>
<MACRO>
<NAME>G_SEARCHPATH_SEPARATOR_S</NAME>
#define G_SEARCHPATH_SEPARATOR_S ":"
</MACRO>