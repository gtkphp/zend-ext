#define GXDP_IS_PROXY_RESOLVER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_PROXY_RESOLVER_SKELETON))
#define GXDP_IS_PROXY_RESOLVER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_PROXY_RESOLVER_SKELETON))
#define GXDP_PROXY_RESOLVER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_PROXY_RESOLVER_SKELETON, GXdpProxyResolverSkeletonClass))
#define GXDP_PROXY_RESOLVER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_PROXY_RESOLVER_SKELETON, GXdpProxyResolverSkeletonClass))
#define GXDP_PROXY_RESOLVER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_PROXY_RESOLVER_SKELETON, GXdpProxyResolverSkeleton))
#define GXDP_TYPE_PROXY_RESOLVER_SKELETON (gxdp_proxy_resolver_skeleton_get_type ())
#define GXDP_IS_PROXY_RESOLVER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_PROXY_RESOLVER_PROXY))
#define GXDP_IS_PROXY_RESOLVER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_PROXY_RESOLVER_PROXY))
#define GXDP_PROXY_RESOLVER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_PROXY_RESOLVER_PROXY, GXdpProxyResolverProxyClass))
#define GXDP_PROXY_RESOLVER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_PROXY_RESOLVER_PROXY, GXdpProxyResolverProxyClass))
#define GXDP_PROXY_RESOLVER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_PROXY_RESOLVER_PROXY, GXdpProxyResolverProxy))
#define GXDP_TYPE_PROXY_RESOLVER_PROXY (gxdp_proxy_resolver_proxy_get_type ())
#define GXDP_PROXY_RESOLVER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_PROXY_RESOLVER, GXdpProxyResolverIface))
#define GXDP_IS_PROXY_RESOLVER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_PROXY_RESOLVER))
#define GXDP_PROXY_RESOLVER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_PROXY_RESOLVER, GXdpProxyResolver))
#define GXDP_TYPE_PROXY_RESOLVER (gxdp_proxy_resolver_get_type ())
#define GXDP_IS_NETWORK_MONITOR_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_NETWORK_MONITOR_SKELETON))
#define GXDP_IS_NETWORK_MONITOR_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_NETWORK_MONITOR_SKELETON))
#define GXDP_NETWORK_MONITOR_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_NETWORK_MONITOR_SKELETON, GXdpNetworkMonitorSkeletonClass))
#define GXDP_NETWORK_MONITOR_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_NETWORK_MONITOR_SKELETON, GXdpNetworkMonitorSkeletonClass))
#define GXDP_NETWORK_MONITOR_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_NETWORK_MONITOR_SKELETON, GXdpNetworkMonitorSkeleton))
#define GXDP_TYPE_NETWORK_MONITOR_SKELETON (gxdp_network_monitor_skeleton_get_type ())
#define GXDP_IS_NETWORK_MONITOR_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_NETWORK_MONITOR_PROXY))
#define GXDP_IS_NETWORK_MONITOR_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_NETWORK_MONITOR_PROXY))
#define GXDP_NETWORK_MONITOR_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_NETWORK_MONITOR_PROXY, GXdpNetworkMonitorProxyClass))
#define GXDP_NETWORK_MONITOR_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_NETWORK_MONITOR_PROXY, GXdpNetworkMonitorProxyClass))
#define GXDP_NETWORK_MONITOR_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_NETWORK_MONITOR_PROXY, GXdpNetworkMonitorProxy))
#define GXDP_TYPE_NETWORK_MONITOR_PROXY (gxdp_network_monitor_proxy_get_type ())
#define GXDP_NETWORK_MONITOR_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_NETWORK_MONITOR, GXdpNetworkMonitorIface))
#define GXDP_IS_NETWORK_MONITOR(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_NETWORK_MONITOR))
#define GXDP_NETWORK_MONITOR(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_NETWORK_MONITOR, GXdpNetworkMonitor))
#define GXDP_TYPE_NETWORK_MONITOR (gxdp_network_monitor_get_type ())
#define GXDP_IS_OPEN_URI_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_OPEN_URI_SKELETON))
#define GXDP_IS_OPEN_URI_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_OPEN_URI_SKELETON))
#define GXDP_OPEN_URI_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_OPEN_URI_SKELETON, GXdpOpenURISkeletonClass))
#define GXDP_OPEN_URI_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_OPEN_URI_SKELETON, GXdpOpenURISkeletonClass))
#define GXDP_OPEN_URI_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_OPEN_URI_SKELETON, GXdpOpenURISkeleton))
#define GXDP_TYPE_OPEN_URI_SKELETON (gxdp_open_uri_skeleton_get_type ())
#define GXDP_IS_OPEN_URI_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_OPEN_URI_PROXY))
#define GXDP_IS_OPEN_URI_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_OPEN_URI_PROXY))
#define GXDP_OPEN_URI_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_OPEN_URI_PROXY, GXdpOpenURIProxyClass))
#define GXDP_OPEN_URI_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_OPEN_URI_PROXY, GXdpOpenURIProxyClass))
#define GXDP_OPEN_URI_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_OPEN_URI_PROXY, GXdpOpenURIProxy))
#define GXDP_TYPE_OPEN_URI_PROXY (gxdp_open_uri_proxy_get_type ())
#define GXDP_OPEN_URI_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_OPEN_URI, GXdpOpenURIIface))
#define GXDP_IS_OPEN_URI(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_OPEN_URI))
#define GXDP_OPEN_URI(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_OPEN_URI, GXdpOpenURI))
#define GXDP_TYPE_OPEN_URI (gxdp_open_uri_get_type ())
#define GXDP_IS_DOCUMENTS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_DOCUMENTS_SKELETON))
#define GXDP_IS_DOCUMENTS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_DOCUMENTS_SKELETON))
#define GXDP_DOCUMENTS_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_DOCUMENTS_SKELETON, GXdpDocumentsSkeletonClass))
#define GXDP_DOCUMENTS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_DOCUMENTS_SKELETON, GXdpDocumentsSkeletonClass))
#define GXDP_DOCUMENTS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_DOCUMENTS_SKELETON, GXdpDocumentsSkeleton))
#define GXDP_TYPE_DOCUMENTS_SKELETON (gxdp_documents_skeleton_get_type ())
#define GXDP_IS_DOCUMENTS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_DOCUMENTS_PROXY))
#define GXDP_IS_DOCUMENTS_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_DOCUMENTS_PROXY))
#define GXDP_DOCUMENTS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_DOCUMENTS_PROXY, GXdpDocumentsProxyClass))
#define GXDP_DOCUMENTS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_DOCUMENTS_PROXY, GXdpDocumentsProxyClass))
#define GXDP_DOCUMENTS_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_DOCUMENTS_PROXY, GXdpDocumentsProxy))
#define GXDP_TYPE_DOCUMENTS_PROXY (gxdp_documents_proxy_get_type ())
#define GXDP_DOCUMENTS_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_DOCUMENTS, GXdpDocumentsIface))
#define GXDP_IS_DOCUMENTS(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_DOCUMENTS))
#define GXDP_DOCUMENTS(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_DOCUMENTS, GXdpDocuments))
#define GXDP_TYPE_DOCUMENTS (gxdp_documents_get_type ())
#define CMSG_SPACE(len) GLIB_ALIGN_TO_SIZEOF (CMSG_LEN (len), struct cmsghdr)
#define GLIB_ALIGN_TO_SIZEOF(len, obj) (((len) + sizeof (obj) - 1) & ~(sizeof (obj) - 1))
#define CMSG_LEN(len) ((size_t)CMSG_DATA((struct cmsghdr *)NULL) + (len))
#define T_SRV 33
#define G_TYPE_SETTINGS_BIND_FLAGS (g_settings_bind_flags_get_type ())
#define G_TYPE_NETWORK_CONNECTIVITY (g_network_connectivity_get_type ())
#define G_TYPE_NOTIFICATION_PRIORITY (g_notification_priority_get_type ())
#define G_TYPE_SUBPROCESS_FLAGS (g_subprocess_flags_get_type ())
#define G_TYPE_TEST_DBUS_FLAGS (g_test_dbus_flags_get_type ())
#define G_TYPE_SOCKET_LISTENER_EVENT (g_socket_listener_event_get_type ())
#define G_TYPE_SOCKET_CLIENT_EVENT (g_socket_client_event_get_type ())
#define G_TYPE_IO_MODULE_SCOPE_FLAGS (g_io_module_scope_flags_get_type ())
#define G_TYPE_TLS_CERTIFICATE_REQUEST_FLAGS (g_tls_certificate_request_flags_get_type ())
#define G_TYPE_TLS_DATABASE_LOOKUP_FLAGS (g_tls_database_lookup_flags_get_type ())
#define G_TYPE_TLS_DATABASE_VERIFY_FLAGS (g_tls_database_verify_flags_get_type ())
#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT_FLAGS (g_dbus_object_manager_client_flags_get_type ())
#define G_TYPE_DBUS_INTERFACE_SKELETON_FLAGS (g_dbus_interface_skeleton_flags_get_type ())
#define G_TYPE_TLS_INTERACTION_RESULT (g_tls_interaction_result_get_type ())
#define G_TYPE_TLS_PASSWORD_FLAGS (g_tls_password_flags_get_type ())
#define G_TYPE_TLS_REHANDSHAKE_MODE (g_tls_rehandshake_mode_get_type ())
#define G_TYPE_TLS_AUTHENTICATION_MODE (g_tls_authentication_mode_get_type ())
#define G_TYPE_TLS_CERTIFICATE_FLAGS (g_tls_certificate_flags_get_type ())
#define G_TYPE_TLS_ERROR (g_tls_error_get_type ())
#define G_TYPE_APPLICATION_FLAGS (g_application_flags_get_type ())
#define G_TYPE_DBUS_MESSAGE_BYTE_ORDER (g_dbus_message_byte_order_get_type ())
#define G_TYPE_CREDENTIALS_TYPE (g_credentials_type_get_type ())
#define G_TYPE_DBUS_SEND_MESSAGE_FLAGS (g_dbus_send_message_flags_get_type ())
#define G_TYPE_DBUS_SIGNAL_FLAGS (g_dbus_signal_flags_get_type ())
#define G_TYPE_DBUS_SERVER_FLAGS (g_dbus_server_flags_get_type ())
#define G_TYPE_DBUS_SUBTREE_FLAGS (g_dbus_subtree_flags_get_type ())
#define G_TYPE_DBUS_PROPERTY_INFO_FLAGS (g_dbus_property_info_flags_get_type ())
#define G_TYPE_DBUS_MESSAGE_HEADER_FIELD (g_dbus_message_header_field_get_type ())
#define G_TYPE_DBUS_MESSAGE_FLAGS (g_dbus_message_flags_get_type ())
#define G_TYPE_DBUS_MESSAGE_TYPE (g_dbus_message_type_get_type ())
#define G_TYPE_DBUS_CALL_FLAGS (g_dbus_call_flags_get_type ())
#define G_TYPE_DBUS_CAPABILITY_FLAGS (g_dbus_capability_flags_get_type ())
#define G_TYPE_DBUS_CONNECTION_FLAGS (g_dbus_connection_flags_get_type ())
#define G_TYPE_DBUS_ERROR (g_dbus_error_get_type ())
#define G_TYPE_DBUS_PROXY_FLAGS (g_dbus_proxy_flags_get_type ())
#define G_TYPE_BUS_NAME_WATCHER_FLAGS (g_bus_name_watcher_flags_get_type ())
#define G_TYPE_BUS_NAME_OWNER_FLAGS (g_bus_name_owner_flags_get_type ())
#define G_TYPE_BUS_TYPE (g_bus_type_get_type ())
#define G_TYPE_UNIX_SOCKET_ADDRESS_TYPE (g_unix_socket_address_type_get_type ())
#define G_TYPE_ZLIB_COMPRESSOR_FORMAT (g_zlib_compressor_format_get_type ())
#define G_TYPE_SOCKET_PROTOCOL (g_socket_protocol_get_type ())
#define G_TYPE_SOCKET_MSG_FLAGS (g_socket_msg_flags_get_type ())
#define G_TYPE_SOCKET_TYPE (g_socket_type_get_type ())
#define G_TYPE_SOCKET_FAMILY (g_socket_family_get_type ())
#define G_TYPE_RESOURCE_LOOKUP_FLAGS (g_resource_lookup_flags_get_type ())
#define G_TYPE_RESOURCE_FLAGS (g_resource_flags_get_type ())
#define G_TYPE_RESOURCE_ERROR (g_resource_error_get_type ())
#define G_TYPE_RESOLVER_RECORD_TYPE (g_resolver_record_type_get_type ())
#define G_TYPE_RESOLVER_ERROR (g_resolver_error_get_type ())
#define G_TYPE_EMBLEM_ORIGIN (g_emblem_origin_get_type ())
#define G_TYPE_IO_STREAM_SPLICE_FLAGS (g_io_stream_splice_flags_get_type ())
#define G_TYPE_OUTPUT_STREAM_SPLICE_FLAGS (g_output_stream_splice_flags_get_type ())
#define G_TYPE_MOUNT_OPERATION_RESULT (g_mount_operation_result_get_type ())
#define G_TYPE_PASSWORD_SAVE (g_password_save_get_type ())
#define G_TYPE_ASK_PASSWORD_FLAGS (g_ask_password_flags_get_type ())
#define G_TYPE_IO_ERROR_ENUM (g_io_error_enum_get_type ())
#define G_TYPE_FILE_MONITOR_EVENT (g_file_monitor_event_get_type ())
#define G_TYPE_FILESYSTEM_PREVIEW_TYPE (g_filesystem_preview_type_get_type ())
#define G_TYPE_FILE_TYPE (g_file_type_get_type ())
#define G_TYPE_FILE_MONITOR_FLAGS (g_file_monitor_flags_get_type ())
#define G_TYPE_FILE_COPY_FLAGS (g_file_copy_flags_get_type ())
#define G_TYPE_DRIVE_START_STOP_TYPE (g_drive_start_stop_type_get_type ())
#define G_TYPE_DRIVE_START_FLAGS (g_drive_start_flags_get_type ())
#define G_TYPE_MOUNT_UNMOUNT_FLAGS (g_mount_unmount_flags_get_type ())
#define G_TYPE_MOUNT_MOUNT_FLAGS (g_mount_mount_flags_get_type ())
#define G_TYPE_FILE_MEASURE_FLAGS (g_file_measure_flags_get_type ())
#define G_TYPE_FILE_CREATE_FLAGS (g_file_create_flags_get_type ())
#define G_TYPE_FILE_QUERY_INFO_FLAGS (g_file_query_info_flags_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_STATUS (g_file_attribute_status_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_INFO_FLAGS (g_file_attribute_info_flags_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_TYPE (g_file_attribute_type_get_type ())
#define G_TYPE_DATA_STREAM_NEWLINE_TYPE (g_data_stream_newline_type_get_type ())
#define G_TYPE_DATA_STREAM_BYTE_ORDER (g_data_stream_byte_order_get_type ())
#define G_TYPE_CONVERTER_RESULT (g_converter_result_get_type ())
#define G_TYPE_CONVERTER_FLAGS (g_converter_flags_get_type ())
#define G_TYPE_APP_INFO_CREATE_FLAGS (g_app_info_create_flags_get_type ())
#define G_ZLIB_DECOMPRESSOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass))
#define G_IS_ZLIB_DECOMPRESSOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_ZLIB_DECOMPRESSOR))
#define G_IS_ZLIB_DECOMPRESSOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_ZLIB_DECOMPRESSOR))
#define G_ZLIB_DECOMPRESSOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass))
#define G_ZLIB_DECOMPRESSOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressor))
#define G_TYPE_ZLIB_DECOMPRESSOR         (g_zlib_decompressor_get_type ())
#define G_ZLIB_COMPRESSOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass))
#define G_IS_ZLIB_COMPRESSOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_ZLIB_COMPRESSOR))
#define G_IS_ZLIB_COMPRESSOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_ZLIB_COMPRESSOR))
#define G_ZLIB_COMPRESSOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass))
#define G_ZLIB_COMPRESSOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressor))
#define G_TYPE_ZLIB_COMPRESSOR         (g_zlib_compressor_get_type ())
#define G_TYPE_WIN32_REGISTRY_VALUE_ITER (g_win32_registry_value_iter_get_type ())
#define G_TYPE_WIN32_REGISTRY_SUBKEY_ITER (g_win32_registry_subkey_iter_get_type ())
#define G_WIN32_REGISTRY_KEY_GET_CLASS(o)    (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_REGISTRY_KEY, GWin32RegistryKeyClass))
#define G_IS_WIN32_REGISTRY_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), G_TYPE_WIN32_REGISTRY_KEY))
#define G_IS_WIN32_REGISTRY_KEY(o)           (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_REGISTRY_KEY))
#define G_WIN32_REGISTRY_KEY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), G_TYPE_WIN32_REGISTRY_KEY, GWin32RegistryKeyClass))
#define G_WIN32_REGISTRY_KEY(o)              (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_REGISTRY_KEY, GWin32RegistryKey))
#define G_TYPE_WIN32_REGISTRY_KEY            (g_win32_registry_key_get_type ())
#define G_WIN32_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_OUTPUT_STREAM, GWin32OutputStreamClass))
#define G_IS_WIN32_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_WIN32_OUTPUT_STREAM))
#define G_IS_WIN32_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_OUTPUT_STREAM))
#define G_WIN32_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_WIN32_OUTPUT_STREAM, GWin32OutputStreamClass))
#define G_WIN32_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_OUTPUT_STREAM, GWin32OutputStream))
#define G_TYPE_WIN32_OUTPUT_STREAM         (g_win32_output_stream_get_type ())
#define G_WIN32_NETWORK_MONITOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_NETWORK_MONITOR, GWin32NetworkMonitorClass))
#define G_IS_WIN32_NETWORK_MONITOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_WIN32_NETWORK_MONITOR))
#define G_IS_WIN32_NETWORK_MONITOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_NETWORK_MONITOR))
#define G_WIN32_NETWORK_MONITOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_WIN32_NETWORK_MONITOR, GWin32NetworkMonitorClass))
#define G_WIN32_NETWORK_MONITOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_NETWORK_MONITOR, GWin32NetworkMonitor))
#define G_TYPE_WIN32_NETWORK_MONITOR         (_g_win32_network_monitor_get_type ())
#define G_WIN32_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_INPUT_STREAM, GWin32InputStreamClass))
#define G_IS_WIN32_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_WIN32_INPUT_STREAM))
#define G_IS_WIN32_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_INPUT_STREAM))
#define G_WIN32_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_WIN32_INPUT_STREAM, GWin32InputStreamClass))
#define G_WIN32_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_INPUT_STREAM, GWin32InputStream))
#define G_TYPE_WIN32_INPUT_STREAM         (g_win32_input_stream_get_type ())
#define G_VOLUME_MONITOR_EXTENSION_POINT_NAME "gio-volume-monitor"
#define G_IS_VOLUME_MONITOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_VOLUME_MONITOR))
#define G_IS_VOLUME_MONITOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_VOLUME_MONITOR))
#define G_VOLUME_MONITOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass))
#define G_VOLUME_MONITOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass))
#define G_VOLUME_MONITOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_VOLUME_MONITOR, GVolumeMonitor))
#define G_TYPE_VOLUME_MONITOR         (g_volume_monitor_get_type ())
#define G_VOLUME_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_VOLUME, GVolumeIface))
#define G_IS_VOLUME(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_VOLUME))
#define G_VOLUME(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_VOLUME, GVolume))
#define G_TYPE_VOLUME            (g_volume_get_type ())
#define G_VOLUME_IDENTIFIER_KIND_CLASS "class"
#define G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT "nfs-mount"
#define G_VOLUME_IDENTIFIER_KIND_UUID "uuid"
#define G_VOLUME_IDENTIFIER_KIND_LABEL "label"
#define G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE "unix-device"
#define G_VOLUME_IDENTIFIER_KIND_HAL_UDI "hal-udi"
#define G_VFS_EXTENSION_POINT_NAME "gio-vfs"
#define G_IS_VFS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_VFS))
#define G_IS_VFS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_VFS))
#define G_VFS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_VFS, GVfsClass))
#define G_VFS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_VFS, GVfsClass))
#define G_VFS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_VFS, GVfs))
#define G_TYPE_VFS         (g_vfs_get_type ())
#define G_UNIX_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
#define G_IS_UNIX_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_SOCKET_ADDRESS))
#define G_IS_UNIX_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_SOCKET_ADDRESS))
#define G_UNIX_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
#define G_UNIX_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress))
#define G_TYPE_UNIX_SOCKET_ADDRESS         (g_unix_socket_address_get_type ())
#define G_UNIX_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStreamClass))
#define G_IS_UNIX_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_OUTPUT_STREAM))
#define G_IS_UNIX_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_OUTPUT_STREAM))
#define G_UNIX_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStreamClass))
#define G_UNIX_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStream))
#define G_TYPE_UNIX_OUTPUT_STREAM         (g_unix_output_stream_get_type ())
#define G_IS_UNIX_MOUNT_MONITOR_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_MOUNT_MONITOR))
#define G_IS_UNIX_MOUNT_MONITOR(o)       (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_MOUNT_MONITOR))
#define G_UNIX_MOUNT_MONITOR_CLASS(k)    (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_MOUNT_MONITOR, GUnixMountMonitorClass))
#define G_UNIX_MOUNT_MONITOR(o)          (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_MOUNT_MONITOR, GUnixMountMonitor))
#define G_TYPE_UNIX_MOUNT_MONITOR        (g_unix_mount_monitor_get_type ())
#define G_TYPE_UNIX_MOUNT_POINT (g_unix_mount_point_get_type ())
#define G_TYPE_UNIX_MOUNT_ENTRY (g_unix_mount_entry_get_type ())
#define G_UNIX_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStreamClass))
#define G_IS_UNIX_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_INPUT_STREAM))
#define G_IS_UNIX_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_INPUT_STREAM))
#define G_UNIX_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStreamClass))
#define G_UNIX_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStream))
#define G_TYPE_UNIX_INPUT_STREAM         (g_unix_input_stream_get_type ())
#define G_UNIX_FD_MESSAGE_GET_CLASS(inst)                   (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessageClass))
#define G_IS_UNIX_FD_MESSAGE_CLASS(class)                   (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_UNIX_FD_MESSAGE))
#define G_IS_UNIX_FD_MESSAGE(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_UNIX_FD_MESSAGE))
#define G_UNIX_FD_MESSAGE_CLASS(class)                      (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessageClass))
#define G_UNIX_FD_MESSAGE(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessage))
#define G_TYPE_UNIX_FD_MESSAGE                              (g_unix_fd_message_get_type ())
#define G_UNIX_FD_LIST_GET_CLASS(inst)                      (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_UNIX_FD_LIST, GUnixFDListClass))
#define G_IS_UNIX_FD_LIST_CLASS(class)                      (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_UNIX_FD_LIST))
#define G_IS_UNIX_FD_LIST(inst)                             (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_UNIX_FD_LIST))
#define G_UNIX_FD_LIST_CLASS(class)                         (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_UNIX_FD_LIST, GUnixFDListClass))
#define G_UNIX_FD_LIST(inst)                                (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_UNIX_FD_LIST, GUnixFDList))
#define G_TYPE_UNIX_FD_LIST                                 (g_unix_fd_list_get_type ())
#define G_UNIX_CREDENTIALS_MESSAGE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass))
#define G_IS_UNIX_CREDENTIALS_MESSAGE_CLASS(c)  (G_TYPE_CHECK_CLASS_TYPE ((c), G_TYPE_UNIX_CREDENTIALS_MESSAGE))
#define G_IS_UNIX_CREDENTIALS_MESSAGE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE))
#define G_UNIX_CREDENTIALS_MESSAGE_CLASS(c)     (G_TYPE_CHECK_CLASS_CAST ((c), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass))
#define G_UNIX_CREDENTIALS_MESSAGE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessage))
#define G_TYPE_UNIX_CREDENTIALS_MESSAGE         (g_unix_credentials_message_get_type ())
#define G_UNIX_CONNECTION_GET_CLASS(inst)                   (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_UNIX_CONNECTION, GUnixConnectionClass))
#define G_IS_UNIX_CONNECTION_CLASS(class)                   (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_UNIX_CONNECTION))
#define G_IS_UNIX_CONNECTION(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_UNIX_CONNECTION))
#define G_UNIX_CONNECTION_CLASS(class)                      (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_UNIX_CONNECTION, GUnixConnectionClass))
#define G_UNIX_CONNECTION(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_UNIX_CONNECTION, GUnixConnection))
#define G_TYPE_UNIX_CONNECTION                              (g_unix_connection_get_type ())
#define G_TLS_SERVER_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnectionInterface))
#define G_IS_TLS_SERVER_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_SERVER_CONNECTION))
#define G_TLS_SERVER_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnection))
#define G_TYPE_TLS_SERVER_CONNECTION                (g_tls_server_connection_get_type ())
#define G_TLS_PASSWORD_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TLS_PASSWORD, GTlsPasswordClass))
#define G_IS_TLS_PASSWORD_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TLS_PASSWORD))
#define G_IS_TLS_PASSWORD(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TLS_PASSWORD))
#define G_TLS_PASSWORD_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TLS_PASSWORD, GTlsPasswordClass))
#define G_TLS_PASSWORD(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TLS_PASSWORD, GTlsPassword))
#define G_TYPE_TLS_PASSWORD         (g_tls_password_get_type ())
#define G_TLS_INTERACTION_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TLS_INTERACTION, GTlsInteractionClass))
#define G_IS_TLS_INTERACTION_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TLS_INTERACTION))
#define G_IS_TLS_INTERACTION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TLS_INTERACTION))
#define G_TLS_INTERACTION_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TLS_INTERACTION, GTlsInteractionClass))
#define G_TLS_INTERACTION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TLS_INTERACTION, GTlsInteraction))
#define G_TYPE_TLS_INTERACTION         (g_tls_interaction_get_type ())
#define G_TLS_FILE_DATABASE_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabaseInterface))
#define G_IS_TLS_FILE_DATABASE(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_FILE_DATABASE))
#define G_TLS_FILE_DATABASE(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabase))
#define G_TYPE_TLS_FILE_DATABASE                (g_tls_file_database_get_type ())
#define G_TLS_DATABASE_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_DATABASE, GTlsDatabaseClass))
#define G_IS_TLS_DATABASE_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_DATABASE))
#define G_IS_TLS_DATABASE(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_DATABASE))
#define G_TLS_DATABASE_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_DATABASE, GTlsDatabaseClass))
#define G_TLS_DATABASE(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_DATABASE, GTlsDatabase))
#define G_TYPE_TLS_DATABASE            (g_tls_database_get_type ())
#define G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT "1.3.6.1.5.5.7.3.2"
#define G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER "1.3.6.1.5.5.7.3.1"
#define G_TLS_ERROR (g_tls_error_quark ())
#define G_TLS_CONNECTION_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_CONNECTION, GTlsConnectionClass))
#define G_IS_TLS_CONNECTION_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_CONNECTION))
#define G_IS_TLS_CONNECTION(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CONNECTION))
#define G_TLS_CONNECTION_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_CONNECTION, GTlsConnectionClass))
#define G_TLS_CONNECTION(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CONNECTION, GTlsConnection))
#define G_TYPE_TLS_CONNECTION            (g_tls_connection_get_type ())
#define G_TLS_CLIENT_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnectionInterface))
#define G_IS_TLS_CLIENT_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CLIENT_CONNECTION))
#define G_TLS_CLIENT_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnection))
#define G_TYPE_TLS_CLIENT_CONNECTION                (g_tls_client_connection_get_type ())
#define G_TLS_CERTIFICATE_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass))
#define G_IS_TLS_CERTIFICATE_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_CERTIFICATE))
#define G_IS_TLS_CERTIFICATE(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CERTIFICATE))
#define G_TLS_CERTIFICATE_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass))
#define G_TLS_CERTIFICATE(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CERTIFICATE, GTlsCertificate))
#define G_TYPE_TLS_CERTIFICATE            (g_tls_certificate_get_type ())
#define G_TLS_BACKEND_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_TLS_BACKEND, GTlsBackendInterface))
#define G_IS_TLS_BACKEND(obj)	         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_TLS_BACKEND))
#define G_TLS_BACKEND(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_TLS_BACKEND, GTlsBackend))
#define G_TYPE_TLS_BACKEND               (g_tls_backend_get_type ())
#define G_TLS_BACKEND_EXTENSION_POINT_NAME "gio-tls-backend"
#define G_THREADED_SOCKET_SERVICE_GET_CLASS(inst)           (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_THREADED_SOCKET_SERVICE,                         \
                                                             GThreadedSocketServiceClass))
#define G_IS_THREADED_SOCKET_SERVICE_CLASS(class)           (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_THREADED_SOCKET_SERVICE))
#define G_IS_THREADED_SOCKET_SERVICE(inst)                  (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_THREADED_SOCKET_SERVICE))
#define G_THREADED_SOCKET_SERVICE_CLASS(class)              (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_THREADED_SOCKET_SERVICE,                         \
                                                             GThreadedSocketServiceClass))
#define G_THREADED_SOCKET_SERVICE(inst)                     (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_THREADED_SOCKET_SERVICE,                         \
                                                             GThreadedSocketService))
#define G_TYPE_THREADED_SOCKET_SERVICE                      (g_threaded_socket_service_get_type ())
#define G_THEMED_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_THEMED_ICON, GThemedIconClass))
#define G_IS_THEMED_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_THEMED_ICON))
#define G_IS_THEMED_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_THEMED_ICON))
#define G_THEMED_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_THEMED_ICON, GThemedIconClass))
#define G_THEMED_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_THEMED_ICON, GThemedIcon))
#define G_TYPE_THEMED_ICON         (g_themed_icon_get_type ())
#define G_IS_TEST_DBUS(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_TEST_DBUS))
#define G_TEST_DBUS(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_TEST_DBUS, \
        GTestDBus))
#define G_TYPE_TEST_DBUS \
    (g_test_dbus_get_type ())
#define G_TCP_WRAPPER_CONNECTION_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass))
#define G_IS_TCP_WRAPPER_CONNECTION_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION))
#define G_IS_TCP_WRAPPER_CONNECTION(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION))
#define G_TCP_WRAPPER_CONNECTION_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass))
#define G_TCP_WRAPPER_CONNECTION(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnection))
#define G_TYPE_TCP_WRAPPER_CONNECTION            (g_tcp_wrapper_connection_get_type ())
#define G_TCP_CONNECTION_GET_CLASS(inst)                    (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_TCP_CONNECTION, GTcpConnectionClass))
#define G_IS_TCP_CONNECTION_CLASS(class)                    (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_TCP_CONNECTION))
#define G_IS_TCP_CONNECTION(inst)                           (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_TCP_CONNECTION))
#define G_TCP_CONNECTION_CLASS(class)                       (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_TCP_CONNECTION, GTcpConnectionClass))
#define G_TCP_CONNECTION(inst)                              (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_TCP_CONNECTION, GTcpConnection))
#define G_TYPE_TCP_CONNECTION                               (g_tcp_connection_get_type ())
#define G_TASK_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TASK, GTaskClass))
#define G_IS_TASK_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TASK))
#define G_IS_TASK(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TASK))
#define G_TASK_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TASK, GTaskClass))
#define G_TASK(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TASK, GTask))
#define G_TYPE_TASK         (g_task_get_type ())
#define G_IS_SUBPROCESS_LAUNCHER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SUBPROCESS_LAUNCHER))
#define G_SUBPROCESS_LAUNCHER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SUBPROCESS_LAUNCHER, GSubprocessLauncher))
#define G_TYPE_SUBPROCESS_LAUNCHER         (g_subprocess_launcher_get_type ())
#define G_IS_SUBPROCESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SUBPROCESS))
#define G_SUBPROCESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SUBPROCESS, GSubprocess))
#define G_TYPE_SUBPROCESS         (g_subprocess_get_type ())
#define G_TYPE_SRV_TARGET (g_srv_target_get_type ())
#define G_SOCKET_SERVICE_GET_CLASS(inst)                    (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_SERVICE, GSocketServiceClass))
#define G_IS_SOCKET_SERVICE_CLASS(class)                    (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_SERVICE))
#define G_IS_SOCKET_SERVICE(inst)                           (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_SERVICE))
#define G_SOCKET_SERVICE_CLASS(class)                       (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_SERVICE, GSocketServiceClass))
#define G_SOCKET_SERVICE(inst)                              (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_SERVICE, GSocketService))
#define G_TYPE_SOCKET_SERVICE                               (g_socket_service_get_type ())
#define G_SOCKET_LISTENER_GET_CLASS(inst)                   (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_LISTENER, GSocketListenerClass))
#define G_IS_SOCKET_LISTENER_CLASS(class)                   (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_LISTENER))
#define G_IS_SOCKET_LISTENER(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_LISTENER))
#define G_SOCKET_LISTENER_CLASS(class)                      (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_LISTENER, GSocketListenerClass))
#define G_SOCKET_LISTENER(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_LISTENER, GSocketListener))
#define G_TYPE_SOCKET_LISTENER                              (g_socket_listener_get_type ())
#define G_SOCKET_CONTROL_MESSAGE_GET_CLASS(inst)            (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE,                          \
                                                             GSocketControlMessageClass))
#define G_IS_SOCKET_CONTROL_MESSAGE_CLASS(class)            (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE))
#define G_IS_SOCKET_CONTROL_MESSAGE(inst)                   (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE))
#define G_SOCKET_CONTROL_MESSAGE_CLASS(class)               (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE,                          \
                                                             GSocketControlMessageClass))
#define G_SOCKET_CONTROL_MESSAGE(inst)                      (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE,                          \
                                                             GSocketControlMessage))
#define G_TYPE_SOCKET_CONTROL_MESSAGE                       (g_socket_control_message_get_type ())
#define G_SOCKET_CONNECTION_GET_CLASS(inst)                 (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass))
#define G_IS_SOCKET_CONNECTION_CLASS(class)                 (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_CONNECTION))
#define G_IS_SOCKET_CONNECTION(inst)                        (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_CONNECTION))
#define G_SOCKET_CONNECTION_CLASS(class)                    (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass))
#define G_SOCKET_CONNECTION(inst)                           (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_CONNECTION, GSocketConnection))
#define G_TYPE_SOCKET_CONNECTION                            (g_socket_connection_get_type ())
#define G_SOCKET_CONNECTABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface))
#define G_IS_SOCKET_CONNECTABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SOCKET_CONNECTABLE))
#define G_SOCKET_CONNECTABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable))
#define G_TYPE_SOCKET_CONNECTABLE            (g_socket_connectable_get_type ())
#define G_SOCKET_CLIENT_GET_CLASS(inst)                     (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_CLIENT, GSocketClientClass))
#define G_IS_SOCKET_CLIENT_CLASS(class)                     (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_CLIENT))
#define G_IS_SOCKET_CLIENT(inst)                            (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_CLIENT))
#define G_SOCKET_CLIENT_CLASS(class)                        (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_CLIENT, GSocketClientClass))
#define G_SOCKET_CLIENT(inst)                               (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_CLIENT, GSocketClient))
#define G_TYPE_SOCKET_CLIENT                                (g_socket_client_get_type ())
#define G_SOCKET_ADDRESS_ENUMERATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass))
#define G_IS_SOCKET_ADDRESS_ENUMERATOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS_ENUMERATOR))
#define G_IS_SOCKET_ADDRESS_ENUMERATOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR))
#define G_SOCKET_ADDRESS_ENUMERATOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass))
#define G_SOCKET_ADDRESS_ENUMERATOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumerator))
#define G_TYPE_SOCKET_ADDRESS_ENUMERATOR         (g_socket_address_enumerator_get_type ())
#define G_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
#define G_IS_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS))
#define G_IS_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS))
#define G_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
#define G_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddress))
#define G_TYPE_SOCKET_ADDRESS         (g_socket_address_get_type ())
#define G_SOCKET_GET_CLASS(inst)                            (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET, GSocketClass))
#define G_IS_SOCKET_CLASS(class)                            (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET))
#define G_IS_SOCKET(inst)                                   (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET))
#define G_SOCKET_CLASS(class)                               (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET, GSocketClass))
#define G_SOCKET(inst)                                      (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET, GSocket))
#define G_TYPE_SOCKET                                       (g_socket_get_type ())
#define G_SIMPLE_PROXY_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass))
#define G_IS_SIMPLE_PROXY_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SIMPLE_PROXY_RESOLVER))
#define G_IS_SIMPLE_PROXY_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SIMPLE_PROXY_RESOLVER))
#define G_SIMPLE_PROXY_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass))
#define G_SIMPLE_PROXY_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolver))
#define G_TYPE_SIMPLE_PROXY_RESOLVER         (g_simple_proxy_resolver_get_type ())
#define G_IS_SIMPLE_PERMISSION(inst)  (G_TYPE_CHECK_INSTANCE_TYPE ((inst),   \
                                       G_TYPE_SIMPLE_PERMISSION))
#define G_SIMPLE_PERMISSION(inst)     (G_TYPE_CHECK_INSTANCE_CAST ((inst),   \
                                       G_TYPE_SIMPLE_PERMISSION,             \
                                       GSimplePermission))
#define G_TYPE_SIMPLE_PERMISSION      (g_simple_permission_get_type ())
#define G_IS_SIMPLE_IO_STREAM(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SIMPLE_IO_STREAM))
#define G_SIMPLE_IO_STREAM(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SIMPLE_IO_STREAM, GSimpleIOStream))
#define G_TYPE_SIMPLE_IO_STREAM                  (g_simple_io_stream_get_type ())
#define G_SIMPLE_ASYNC_RESULT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass))
#define G_IS_SIMPLE_ASYNC_RESULT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SIMPLE_ASYNC_RESULT))
#define G_IS_SIMPLE_ASYNC_RESULT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SIMPLE_ASYNC_RESULT))
#define G_SIMPLE_ASYNC_RESULT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass))
#define G_SIMPLE_ASYNC_RESULT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResult))
#define G_TYPE_SIMPLE_ASYNC_RESULT         (g_simple_async_result_get_type ())
#define G_SIMPLE_ACTION_GROUP_GET_CLASS(inst)               (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass))
#define G_IS_SIMPLE_ACTION_GROUP_CLASS(class)               (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SIMPLE_ACTION_GROUP))
#define G_IS_SIMPLE_ACTION_GROUP(inst)                      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION_GROUP))
#define G_SIMPLE_ACTION_GROUP_CLASS(class)                  (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass))
#define G_SIMPLE_ACTION_GROUP(inst)                         (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroup))
#define G_TYPE_SIMPLE_ACTION_GROUP                          (g_simple_action_group_get_type ())
#define G_IS_SIMPLE_ACTION(inst)                            (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION))
#define G_SIMPLE_ACTION(inst)                               (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION, GSimpleAction))
#define G_TYPE_SIMPLE_ACTION                                (g_simple_action_get_type ())
#define                 G_TYPE_SETTINGS_SCHEMA_KEY                      (g_settings_schema_key_get_type ())
#define                 G_TYPE_SETTINGS_SCHEMA                          (g_settings_schema_get_type ())
#define                 G_TYPE_SETTINGS_SCHEMA_SOURCE                   (g_settings_schema_source_get_type ())
#define G_SETTINGS_BACKEND_EXTENSION_POINT_NAME "gsettings-backend"
#define G_SETTINGS_BACKEND_GET_CLASS(inst)                  (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SETTINGS_BACKEND, GSettingsBackendClass))
#define G_IS_SETTINGS_BACKEND_CLASS(class)                  (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SETTINGS_BACKEND))
#define G_IS_SETTINGS_BACKEND(inst)                         (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SETTINGS_BACKEND))
#define G_SETTINGS_BACKEND_CLASS(class)                     (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SETTINGS_BACKEND, GSettingsBackendClass))
#define G_SETTINGS_BACKEND(inst)                            (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SETTINGS_BACKEND, GSettingsBackend))
#define G_TYPE_SETTINGS_BACKEND                             (g_settings_backend_get_type ())
#define G_SETTINGS_GET_CLASS(inst)                          (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SETTINGS, GSettingsClass))
#define G_IS_SETTINGS_CLASS(class)                          (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SETTINGS))
#define G_IS_SETTINGS(inst)                                 (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SETTINGS))
#define G_SETTINGS_CLASS(class)                             (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SETTINGS, GSettingsClass))
#define G_SETTINGS(inst)                                    (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SETTINGS, GSettings))
#define G_TYPE_SETTINGS                                     (g_settings_get_type ())
#define G_SEEKABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SEEKABLE, GSeekableIface))
#define G_IS_SEEKABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SEEKABLE))
#define G_SEEKABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SEEKABLE, GSeekable))
#define G_TYPE_SEEKABLE            (g_seekable_get_type ())
#define G_RESOURCE_ERROR (g_resource_error_quark ())
#define G_TYPE_RESOURCE (g_resource_get_type ())
#define G_RESOLVER_ERROR (g_resolver_error_quark ())
#define G_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_RESOLVER, GResolverClass))
#define G_IS_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_RESOLVER))
#define G_IS_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_RESOLVER))
#define G_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_RESOLVER, GResolverClass))
#define G_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_RESOLVER, GResolver))
#define G_TYPE_RESOLVER         (g_resolver_get_type ())
#define G_REMOTE_ACTION_GROUP_GET_IFACE(inst)               (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                   \
                                                             G_TYPE_REMOTE_ACTION_GROUP,                              \
                                                             GRemoteActionGroupInterface))
#define G_IS_REMOTE_ACTION_GROUP(inst)                      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                      \
                                                             G_TYPE_REMOTE_ACTION_GROUP))
#define G_REMOTE_ACTION_GROUP(inst)                         (G_TYPE_CHECK_INSTANCE_CAST ((inst),                      \
                                                             G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroup))
#define G_TYPE_REMOTE_ACTION_GROUP                          (g_remote_action_group_get_type ())
#define G_PROXY_RESOLVER_PORTAL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_PROXY_RESOLVER_PORTAL, GProxyResolverPortalClass))
#define G_IS_PROXY_RESOLVER_PORTAL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_PROXY_RESOLVER_PORTAL))
#define G_IS_PROXY_RESOLVER_PORTAL(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_RESOLVER_PORTAL))
#define G_PROXY_RESOLVER_PORTAL_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_PROXY_RESOLVER_PORTAL, GProxyResolverPortalClass))
#define G_PROXY_RESOLVER_PORTAL(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_RESOLVER_PORTAL, GProxyResolverPortal))
#define G_TYPE_PROXY_RESOLVER_PORTAL         (g_proxy_resolver_portal_get_type ())
#define G_PROXY_RESOLVER_EXTENSION_POINT_NAME "gio-proxy-resolver"
#define G_PROXY_RESOLVER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_PROXY_RESOLVER, GProxyResolverInterface))
#define G_IS_PROXY_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_RESOLVER))
#define G_PROXY_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_RESOLVER, GProxyResolver))
#define G_TYPE_PROXY_RESOLVER         (g_proxy_resolver_get_type ())
#define G_PROXY_ADDRESS_ENUMERATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass))
#define G_IS_PROXY_ADDRESS_ENUMERATOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_PROXY_ADDRESS_ENUMERATOR))
#define G_IS_PROXY_ADDRESS_ENUMERATOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR))
#define G_PROXY_ADDRESS_ENUMERATOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass))
#define G_PROXY_ADDRESS_ENUMERATOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumerator))
#define G_TYPE_PROXY_ADDRESS_ENUMERATOR         (g_proxy_address_enumerator_get_type ())
#define G_PROXY_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_PROXY_ADDRESS, GProxyAddressClass))
#define G_IS_PROXY_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_PROXY_ADDRESS))
#define G_IS_PROXY_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_ADDRESS))
#define G_PROXY_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_PROXY_ADDRESS, GProxyAddressClass))
#define G_PROXY_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_ADDRESS, GProxyAddress))
#define G_TYPE_PROXY_ADDRESS         (g_proxy_address_get_type ())
#define G_PROXY_EXTENSION_POINT_NAME "gio-proxy"
#define G_PROXY_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_PROXY, GProxyInterface))
#define G_IS_PROXY(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY))
#define G_PROXY(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY, GProxy))
#define G_TYPE_PROXY		(g_proxy_get_type ())
#define G_IS_PROPERTY_ACTION(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_PROPERTY_ACTION))
#define G_PROPERTY_ACTION(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_PROPERTY_ACTION, GPropertyAction))
#define G_TYPE_PROPERTY_ACTION                              (g_property_action_get_type ())
#define G_POLLABLE_OUTPUT_STREAM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStreamInterface))
#define G_IS_POLLABLE_OUTPUT_STREAM(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM))
#define G_POLLABLE_OUTPUT_STREAM(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStream))
#define G_TYPE_POLLABLE_OUTPUT_STREAM               (g_pollable_output_stream_get_type ())
#define G_POLLABLE_INPUT_STREAM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStreamInterface))
#define G_IS_POLLABLE_INPUT_STREAM(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_POLLABLE_INPUT_STREAM))
#define G_POLLABLE_INPUT_STREAM(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStream))
#define G_TYPE_POLLABLE_INPUT_STREAM               (g_pollable_input_stream_get_type ())
#define G_PERMISSION_GET_CLASS(inst)  (G_TYPE_INSTANCE_GET_CLASS ((inst),    \
                                       G_TYPE_PERMISSION, GPermissionClass))
#define G_IS_PERMISSION_CLASS(class)  (G_TYPE_CHECK_CLASS_TYPE ((class),     \
                                       G_TYPE_PERMISSION))
#define G_IS_PERMISSION(inst)         (G_TYPE_CHECK_INSTANCE_TYPE ((inst),   \
                                       G_TYPE_PERMISSION))
#define G_PERMISSION_CLASS(class)     (G_TYPE_CHECK_CLASS_CAST ((class),     \
                                       G_TYPE_PERMISSION, GPermissionClass))
#define G_PERMISSION(inst)            (G_TYPE_CHECK_INSTANCE_CAST ((inst),   \
                                       G_TYPE_PERMISSION, GPermission))
#define G_TYPE_PERMISSION             (g_permission_get_type ())
#define G_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_OUTPUT_STREAM, GOutputStreamClass))
#define G_IS_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_OUTPUT_STREAM))
#define G_IS_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_OUTPUT_STREAM))
#define G_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_OUTPUT_STREAM, GOutputStreamClass))
#define G_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_OUTPUT_STREAM, GOutputStream))
#define G_TYPE_OUTPUT_STREAM         (g_output_stream_get_type ())
#define G_OSX_APP_INFO_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_OSX_APP_INFO, GOsxAppInfoClass))
#define G_IS_OSX_APP_INFO_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_OSX_APP_INFO))
#define G_IS_OSX_APP_INFO(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_OSX_APP_INFO))
#define G_OSX_APP_INFO_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_OSX_APP_INFO, GOsxAppInfoClass))
#define G_OSX_APP_INFO(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_OSX_APP_INFO, GOsxAppInfo))
#define G_TYPE_OSX_APP_INFO         (g_osx_app_info_get_type ())
#define G_IS_NOTIFICATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NOTIFICATION))
#define G_NOTIFICATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NOTIFICATION, GNotification))
#define G_TYPE_NOTIFICATION         (g_notification_get_type ())
#define G_NETWORK_SERVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
#define G_IS_NETWORK_SERVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_SERVICE))
#define G_IS_NETWORK_SERVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_SERVICE))
#define G_NETWORK_SERVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
#define G_NETWORK_SERVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_SERVICE, GNetworkService))
#define G_TYPE_NETWORK_SERVICE         (g_network_service_get_type ())
#define G_NETWORK_MONITOR_PORTAL_GET_INITABLE_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_INITABLE, GInitable))
#define G_NETWORK_MONITOR_PORTAL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_MONITOR_PORTAL, GNetworkMonitorPortalClass))
#define G_IS_NETWORK_MONITOR_PORTAL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_MONITOR_PORTAL))
#define G_IS_NETWORK_MONITOR_PORTAL(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_MONITOR_PORTAL))
#define G_NETWORK_MONITOR_PORTAL_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_MONITOR_PORTAL, GNetworkMonitorPortalClass))
#define G_NETWORK_MONITOR_PORTAL(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_MONITOR_PORTAL, GNetworkMonitorPortal))
#define G_TYPE_NETWORK_MONITOR_PORTAL         (g_network_monitor_portal_get_type ())
#define G_NETWORK_MONITOR_GET_INTERFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitorInterface))
#define G_IS_NETWORK_MONITOR(o)            (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_MONITOR))
#define G_NETWORK_MONITOR(o)               (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitor))
#define G_TYPE_NETWORK_MONITOR             (g_network_monitor_get_type ())
#define G_NETWORK_MONITOR_EXTENSION_POINT_NAME "gio-network-monitor"
#define G_NETWORK_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
#define G_IS_NETWORK_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_ADDRESS))
#define G_IS_NETWORK_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_ADDRESS))
#define G_NETWORK_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
#define G_NETWORK_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddress))
#define G_TYPE_NETWORK_ADDRESS         (g_network_address_get_type ())
#define G_NATIVE_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass))
#define G_IS_NATIVE_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NATIVE_SOCKET_ADDRESS))
#define G_IS_NATIVE_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NATIVE_SOCKET_ADDRESS))
#define G_NATIVE_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass))
#define G_NATIVE_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddress))
#define G_TYPE_NATIVE_SOCKET_ADDRESS         (g_native_socket_address_get_type ())
#define G_MOUNT_OPERATION_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MOUNT_OPERATION, GMountOperationClass))
#define G_IS_MOUNT_OPERATION_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MOUNT_OPERATION))
#define G_IS_MOUNT_OPERATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MOUNT_OPERATION))
#define G_MOUNT_OPERATION_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MOUNT_OPERATION, GMountOperationClass))
#define G_MOUNT_OPERATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MOUNT_OPERATION, GMountOperation))
#define G_TYPE_MOUNT_OPERATION         (g_mount_operation_get_type ())
#define G_MOUNT_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_MOUNT, GMountIface))
#define G_IS_MOUNT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_MOUNT))
#define G_MOUNT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_MOUNT, GMount))
#define G_TYPE_MOUNT            (g_mount_get_type ())
#define G_MENU_LINK_ITER_GET_CLASS(inst)                    (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass))
#define G_IS_MENU_LINK_ITER_CLASS(class)                    (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_MENU_LINK_ITER))
#define G_IS_MENU_LINK_ITER(inst)                           (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_MENU_LINK_ITER))
#define G_MENU_LINK_ITER_CLASS(class)                       (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass))
#define G_MENU_LINK_ITER(inst)                              (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_MENU_LINK_ITER, GMenuLinkIter))
#define G_TYPE_MENU_LINK_ITER                               (g_menu_link_iter_get_type ())
#define G_MENU_ATTRIBUTE_ITER_GET_CLASS(inst)               (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass))
#define G_IS_MENU_ATTRIBUTE_ITER_CLASS(class)               (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER))
#define G_IS_MENU_ATTRIBUTE_ITER(inst)                      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER))
#define G_MENU_ATTRIBUTE_ITER_CLASS(class)                  (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass))
#define G_MENU_ATTRIBUTE_ITER(inst)                         (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIter))
#define G_TYPE_MENU_ATTRIBUTE_ITER                          (g_menu_attribute_iter_get_type ())
#define G_MENU_MODEL_GET_CLASS(inst)                        (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_MENU_MODEL, GMenuModelClass))
#define G_IS_MENU_MODEL_CLASS(class)                        (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_MENU_MODEL))
#define G_IS_MENU_MODEL(inst)                               (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_MENU_MODEL))
#define G_MENU_MODEL_CLASS(class)                           (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_MENU_MODEL, GMenuModelClass))
#define G_MENU_MODEL(inst)                                  (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_MENU_MODEL, GMenuModel))
#define G_TYPE_MENU_MODEL                                   (g_menu_model_get_type ())
#define G_MENU_LINK_SECTION "section"
#define G_MENU_LINK_SUBMENU "submenu"
#define G_MENU_ATTRIBUTE_ICON "icon"
#define G_MENU_ATTRIBUTE_LABEL "label"
#define G_MENU_ATTRIBUTE_TARGET "target"
#define G_MENU_ATTRIBUTE_ACTION_NAMESPACE "action-namespace"
#define G_MENU_ATTRIBUTE_ACTION "action"
#define G_IS_MENU_ITEM(inst) (G_TYPE_CHECK_INSTANCE_TYPE ((inst), \
                              G_TYPE_MENU_ITEM))
#define G_MENU_ITEM(inst)    (G_TYPE_CHECK_INSTANCE_CAST ((inst), \
                              G_TYPE_MENU_ITEM, GMenuItem))
#define G_TYPE_MENU_ITEM     (g_menu_item_get_type ())
#define G_IS_MENU(inst)      (G_TYPE_CHECK_INSTANCE_TYPE ((inst), \
                              G_TYPE_MENU))
#define G_MENU(inst)         (G_TYPE_CHECK_INSTANCE_CAST ((inst), \
                              G_TYPE_MENU, GMenu))
#define G_TYPE_MENU          (g_menu_get_type ())
#define G_MEMORY_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass))
#define G_IS_MEMORY_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MEMORY_OUTPUT_STREAM))
#define G_IS_MEMORY_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MEMORY_OUTPUT_STREAM))
#define G_MEMORY_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass))
#define G_MEMORY_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStream))
#define G_TYPE_MEMORY_OUTPUT_STREAM         (g_memory_output_stream_get_type ())
#define G_MEMORY_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass))
#define G_IS_MEMORY_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MEMORY_INPUT_STREAM))
#define G_IS_MEMORY_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MEMORY_INPUT_STREAM))
#define G_MEMORY_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass))
#define G_MEMORY_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStream))
#define G_TYPE_MEMORY_INPUT_STREAM         (g_memory_input_stream_get_type ())
#define G_LOADABLE_ICON_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_LOADABLE_ICON, GLoadableIconIface))
#define G_IS_LOADABLE_ICON(obj)	        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_LOADABLE_ICON))
#define G_LOADABLE_ICON(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_LOADABLE_ICON, GLoadableIcon))
#define G_TYPE_LOADABLE_ICON            (g_loadable_icon_get_type ())
#define G_TYPE_LIST_STORE (g_list_store_get_type ())
#define G_TYPE_LIST_MODEL g_list_model_get_type ()
#define G_IO_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_IO_STREAM, GIOStreamClass))
#define G_IS_IO_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_IO_STREAM))
#define G_IS_IO_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_IO_STREAM))
#define G_IO_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_IO_STREAM, GIOStreamClass))
#define G_IO_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_IO_STREAM, GIOStream))
#define G_TYPE_IO_STREAM         (g_io_stream_get_type ())
#define G_IO_MODULE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_IO_TYPE_MODULE, GIOModuleClass))
#define G_IO_IS_MODULE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_IO_TYPE_MODULE))
#define G_IO_IS_MODULE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_IO_TYPE_MODULE))
#define G_IO_MODULE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_IO_TYPE_MODULE, GIOModuleClass))
#define G_IO_MODULE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_IO_TYPE_MODULE, GIOModule))
#define G_IO_TYPE_MODULE         (g_io_module_get_type ())
#define G_IO_ERROR g_io_error_quark()
#define G_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INPUT_STREAM, GInputStreamClass))
#define G_IS_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INPUT_STREAM))
#define G_IS_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INPUT_STREAM))
#define G_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INPUT_STREAM, GInputStreamClass))
#define G_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INPUT_STREAM, GInputStream))
#define G_TYPE_INPUT_STREAM         (g_input_stream_get_type ())
#define G_TYPE_IS_INITABLE(type)   (g_type_is_a ((type), G_TYPE_INITABLE))
#define G_INITABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_INITABLE, GInitableIface))
#define G_IS_INITABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_INITABLE))
#define G_INITABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_INITABLE, GInitable))
#define G_TYPE_INITABLE            (g_initable_get_type ())
#define G_INET_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
#define G_IS_INET_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_SOCKET_ADDRESS))
#define G_IS_INET_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_SOCKET_ADDRESS))
#define G_INET_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
#define G_INET_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress))
#define G_TYPE_INET_SOCKET_ADDRESS         (g_inet_socket_address_get_type ())
#define G_INET_ADDRESS_MASK_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass))
#define G_IS_INET_ADDRESS_MASK_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS_MASK))
#define G_IS_INET_ADDRESS_MASK(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS_MASK))
#define G_INET_ADDRESS_MASK_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass))
#define G_INET_ADDRESS_MASK(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS_MASK, GInetAddressMask))
#define G_TYPE_INET_ADDRESS_MASK         (g_inet_address_mask_get_type ())
#define G_INET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS, GInetAddressClass))
#define G_IS_INET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS))
#define G_IS_INET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS))
#define G_INET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS, GInetAddressClass))
#define G_INET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS, GInetAddress))
#define G_TYPE_INET_ADDRESS         (g_inet_address_get_type ())
#define G_ICON_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ICON, GIconIface))
#define G_IS_ICON(obj)	       (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ICON))
#define G_ICON(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ICON, GIcon))
#define G_TYPE_ICON            (g_icon_get_type ())
#define G_FILTER_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass))
#define G_IS_FILTER_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILTER_OUTPUT_STREAM))
#define G_IS_FILTER_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILTER_OUTPUT_STREAM))
#define G_FILTER_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass))
#define G_FILTER_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStream))
#define G_TYPE_FILTER_OUTPUT_STREAM         (g_filter_output_stream_get_type ())
#define G_FILTER_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass))
#define G_IS_FILTER_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILTER_INPUT_STREAM))
#define G_IS_FILTER_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILTER_INPUT_STREAM))
#define G_FILTER_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass))
#define G_FILTER_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStream))
#define G_TYPE_FILTER_INPUT_STREAM         (g_filter_input_stream_get_type ())
#define G_FILE_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass))
#define G_IS_FILE_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_OUTPUT_STREAM))
#define G_IS_FILE_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_OUTPUT_STREAM))
#define G_FILE_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass))
#define G_FILE_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStream))
#define G_TYPE_FILE_OUTPUT_STREAM         (g_file_output_stream_get_type ())
#define G_IS_FILENAME_COMPLETER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILENAME_COMPLETER))
#define G_IS_FILENAME_COMPLETER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILENAME_COMPLETER))
#define G_FILENAME_COMPLETER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass))
#define G_FILENAME_COMPLETER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass))
#define G_FILENAME_COMPLETER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILENAME_COMPLETER, GFilenameCompleter))
#define G_TYPE_FILENAME_COMPLETER         (g_filename_completer_get_type ())
#define G_FILE_MONITOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_MONITOR, GFileMonitorClass))
#define G_IS_FILE_MONITOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_MONITOR))
#define G_IS_FILE_MONITOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_MONITOR))
#define G_FILE_MONITOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_MONITOR, GFileMonitorClass))
#define G_FILE_MONITOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_MONITOR, GFileMonitor))
#define G_TYPE_FILE_MONITOR         (g_file_monitor_get_type ())
#define G_FILE_IO_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_IO_STREAM, GFileIOStreamClass))
#define G_IS_FILE_IO_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_IO_STREAM))
#define G_IS_FILE_IO_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_IO_STREAM))
#define G_FILE_IO_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_IO_STREAM, GFileIOStreamClass))
#define G_FILE_IO_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_IO_STREAM, GFileIOStream))
#define G_TYPE_FILE_IO_STREAM         (g_file_io_stream_get_type ())
#define G_FILE_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass))
#define G_IS_FILE_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_INPUT_STREAM))
#define G_IS_FILE_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_INPUT_STREAM))
#define G_FILE_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass))
#define G_FILE_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_INPUT_STREAM, GFileInputStream))
#define G_TYPE_FILE_INPUT_STREAM         (g_file_input_stream_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_MATCHER (g_file_attribute_matcher_get_type ())
#define G_FILE_ATTRIBUTE_RECENT_MODIFIED "recent::modified"          /* int64 (time_t) */
#define G_FILE_ATTRIBUTE_TRASH_DELETION_DATE "trash::deletion-date"  /* string */
#define G_FILE_ATTRIBUTE_TRASH_ORIG_PATH "trash::orig-path"     /* byte string */
#define G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT "trash::item-count"     /* uint32 */
#define G_FILE_ATTRIBUTE_SELINUX_CONTEXT "selinux::context"       /* string */
#define G_FILE_ATTRIBUTE_GVFS_BACKEND "gvfs::backend"             /* string */
#define G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE "filesystem::remote"                   /* boolean */
#define G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW "filesystem::use-preview"        /* uint32 (GFilesystemPreviewType) */
#define G_FILE_ATTRIBUTE_FILESYSTEM_READONLY "filesystem::readonly"               /* boolean */
#define G_FILE_ATTRIBUTE_FILESYSTEM_TYPE "filesystem::type"                       /* string */
#define G_FILE_ATTRIBUTE_FILESYSTEM_USED "filesystem::used"                       /* uint64 */
#define G_FILE_ATTRIBUTE_FILESYSTEM_FREE "filesystem::free"                       /* uint64 */
#define G_FILE_ATTRIBUTE_FILESYSTEM_SIZE "filesystem::size"                       /* uint64 */
#define G_FILE_ATTRIBUTE_PREVIEW_ICON "preview::icon"         /* object (GIcon) */
#define G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID "thumbnail::is-valid"        /* boolean */
#define G_FILE_ATTRIBUTE_THUMBNAILING_FAILED "thumbnail::failed"         /* boolean */
#define G_FILE_ATTRIBUTE_THUMBNAIL_PATH "thumbnail::path"         /* bytestring */
#define G_FILE_ATTRIBUTE_OWNER_GROUP "owner::group"               /* string */
#define G_FILE_ATTRIBUTE_OWNER_USER_REAL "owner::user-real"       /* string */
#define G_FILE_ATTRIBUTE_OWNER_USER "owner::user"                 /* string */
#define G_FILE_ATTRIBUTE_DOS_IS_SYSTEM "dos::is-system"           /* boolean */
#define G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE "dos::is-archive"         /* boolean */
#define G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT "unix::is-mountpoint" /* boolean */
#define G_FILE_ATTRIBUTE_UNIX_BLOCKS "unix::blocks"               /* uint64 */
#define G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE "unix::block-size"       /* uint32 */
#define G_FILE_ATTRIBUTE_UNIX_RDEV "unix::rdev"                   /* uint32 */
#define G_FILE_ATTRIBUTE_UNIX_GID "unix::gid"                     /* uint32 */
#define G_FILE_ATTRIBUTE_UNIX_UID "unix::uid"                     /* uint32 */
#define G_FILE_ATTRIBUTE_UNIX_NLINK "unix::nlink"                 /* uint32 */
#define G_FILE_ATTRIBUTE_UNIX_MODE "unix::mode"                   /* uint32 */
#define G_FILE_ATTRIBUTE_UNIX_INODE "unix::inode"                 /* uint64 */
#define G_FILE_ATTRIBUTE_UNIX_DEVICE "unix::device"               /* uint32 */
#define G_FILE_ATTRIBUTE_TIME_CREATED_USEC "time::created-usec"   /* uint32 */
#define G_FILE_ATTRIBUTE_TIME_CREATED "time::created"             /* uint64 */
#define G_FILE_ATTRIBUTE_TIME_CHANGED_USEC "time::changed-usec"   /* uint32 */
#define G_FILE_ATTRIBUTE_TIME_CHANGED "time::changed"             /* uint64 */
#define G_FILE_ATTRIBUTE_TIME_ACCESS_USEC "time::access-usec"     /* uint32 */
#define G_FILE_ATTRIBUTE_TIME_ACCESS "time::access"               /* uint64 */
#define G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC "time::modified-usec" /* uint32 */
#define G_FILE_ATTRIBUTE_TIME_MODIFIED "time::modified"           /* uint64 */
#define G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC "mountable::is-media-check-automatic"      /* boolean */
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL "mountable::can-poll"      /* boolean */
#define G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE "mountable::start-stop-type" /* uint32 (GDriveStartStopType) */
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP "mountable::can-stop"      /* boolean */
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED "mountable::can-start-degraded"     /* boolean */
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START "mountable::can-start"     /* boolean */
#define G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI "mountable::hal-udi"         /* string */
#define G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE "mountable::unix-device-file" /* string */
#define G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE "mountable::unix-device" /* uint32 */
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT "mountable::can-eject"     /* boolean */
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT "mountable::can-unmount" /* boolean */
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT "mountable::can-mount"     /* boolean */
#define G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME "access::can-rename"   /* boolean */
#define G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH "access::can-trash"     /* boolean */
#define G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE "access::can-delete"   /* boolean */
#define G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE "access::can-execute" /* boolean */
#define G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE "access::can-write"     /* boolean */
#define G_FILE_ATTRIBUTE_ACCESS_CAN_READ "access::can-read"       /* boolean */
#define G_FILE_ATTRIBUTE_ID_FILESYSTEM "id::filesystem"         /* string */
#define G_FILE_ATTRIBUTE_ID_FILE "id::file"                     /* string */
#define G_FILE_ATTRIBUTE_ETAG_VALUE "etag::value"                 /* string */
#define G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER "standard::sort-order"         /* int32  */
#define G_FILE_ATTRIBUTE_STANDARD_TARGET_URI "standard::target-uri"         /* string */
#define G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET "standard::symlink-target" /* byte string */
#define G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE "standard::allocated-size" /* uint64 */
#define G_FILE_ATTRIBUTE_STANDARD_SIZE "standard::size"                     /* uint64 */
#define G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE "standard::fast-content-type" /* string */
#define G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE "standard::content-type"     /* string */
#define G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON "standard::symbolic-icon"   /* object (GIcon) */
#define G_FILE_ATTRIBUTE_STANDARD_ICON "standard::icon"                     /* object (GIcon) */
#define G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION "standard::description"        /* string */
#define G_FILE_ATTRIBUTE_STANDARD_COPY_NAME "standard::copy-name"           /* string */
#define G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME "standard::edit-name"           /* string */
#define G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME "standard::display-name"     /* string */
#define G_FILE_ATTRIBUTE_STANDARD_NAME "standard::name"                     /* byte string */
#define G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE "standard::is-volatile"      /* boolean */
#define G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL "standard::is-virtual"         /* boolean */
#define G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "standard::is-symlink"         /* boolean */
#define G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP "standard::is-backup"           /* boolean */
#define G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN "standard::is-hidden"           /* boolean */
#define G_FILE_ATTRIBUTE_STANDARD_TYPE "standard::type"                     /* uint32 (GFileType) */
#define G_FILE_INFO_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_INFO, GFileInfoClass))
#define G_IS_FILE_INFO_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_INFO))
#define G_IS_FILE_INFO(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_INFO))
#define G_FILE_INFO_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_INFO, GFileInfoClass))
#define G_FILE_INFO(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_INFO, GFileInfo))
#define G_TYPE_FILE_INFO         (g_file_info_get_type ())
#define G_FILE_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_ICON, GFileIconClass))
#define G_IS_FILE_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_ICON))
#define G_IS_FILE_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_ICON))
#define G_FILE_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_ICON, GFileIconClass))
#define G_FILE_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_ICON, GFileIcon))
#define G_TYPE_FILE_ICON         (g_file_icon_get_type ())
#define G_FILE_ENUMERATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass))
#define G_IS_FILE_ENUMERATOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_ENUMERATOR))
#define G_IS_FILE_ENUMERATOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_ENUMERATOR))
#define G_FILE_ENUMERATOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass))
#define G_FILE_ENUMERATOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_ENUMERATOR, GFileEnumerator))
#define G_TYPE_FILE_ENUMERATOR         (g_file_enumerator_get_type ())
#define G_FILE_DESCRIPTOR_BASED_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_FILE_DESCRIPTOR_BASED, GFileDescriptorBasedIface))
#define G_IS_FILE_DESCRIPTOR_BASED(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_FILE_DESCRIPTOR_BASED))
#define G_FILE_DESCRIPTOR_BASED(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_FILE_DESCRIPTOR_BASED, GFileDescriptorBased))
#define G_TYPE_FILE_DESCRIPTOR_BASED            (g_file_descriptor_based_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_INFO_LIST (g_file_attribute_info_list_get_type ())
#define G_FILE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_FILE, GFileIface))
#define G_IS_FILE(obj)	       (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_FILE))
#define G_FILE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_FILE, GFile))
#define G_TYPE_FILE            (g_file_get_type ())
#define G_EMBLEMED_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_EMBLEMED_ICON, GEmblemedIconClass))
#define G_IS_EMBLEMED_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_EMBLEMED_ICON))
#define G_IS_EMBLEMED_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_EMBLEMED_ICON))
#define G_EMBLEMED_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_EMBLEMED_ICON, GEmblemedIconClass))
#define G_EMBLEMED_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_EMBLEMED_ICON, GEmblemedIcon))
#define G_TYPE_EMBLEMED_ICON         (g_emblemed_icon_get_type ())
#define G_EMBLEM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_EMBLEM, GEmblemClass))
#define G_IS_EMBLEM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_EMBLEM))
#define G_IS_EMBLEM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_EMBLEM))
#define G_EMBLEM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_EMBLEM, GEmblemClass))
#define G_EMBLEM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_EMBLEM, GEmblem))
#define G_TYPE_EMBLEM         (g_emblem_get_type ())
#define G_DTLS_SERVER_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnectionInterface))
#define G_IS_DTLS_SERVER_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DTLS_SERVER_CONNECTION))
#define G_DTLS_SERVER_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnection))
#define G_TYPE_DTLS_SERVER_CONNECTION                (g_dtls_server_connection_get_type ())
#define G_DTLS_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_DTLS_CONNECTION, GDtlsConnectionInterface))
#define G_IS_DTLS_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DTLS_CONNECTION))
#define G_DTLS_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DTLS_CONNECTION, GDtlsConnection))
#define G_TYPE_DTLS_CONNECTION                (g_dtls_connection_get_type ())
#define G_DTLS_CLIENT_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnectionInterface))
#define G_IS_DTLS_CLIENT_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DTLS_CLIENT_CONNECTION))
#define G_DTLS_CLIENT_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnection))
#define G_TYPE_DTLS_CLIENT_CONNECTION                (g_dtls_client_connection_get_type ())
#define G_DRIVE_GET_IFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_DRIVE, GDriveIface))
#define G_IS_DRIVE(obj)        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_DRIVE))
#define G_DRIVE(obj)           (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_DRIVE, GDrive))
#define G_TYPE_DRIVE           (g_drive_get_type ())
#define G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME "gio-desktop-app-info-lookup"
#define G_DESKTOP_APP_INFO_LOOKUP_GET_IFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP, GDesktopAppInfoLookupIface))
#define G_IS_DESKTOP_APP_INFO_LOOKUP(obj)	 (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP))
#define G_DESKTOP_APP_INFO_LOOKUP(obj)           (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP, GDesktopAppInfoLookup))
#define G_TYPE_DESKTOP_APP_INFO_LOOKUP           (g_desktop_app_info_lookup_get_type ())
#define G_DESKTOP_APP_INFO_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfoClass))
#define G_IS_DESKTOP_APP_INFO_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DESKTOP_APP_INFO))
#define G_IS_DESKTOP_APP_INFO(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DESKTOP_APP_INFO))
#define G_DESKTOP_APP_INFO_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfoClass))
#define G_DESKTOP_APP_INFO(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfo))
#define G_TYPE_DESKTOP_APP_INFO         (g_desktop_app_info_get_type ())
#define G_IS_DBUS_SERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_SERVER))
#define G_DBUS_SERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_SERVER, GDBusServer))
#define G_TYPE_DBUS_SERVER         (g_dbus_server_get_type ())
#define G_IS_DBUS_PROXY_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_PROXY))
#define G_IS_DBUS_PROXY(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_PROXY))
#define G_DBUS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_PROXY, GDBusProxyClass))
#define G_DBUS_PROXY_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_PROXY, GDBusProxyClass))
#define G_DBUS_PROXY(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_PROXY, GDBusProxy))
#define G_TYPE_DBUS_PROXY         (g_dbus_proxy_get_type ())
#define G_IS_DBUS_OBJECT_SKELETON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_SKELETON))
#define G_IS_DBUS_OBJECT_SKELETON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_SKELETON))
#define G_DBUS_OBJECT_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass))
#define G_DBUS_OBJECT_SKELETON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass))
#define G_DBUS_OBJECT_SKELETON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeleton))
#define G_TYPE_DBUS_OBJECT_SKELETON         (g_dbus_object_skeleton_get_type ())
#define G_IS_DBUS_OBJECT_PROXY_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_PROXY))
#define G_IS_DBUS_OBJECT_PROXY(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_PROXY))
#define G_DBUS_OBJECT_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass))
#define G_DBUS_OBJECT_PROXY_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass))
#define G_DBUS_OBJECT_PROXY(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxy))
#define G_TYPE_DBUS_OBJECT_PROXY         (g_dbus_object_proxy_get_type ())
#define G_IS_DBUS_OBJECT_MANAGER_SERVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_MANAGER_SERVER))
#define G_IS_DBUS_OBJECT_MANAGER_SERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER))
#define G_DBUS_OBJECT_MANAGER_SERVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass))
#define G_DBUS_OBJECT_MANAGER_SERVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass))
#define G_DBUS_OBJECT_MANAGER_SERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServer))
#define G_TYPE_DBUS_OBJECT_MANAGER_SERVER         (g_dbus_object_manager_server_get_type ())
#define G_IS_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT))
#define G_IS_DBUS_OBJECT_MANAGER_CLIENT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT))
#define G_DBUS_OBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass))
#define G_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass))
#define G_DBUS_OBJECT_MANAGER_CLIENT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClient))
#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT         (g_dbus_object_manager_client_get_type ())
#define G_DBUS_OBJECT_MANAGER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManagerIface))
#define G_IS_DBUS_OBJECT_MANAGER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER))
#define G_DBUS_OBJECT_MANAGER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManager))
#define G_TYPE_DBUS_OBJECT_MANAGER         (g_dbus_object_manager_get_type())
#define G_DBUS_OBJECT_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_OBJECT, GDBusObjectIface))
#define G_IS_DBUS_OBJECT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT))
#define G_DBUS_OBJECT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT, GDBusObject))
#define G_TYPE_DBUS_OBJECT         (g_dbus_object_get_type())
#define G_IS_DBUS_METHOD_INVOCATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_METHOD_INVOCATION))
#define G_DBUS_METHOD_INVOCATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_METHOD_INVOCATION, GDBusMethodInvocation))
#define G_TYPE_DBUS_METHOD_INVOCATION         (g_dbus_method_invocation_get_type ())
#define G_IS_DBUS_MESSAGE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_MESSAGE))
#define G_DBUS_MESSAGE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_MESSAGE, GDBusMessage))
#define G_TYPE_DBUS_MESSAGE         (g_dbus_message_get_type ())
#define G_IS_DBUS_MENU_MODEL(inst)      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),   \
                                         G_TYPE_DBUS_MENU_MODEL))
#define G_DBUS_MENU_MODEL(inst)         (G_TYPE_CHECK_INSTANCE_CAST ((inst),   \
                                         G_TYPE_DBUS_MENU_MODEL, GDBusMenuModel))
#define G_TYPE_DBUS_MENU_MODEL          (g_dbus_menu_model_get_type ())
#define G_TYPE_DBUS_ANNOTATION_INFO (g_dbus_annotation_info_get_type ())
#define G_TYPE_DBUS_ARG_INFO        (g_dbus_arg_info_get_type ())
#define G_TYPE_DBUS_PROPERTY_INFO   (g_dbus_property_info_get_type ())
#define G_TYPE_DBUS_SIGNAL_INFO     (g_dbus_signal_info_get_type ())
#define G_TYPE_DBUS_METHOD_INFO     (g_dbus_method_info_get_type ())
#define G_TYPE_DBUS_INTERFACE_INFO  (g_dbus_interface_info_get_type ())
#define G_TYPE_DBUS_NODE_INFO       (g_dbus_node_info_get_type ())
#define G_IS_DBUS_INTERFACE_SKELETON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_INTERFACE_SKELETON))
#define G_IS_DBUS_INTERFACE_SKELETON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_INTERFACE_SKELETON))
#define G_DBUS_INTERFACE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass))
#define G_DBUS_INTERFACE_SKELETON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass))
#define G_DBUS_INTERFACE_SKELETON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeleton))
#define G_TYPE_DBUS_INTERFACE_SKELETON         (g_dbus_interface_skeleton_get_type ())
#define G_DBUS_INTERFACE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_INTERFACE, GDBusInterfaceIface))
#define G_IS_DBUS_INTERFACE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_INTERFACE))
#define G_DBUS_INTERFACE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_INTERFACE, GDBusInterface))
#define G_TYPE_DBUS_INTERFACE         (g_dbus_interface_get_type())
#define G_DBUS_ERROR g_dbus_error_quark()
#define G_IS_DBUS_CONNECTION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_CONNECTION))
#define G_DBUS_CONNECTION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_CONNECTION, GDBusConnection))
#define G_TYPE_DBUS_CONNECTION         (g_dbus_connection_get_type ())
#define G_IS_DBUS_AUTH_OBSERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_AUTH_OBSERVER))
#define G_DBUS_AUTH_OBSERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_AUTH_OBSERVER, GDBusAuthObserver))
#define G_TYPE_DBUS_AUTH_OBSERVER         (g_dbus_auth_observer_get_type ())
#define G_DBUS_ACTION_GROUP_GET_CLASS(inst)                 (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroupClass))
#define G_IS_DBUS_ACTION_GROUP_CLASS(class)                 (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_DBUS_ACTION_GROUP))
#define G_IS_DBUS_ACTION_GROUP(inst)                        (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_DBUS_ACTION_GROUP))
#define G_DBUS_ACTION_GROUP_CLASS(class)                    (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroupClass))
#define G_DBUS_ACTION_GROUP(inst)                           (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroup))
#define G_TYPE_DBUS_ACTION_GROUP                            (g_dbus_action_group_get_type ())
#define G_DATA_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass))
#define G_IS_DATA_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DATA_OUTPUT_STREAM))
#define G_IS_DATA_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DATA_OUTPUT_STREAM))
#define G_DATA_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass))
#define G_DATA_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStream))
#define G_TYPE_DATA_OUTPUT_STREAM         (g_data_output_stream_get_type ())
#define G_DATA_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass))
#define G_IS_DATA_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DATA_INPUT_STREAM))
#define G_IS_DATA_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DATA_INPUT_STREAM))
#define G_DATA_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass))
#define G_DATA_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DATA_INPUT_STREAM, GDataInputStream))
#define G_TYPE_DATA_INPUT_STREAM         (g_data_input_stream_get_type ())
#define G_TYPE_IS_DATAGRAM_BASED(type)    (g_type_is_a ((type), \
                                           G_TYPE_DATAGRAM_BASED))
#define G_DATAGRAM_BASED_GET_IFACE(inst)  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), \
                                           G_TYPE_DATAGRAM_BASED, \
                                           GDatagramBasedInterface))
#define G_IS_DATAGRAM_BASED(inst)         (G_TYPE_CHECK_INSTANCE_TYPE ((inst), \
                                           G_TYPE_DATAGRAM_BASED))
#define G_DATAGRAM_BASED(inst)            (G_TYPE_CHECK_INSTANCE_CAST ((inst), \
                                           G_TYPE_DATAGRAM_BASED, GDatagramBased))
#define G_TYPE_DATAGRAM_BASED             (g_datagram_based_get_type ())
#define G_IS_CREDENTIALS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CREDENTIALS))
#define G_IS_CREDENTIALS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CREDENTIALS))
#define G_CREDENTIALS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CREDENTIALS, GCredentialsClass))
#define G_CREDENTIALS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CREDENTIALS, GCredentialsClass))
#define G_CREDENTIALS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CREDENTIALS, GCredentials))
#define G_TYPE_CREDENTIALS         (g_credentials_get_type ())
#define G_CONVERTER_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass))
#define G_IS_CONVERTER_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CONVERTER_OUTPUT_STREAM))
#define G_IS_CONVERTER_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CONVERTER_OUTPUT_STREAM))
#define G_CONVERTER_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass))
#define G_CONVERTER_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStream))
#define G_TYPE_CONVERTER_OUTPUT_STREAM         (g_converter_output_stream_get_type ())
#define G_CONVERTER_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass))
#define G_IS_CONVERTER_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CONVERTER_INPUT_STREAM))
#define G_IS_CONVERTER_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CONVERTER_INPUT_STREAM))
#define G_CONVERTER_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass))
#define G_CONVERTER_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStream))
#define G_TYPE_CONVERTER_INPUT_STREAM         (g_converter_input_stream_get_type ())
#define G_CONVERTER_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_CONVERTER, GConverterIface))
#define G_IS_CONVERTER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_CONVERTER))
#define G_CONVERTER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_CONVERTER, GConverter))
#define G_TYPE_CONVERTER            (g_converter_get_type ())
#define G_CHARSET_CONVERTER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass))
#define G_IS_CHARSET_CONVERTER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CHARSET_CONVERTER))
#define G_IS_CHARSET_CONVERTER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CHARSET_CONVERTER))
#define G_CHARSET_CONVERTER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass))
#define G_CHARSET_CONVERTER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CHARSET_CONVERTER, GCharsetConverter))
#define G_TYPE_CHARSET_CONVERTER         (g_charset_converter_get_type ())
#define G_CANCELLABLE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CANCELLABLE, GCancellableClass))
#define G_IS_CANCELLABLE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CANCELLABLE))
#define G_IS_CANCELLABLE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CANCELLABLE))
#define G_CANCELLABLE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CANCELLABLE, GCancellableClass))
#define G_CANCELLABLE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CANCELLABLE, GCancellable))
#define G_TYPE_CANCELLABLE         (g_cancellable_get_type ())
#define G_IS_BYTES_ICON(inst)     (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_BYTES_ICON))
#define G_BYTES_ICON(inst)        (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_BYTES_ICON, GBytesIcon))
#define G_TYPE_BYTES_ICON         (g_bytes_icon_get_type ())
#define G_BUFFERED_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass))
#define G_IS_BUFFERED_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_BUFFERED_OUTPUT_STREAM))
#define G_IS_BUFFERED_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_BUFFERED_OUTPUT_STREAM))
#define G_BUFFERED_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass))
#define G_BUFFERED_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStream))
#define G_TYPE_BUFFERED_OUTPUT_STREAM         (g_buffered_output_stream_get_type ())
#define G_BUFFERED_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass))
#define G_IS_BUFFERED_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_BUFFERED_INPUT_STREAM))
#define G_IS_BUFFERED_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_BUFFERED_INPUT_STREAM))
#define G_BUFFERED_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass))
#define G_BUFFERED_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStream))
#define G_TYPE_BUFFERED_INPUT_STREAM         (g_buffered_input_stream_get_type ())
#define G_ASYNC_RESULT_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ASYNC_RESULT, GAsyncResultIface))
#define G_IS_ASYNC_RESULT(obj)	       (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ASYNC_RESULT))
#define G_ASYNC_RESULT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ASYNC_RESULT, GAsyncResult))
#define G_TYPE_ASYNC_RESULT            (g_async_result_get_type ())
#define G_TYPE_IS_ASYNC_INITABLE(type)   (g_type_is_a ((type), G_TYPE_ASYNC_INITABLE))
#define G_ASYNC_INITABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ASYNC_INITABLE, GAsyncInitableIface))
#define G_IS_ASYNC_INITABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ASYNC_INITABLE))
#define G_ASYNC_INITABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ASYNC_INITABLE, GAsyncInitable))
#define G_TYPE_ASYNC_INITABLE            (g_async_initable_get_type ())
#define G_APPLICATION_COMMAND_LINE_GET_CLASS(inst)          (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_APPLICATION_COMMAND_LINE,                        \
                                                             GApplicationCommandLineClass))
#define G_IS_APPLICATION_COMMAND_LINE_CLASS(class)          (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_APPLICATION_COMMAND_LINE))
#define G_IS_APPLICATION_COMMAND_LINE(inst)                 (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_APPLICATION_COMMAND_LINE))
#define G_APPLICATION_COMMAND_LINE_CLASS(class)             (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_APPLICATION_COMMAND_LINE,                        \
                                                             GApplicationCommandLineClass))
#define G_APPLICATION_COMMAND_LINE(inst)                    (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_APPLICATION_COMMAND_LINE,                        \
                                                             GApplicationCommandLine))
#define G_TYPE_APPLICATION_COMMAND_LINE                     (g_application_command_line_get_type ())
#define G_APPLICATION_GET_CLASS(inst)                       (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_APPLICATION, GApplicationClass))
#define G_IS_APPLICATION_CLASS(class)                       (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_APPLICATION))
#define G_IS_APPLICATION(inst)                              (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_APPLICATION))
#define G_APPLICATION_CLASS(class)                          (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_APPLICATION, GApplicationClass))
#define G_APPLICATION(inst)                                 (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_APPLICATION, GApplication))
#define G_TYPE_APPLICATION                                  (g_application_get_type ())
#define G_IS_APP_INFO_MONITOR(inst)                         (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_APP_INFO_MONITOR))
#define G_APP_INFO_MONITOR(inst)                            (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_APP_INFO_MONITOR, GAppInfoMonitor))
#define G_TYPE_APP_INFO_MONITOR                             (g_app_info_monitor_get_type ())
#define G_APP_LAUNCH_CONTEXT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))
#define G_IS_APP_LAUNCH_CONTEXT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_APP_LAUNCH_CONTEXT))
#define G_IS_APP_LAUNCH_CONTEXT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_APP_LAUNCH_CONTEXT))
#define G_APP_LAUNCH_CONTEXT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))
#define G_APP_LAUNCH_CONTEXT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContext))
#define G_TYPE_APP_LAUNCH_CONTEXT         (g_app_launch_context_get_type ())
#define G_APP_INFO_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_APP_INFO, GAppInfoIface))
#define G_IS_APP_INFO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_APP_INFO))
#define G_APP_INFO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_APP_INFO, GAppInfo))
#define G_TYPE_APP_INFO            (g_app_info_get_type ())
#define G_ACTION_MAP_GET_IFACE(inst)                        (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                   \
                                                             G_TYPE_ACTION_MAP, GActionMapInterface))
#define G_IS_ACTION_MAP(inst)                               (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                      \
                                                             G_TYPE_ACTION_MAP))
#define G_ACTION_MAP(inst)                                  (G_TYPE_CHECK_INSTANCE_CAST ((inst),                      \
                                                             G_TYPE_ACTION_MAP, GActionMap))
#define G_TYPE_ACTION_MAP                                   (g_action_map_get_type ())
#define G_ACTION_GROUP_GET_IFACE(inst)                      (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                  \
                                                             G_TYPE_ACTION_GROUP, GActionGroupInterface))
#define G_IS_ACTION_GROUP(inst)                             (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_ACTION_GROUP))
#define G_ACTION_GROUP(inst)                                (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_ACTION_GROUP, GActionGroup))
#define G_TYPE_ACTION_GROUP                                 (g_action_group_get_type ())
#define G_ACTION_GET_IFACE(inst)                            (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                  \
                                                             G_TYPE_ACTION, GActionInterface))
#define G_IS_ACTION(inst)                                   (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_ACTION))
#define G_ACTION(inst)                                      (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_ACTION, GAction))
#define G_TYPE_ACTION                                       (g_action_get_type ())
typedef struct __GXdpProxyResolverSkeletonPrivate GXdpProxyResolverSkeletonPrivate;
typedef struct __GXdpProxyResolverProxyPrivate GXdpProxyResolverProxyPrivate;
typedef struct __GXdpProxyResolver GXdpProxyResolver;
typedef struct __GXdpOpenURISkeletonPrivate GXdpOpenURISkeletonPrivate;
typedef struct __GXdpOpenURIProxyPrivate GXdpOpenURIProxyPrivate;
typedef struct __GXdpOpenURI GXdpOpenURI;
typedef struct __GXdpNetworkMonitorSkeletonPrivate GXdpNetworkMonitorSkeletonPrivate;
typedef struct __GXdpNetworkMonitorProxyPrivate GXdpNetworkMonitorProxyPrivate;
typedef struct __GXdpNetworkMonitor GXdpNetworkMonitor;
typedef struct __GXdpDocumentsSkeletonPrivate GXdpDocumentsSkeletonPrivate;
typedef struct __GXdpDocumentsProxyPrivate GXdpDocumentsProxyPrivate;
typedef struct __GXdpDocuments GXdpDocuments;
typedef struct _GXdpProxyResolverSkeletonClass GXdpProxyResolverSkeletonClass;
typedef struct _GXdpProxyResolverSkeleton GXdpProxyResolverSkeleton;
typedef struct _GXdpProxyResolverProxyClass GXdpProxyResolverProxyClass;
typedef struct _GXdpProxyResolverProxy GXdpProxyResolverProxy;
typedef struct _GXdpProxyResolverIface GXdpProxyResolverIface;
typedef struct _GXdpNetworkMonitorSkeletonClass GXdpNetworkMonitorSkeletonClass;
typedef struct _GXdpNetworkMonitorSkeleton GXdpNetworkMonitorSkeleton;
typedef struct _GXdpNetworkMonitorProxyClass GXdpNetworkMonitorProxyClass;
typedef struct _GXdpNetworkMonitorProxy GXdpNetworkMonitorProxy;
typedef struct _GXdpNetworkMonitorIface GXdpNetworkMonitorIface;
typedef struct _GXdpOpenURISkeletonClass GXdpOpenURISkeletonClass;
typedef struct _GXdpOpenURISkeleton GXdpOpenURISkeleton;
typedef struct _GXdpOpenURIProxyClass GXdpOpenURIProxyClass;
typedef struct _GXdpOpenURIProxy GXdpOpenURIProxy;
typedef struct _GXdpOpenURIIface GXdpOpenURIIface;
typedef struct _GXdpDocumentsSkeletonClass GXdpDocumentsSkeletonClass;
typedef struct _GXdpDocumentsSkeleton GXdpDocumentsSkeleton;
typedef struct _GXdpDocumentsProxyClass GXdpDocumentsProxyClass;
typedef struct _GXdpDocumentsProxy GXdpDocumentsProxy;
typedef struct _GXdpDocumentsIface GXdpDocumentsIface;
typedef struct _GZlibDecompressorClass GZlibDecompressorClass;
typedef struct _GZlibCompressorClass GZlibCompressorClass;
typedef struct __GWin32RegistryKeyPrivate GWin32RegistryKeyPrivate;
typedef struct _GWin32RegistryValueIter GWin32RegistryValueIter;
typedef struct _GWin32RegistrySubkeyIter GWin32RegistrySubkeyIter;
typedef struct _GWin32RegistryKeyClass GWin32RegistryKeyClass;
typedef struct _GWin32RegistryKey GWin32RegistryKey;
typedef struct __GWin32OutputStreamPrivate GWin32OutputStreamPrivate;
typedef struct _GWin32OutputStreamClass GWin32OutputStreamClass;
typedef struct _GWin32OutputStream GWin32OutputStream;
typedef struct __GWin32NetworkMonitorPrivate GWin32NetworkMonitorPrivate;
typedef struct _GWin32NetworkMonitorClass GWin32NetworkMonitorClass;
typedef struct _GWin32NetworkMonitor GWin32NetworkMonitor;
typedef struct __GWin32InputStreamPrivate GWin32InputStreamPrivate;
typedef struct _GWin32InputStreamClass GWin32InputStreamClass;
typedef struct _GWin32InputStream GWin32InputStream;
typedef struct _GVolumeMonitorClass GVolumeMonitorClass;
typedef struct _GVolumeMonitor GVolumeMonitor;
typedef struct _GVolumeIface GVolumeIface;
typedef struct _GVfsClass GVfsClass;
typedef struct _GVfs GVfs;
typedef struct __GUnixSocketAddressPrivate GUnixSocketAddressPrivate;
typedef struct _GUnixSocketAddressClass GUnixSocketAddressClass;
typedef struct _GUnixSocketAddress GUnixSocketAddress;
typedef struct __GUnixOutputStreamPrivate GUnixOutputStreamPrivate;
typedef struct _GUnixOutputStreamClass GUnixOutputStreamClass;
typedef struct _GUnixOutputStream GUnixOutputStream;
typedef struct __GUnixMountPoint GUnixMountPoint;
typedef struct __GUnixMountMonitorClass GUnixMountMonitorClass;
typedef struct __GUnixMountMonitor GUnixMountMonitor;
typedef struct __GUnixMountEntry GUnixMountEntry;
typedef struct __GUnixInputStreamPrivate GUnixInputStreamPrivate;
typedef struct _GUnixInputStreamClass GUnixInputStreamClass;
typedef struct _GUnixInputStream GUnixInputStream;
typedef struct __GUnixFDMessagePrivate GUnixFDMessagePrivate;
typedef struct _GUnixFDMessage GUnixFDMessage;
typedef struct _GUnixFDMessageClass GUnixFDMessageClass;
typedef struct __GUnixFDListPrivate GUnixFDListPrivate;
typedef struct _GUnixFDList GUnixFDList;
typedef struct _GUnixFDListClass GUnixFDListClass;
typedef struct __GUnixCredentialsMessagePrivate GUnixCredentialsMessagePrivate;
typedef struct _GUnixCredentialsMessage GUnixCredentialsMessage;
typedef struct _GUnixCredentialsMessageClass GUnixCredentialsMessageClass;
typedef struct __GUnixConnectionPrivate GUnixConnectionPrivate;
typedef struct _GUnixConnection GUnixConnection;
typedef struct _GUnixConnectionClass GUnixConnectionClass;
typedef struct _GTlsServerConnectionInterface GTlsServerConnectionInterface;
typedef struct __GTlsPasswordPrivate GTlsPasswordPrivate;
typedef struct _GTlsPasswordClass GTlsPasswordClass;
typedef struct _GTlsPassword GTlsPassword;
typedef struct __GTlsInteractionPrivate GTlsInteractionPrivate;
typedef struct _GTlsInteractionClass GTlsInteractionClass;
typedef struct _GTlsInteraction GTlsInteraction;
typedef struct _GTlsFileDatabaseInterface GTlsFileDatabaseInterface;
typedef struct __GTlsDatabasePrivate GTlsDatabasePrivate;
typedef struct _GTlsDatabaseClass GTlsDatabaseClass;
typedef struct _GTlsDatabase GTlsDatabase;
typedef struct __GTlsConnectionPrivate GTlsConnectionPrivate;
typedef struct _GTlsConnectionClass GTlsConnectionClass;
typedef struct _GTlsConnection GTlsConnection;
typedef struct _GTlsClientConnectionInterface GTlsClientConnectionInterface;
typedef struct __GTlsCertificatePrivate GTlsCertificatePrivate;
typedef struct _GTlsCertificateClass GTlsCertificateClass;
typedef struct _GTlsCertificate GTlsCertificate;
typedef struct __GTlsBackend GTlsBackend;
typedef struct _GTlsBackendInterface GTlsBackendInterface;
typedef struct __GThreadedSocketServicePrivate GThreadedSocketServicePrivate;
typedef struct _GThreadedSocketService GThreadedSocketService;
typedef struct _GThreadedSocketServiceClass GThreadedSocketServiceClass;
typedef struct __GThemedIconClass GThemedIconClass;
typedef struct __GTcpWrapperConnectionPrivate GTcpWrapperConnectionPrivate;
typedef struct _GTcpWrapperConnection GTcpWrapperConnection;
typedef struct _GTcpWrapperConnectionClass GTcpWrapperConnectionClass;
typedef struct __GTcpConnectionPrivate GTcpConnectionPrivate;
typedef struct _GTcpConnection GTcpConnection;
typedef struct _GTcpConnectionClass GTcpConnectionClass;
typedef struct __GTaskClass GTaskClass;
typedef struct __GSocketServicePrivate GSocketServicePrivate;
typedef struct _GSocketService GSocketService;
typedef struct _GSocketServiceClass GSocketServiceClass;
typedef struct __GSocketListenerPrivate GSocketListenerPrivate;
typedef struct _GSocketListener GSocketListener;
typedef struct _GSocketListenerClass GSocketListenerClass;
typedef struct __GSocketControlMessagePrivate GSocketControlMessagePrivate;
typedef struct _GSocketControlMessage GSocketControlMessage;
typedef struct _GSocketControlMessageClass GSocketControlMessageClass;
typedef struct __GSocketConnectionPrivate GSocketConnectionPrivate;
typedef struct _GSocketConnection GSocketConnection;
typedef struct _GSocketConnectionClass GSocketConnectionClass;
typedef struct _GSocketConnectableIface GSocketConnectableIface;
typedef struct __GSocketClientPrivate GSocketClientPrivate;
typedef struct _GSocketClient GSocketClient;
typedef struct _GSocketClientClass GSocketClientClass;
typedef struct _GSocketAddressEnumeratorClass GSocketAddressEnumeratorClass;
typedef struct _GSocketAddressEnumerator GSocketAddressEnumerator;
typedef struct _GSocketAddressClass GSocketAddressClass;
typedef struct _GSocketAddress GSocketAddress;
typedef struct __GSocketPrivate GSocketPrivate;
typedef struct _GSocket GSocket;
typedef struct _GSocketClass GSocketClass;
typedef struct __GSimpleProxyResolverPrivate GSimpleProxyResolverPrivate;
typedef struct _GSimpleProxyResolverClass GSimpleProxyResolverClass;
typedef struct _GSimpleProxyResolver GSimpleProxyResolver;
typedef struct __GSimpleAsyncResultClass GSimpleAsyncResultClass;
typedef struct __GSimpleActionGroupPrivate GSimpleActionGroupPrivate;
typedef struct _GSimpleActionGroupClass GSimpleActionGroupClass;
typedef struct _GSimpleActionGroup GSimpleActionGroup;
typedef struct __GSettingsSchemaSource GSettingsSchemaSource;
typedef struct __GSettingsSchemaKey GSettingsSchemaKey;
typedef struct __GSettingsSchema GSettingsSchema;
typedef struct __GSettingsBackendPrivate GSettingsBackendPrivate;
typedef struct _GSettingsBackend GSettingsBackend;
typedef struct _GSettingsBackendClass GSettingsBackendClass;
typedef struct __GSettingsPrivate GSettingsPrivate;
typedef struct _GSettings GSettings;
typedef struct _GSettingsClass GSettingsClass;
typedef struct _GSeekableIface GSeekableIface;
typedef struct _GStaticResource GStaticResource;
typedef struct __GResolverPrivate GResolverPrivate;
typedef struct _GResolverClass GResolverClass;
typedef struct _GResolver GResolver;
typedef struct _GRemoteActionGroupInterface GRemoteActionGroupInterface;
typedef struct __GProxyResolverPortal GProxyResolverPortal;
typedef struct _GProxyResolverPortalClass GProxyResolverPortalClass;
typedef struct _GProxyResolverInterface GProxyResolverInterface;
typedef struct __GProxyAddressEnumeratorPrivate GProxyAddressEnumeratorPrivate;
typedef struct _GProxyAddressEnumeratorClass GProxyAddressEnumeratorClass;
typedef struct _GProxyAddressEnumerator GProxyAddressEnumerator;
typedef struct __GProxyAddressPrivate GProxyAddressPrivate;
typedef struct _GProxyAddressClass GProxyAddressClass;
typedef struct _GProxyAddress GProxyAddress;
typedef struct _GProxyInterface GProxyInterface;
typedef struct _GPollableOutputStreamInterface GPollableOutputStreamInterface;
typedef struct _GPollableInputStreamInterface GPollableInputStreamInterface;
typedef struct __GPermissionPrivate GPermissionPrivate;
typedef struct _GPermissionClass GPermissionClass;
typedef struct _GPermission GPermission;
typedef struct __GOutputStreamPrivate GOutputStreamPrivate;
typedef struct _GOutputStreamClass GOutputStreamClass;
typedef struct _GOutputStream GOutputStream;
typedef struct __GOsxAppInfo GOsxAppInfo;
typedef struct _GOsxAppInfoClass GOsxAppInfoClass;
typedef struct __GNetworkServicePrivate GNetworkServicePrivate;
typedef struct _GNetworkServiceClass GNetworkServiceClass;
typedef struct _GNetworkService GNetworkService;
typedef struct __GNetworkMonitorPortalPrivate GNetworkMonitorPortalPrivate;
typedef struct _GNetworkMonitorPortalClass GNetworkMonitorPortalClass;
typedef struct _GNetworkMonitorPortal GNetworkMonitorPortal;
typedef struct _GNetworkMonitorInterface GNetworkMonitorInterface;
typedef struct __GNetworkAddressPrivate GNetworkAddressPrivate;
typedef struct _GNetworkAddressClass GNetworkAddressClass;
typedef struct _GNetworkAddress GNetworkAddress;
typedef struct __GNativeSocketAddressPrivate GNativeSocketAddressPrivate;
typedef struct _GNativeSocketAddressClass GNativeSocketAddressClass;
typedef struct _GNativeSocketAddress GNativeSocketAddress;
typedef struct __GMountOperationPrivate GMountOperationPrivate;
typedef struct _GMountOperationClass GMountOperationClass;
typedef struct _GMountOperation GMountOperation;
typedef struct _GMountIface GMountIface;
typedef struct __GMenuModelPrivate GMenuModelPrivate;
typedef struct __GMenuLinkIterPrivate GMenuLinkIterPrivate;
typedef struct __GMenuAttributeIterPrivate GMenuAttributeIterPrivate;
typedef struct _GMenuLinkIterClass GMenuLinkIterClass;
typedef struct _GMenuLinkIter GMenuLinkIter;
typedef struct _GMenuAttributeIterClass GMenuAttributeIterClass;
typedef struct _GMenuAttributeIter GMenuAttributeIter;
typedef struct _GMenuModelClass GMenuModelClass;
typedef struct _GMenuModel GMenuModel;
typedef struct __GMenuItem GMenuItem;
typedef struct __GMenu GMenu;
typedef struct __GMemoryOutputStreamPrivate GMemoryOutputStreamPrivate;
typedef struct _GMemoryOutputStreamClass GMemoryOutputStreamClass;
typedef struct _GMemoryOutputStream GMemoryOutputStream;
typedef struct __GMemoryInputStreamPrivate GMemoryInputStreamPrivate;
typedef struct _GMemoryInputStreamClass GMemoryInputStreamClass;
typedef struct _GMemoryInputStream GMemoryInputStream;
typedef struct _GLoadableIconIface GLoadableIconIface;
typedef struct __GListStore GListStore;
typedef struct __GListModel GListModel;
typedef struct _GListModelInterface GListModelInterface;
typedef struct __GZlibDecompressor GZlibDecompressor;
typedef struct __GZlibCompressor GZlibCompressor;
typedef struct __GVolume GVolume;
typedef struct __GTlsServerConnection GTlsServerConnection;
typedef struct __GTlsFileDatabase GTlsFileDatabase;
typedef struct __GTlsClientConnection GTlsClientConnection;
typedef struct __GThemedIcon GThemedIcon;
typedef struct __GTestDBus GTestDBus;
typedef struct __GTask GTask;
typedef struct __GSubprocessLauncher GSubprocessLauncher;
typedef struct __GSubprocess GSubprocess;
typedef struct __GSrvTarget GSrvTarget;
typedef struct __GSocketConnectable GSocketConnectable;
typedef struct __GSimplePermission GSimplePermission;
typedef struct __GSimpleIOStream GSimpleIOStream;
typedef struct __GSimpleAsyncResult GSimpleAsyncResult;
typedef struct __GSimpleAction GSimpleAction;
typedef struct __GSeekable GSeekable;
typedef struct __GResource GResource;
typedef struct __GRemoteActionGroup GRemoteActionGroup;
typedef struct __GProxyResolver GProxyResolver;
typedef struct __GProxy GProxy;
typedef struct __GPropertyAction GPropertyAction;
typedef struct __GPollableOutputStream GPollableOutputStream;
typedef struct __GPollableInputStream GPollableInputStream;
typedef struct __GNotification GNotification;
typedef struct __GNetworkMonitor GNetworkMonitor;
typedef struct __GMount GMount;
typedef struct __GLoadableIcon GLoadableIcon;
typedef struct __GInitable GInitable;
typedef struct __GIcon GIcon;
typedef struct __GIOStreamAdapter GIOStreamAdapter;
typedef struct __GIOSchedulerJob GIOSchedulerJob;
typedef struct __GIOModule GIOModule;
typedef struct __GIOExtensionPoint GIOExtensionPoint;
typedef struct __GIOExtension GIOExtension;
typedef struct __GFilenameCompleter GFilenameCompleter;
typedef struct __GFileInfo GFileInfo;
typedef struct __GFileIcon GFileIcon;
typedef struct __GFileDescriptorBased GFileDescriptorBased;
typedef struct __GFileAttributeMatcher GFileAttributeMatcher;
typedef struct __GFile GFile;
typedef struct __GDtlsServerConnection GDtlsServerConnection;
typedef struct __GDtlsConnection GDtlsConnection;
typedef struct __GDtlsClientConnection GDtlsClientConnection;
typedef struct __GDrive GDrive;
typedef struct __GDatagramBased GDatagramBased;
typedef struct __GDBusServer GDBusServer;
typedef struct __GDBusObjectManager GDBusObjectManager;
typedef struct __GDBusObject GDBusObject;
typedef struct __GDBusMethodInvocation GDBusMethodInvocation;
typedef struct __GDBusMessage GDBusMessage;
typedef struct __GDBusInterface GDBusInterface;
typedef struct __GDBusConnection GDBusConnection;
typedef struct __GDBusAuthObserver GDBusAuthObserver;
typedef struct __GDBusActionGroup GDBusActionGroup;
typedef struct __GCredentials GCredentials;
typedef struct __GConverter GConverter;
typedef struct __GCharsetConverter GCharsetConverter;
typedef struct __GBytesIcon GBytesIcon;
typedef struct __GAsyncResult GAsyncResult;
typedef struct __GAsyncInitable GAsyncInitable;
typedef struct __GAppInfo GAppInfo;
typedef struct __GActionMap GActionMap;
typedef struct __GActionGroup GActionGroup;
typedef struct __GAction GAction;
typedef struct _GOutputMessage GOutputMessage;
typedef struct _GOutputVector GOutputVector;
typedef struct _GInputMessage GInputMessage;
typedef struct _GInputVector GInputVector;
typedef struct __GIOStreamPrivate GIOStreamPrivate;
typedef struct _GIOStreamClass GIOStreamClass;
typedef struct _GIOStream GIOStream;
typedef struct __GIOModuleScope GIOModuleScope;
typedef struct __GIOModuleClass GIOModuleClass;
typedef struct __GInputStreamPrivate GInputStreamPrivate;
typedef struct _GInputStreamClass GInputStreamClass;
typedef struct _GInputStream GInputStream;
typedef struct _GInitableIface GInitableIface;
typedef struct __GInetSocketAddressPrivate GInetSocketAddressPrivate;
typedef struct _GInetSocketAddressClass GInetSocketAddressClass;
typedef struct _GInetSocketAddress GInetSocketAddress;
typedef struct __GInetAddressMaskPrivate GInetAddressMaskPrivate;
typedef struct _GInetAddressMaskClass GInetAddressMaskClass;
typedef struct _GInetAddressMask GInetAddressMask;
typedef struct __GInetAddressPrivate GInetAddressPrivate;
typedef struct _GInetAddressClass GInetAddressClass;
typedef struct _GInetAddress GInetAddress;
typedef struct _GIconIface GIconIface;
typedef struct _GFilterOutputStreamClass GFilterOutputStreamClass;
typedef struct _GFilterOutputStream GFilterOutputStream;
typedef struct _GFilterInputStreamClass GFilterInputStreamClass;
typedef struct _GFilterInputStream GFilterInputStream;
typedef struct __GFileOutputStreamPrivate GFileOutputStreamPrivate;
typedef struct _GFileOutputStreamClass GFileOutputStreamClass;
typedef struct _GFileOutputStream GFileOutputStream;
typedef struct _GFilenameCompleterClass GFilenameCompleterClass;
typedef struct __GFileMonitorPrivate GFileMonitorPrivate;
typedef struct _GFileMonitorClass GFileMonitorClass;
typedef struct _GFileMonitor GFileMonitor;
typedef struct __GFileIOStreamPrivate GFileIOStreamPrivate;
typedef struct _GFileIOStreamClass GFileIOStreamClass;
typedef struct _GFileIOStream GFileIOStream;
typedef struct __GFileInputStreamPrivate GFileInputStreamPrivate;
typedef struct _GFileInputStreamClass GFileInputStreamClass;
typedef struct _GFileInputStream GFileInputStream;
typedef struct __GFileInfoClass GFileInfoClass;
typedef struct __GFileIconClass GFileIconClass;
typedef struct __GFileEnumeratorPrivate GFileEnumeratorPrivate;
typedef struct _GFileEnumeratorClass GFileEnumeratorClass;
typedef struct _GFileEnumerator GFileEnumerator;
typedef struct _GFileDescriptorBasedIface GFileDescriptorBasedIface;
typedef struct _GFileAttributeInfoList GFileAttributeInfoList;
typedef struct _GFileAttributeInfo GFileAttributeInfo;
typedef struct __GFile GFile;
typedef struct _GFileIface GFileIface;
typedef struct __GEmblemedIconPrivate GEmblemedIconPrivate;
typedef struct _GEmblemedIconClass GEmblemedIconClass;
typedef struct _GEmblemedIcon GEmblemedIcon;
typedef struct __GEmblemClass GEmblemClass;
typedef struct __GEmblem GEmblem;
typedef struct _GDtlsServerConnectionInterface GDtlsServerConnectionInterface;
typedef struct _GDtlsConnectionInterface GDtlsConnectionInterface;
typedef struct _GDtlsClientConnectionInterface GDtlsClientConnectionInterface;
typedef struct _GDriveIface GDriveIface;
typedef struct __GDesktopAppInfoLookup GDesktopAppInfoLookup;
typedef struct __GDesktopAppInfo GDesktopAppInfo;
typedef struct _GDesktopAppInfoLookupIface GDesktopAppInfoLookupIface;
typedef struct _GDesktopAppInfoClass GDesktopAppInfoClass;
typedef struct __GDBusProxyPrivate GDBusProxyPrivate;
typedef struct _GDBusProxyClass GDBusProxyClass;
typedef struct _GDBusProxy GDBusProxy;
typedef struct __GDBusObjectSkeletonPrivate GDBusObjectSkeletonPrivate;
typedef struct _GDBusObjectSkeletonClass GDBusObjectSkeletonClass;
typedef struct _GDBusObjectSkeleton GDBusObjectSkeleton;
typedef struct __GDBusObjectProxyPrivate GDBusObjectProxyPrivate;
typedef struct _GDBusObjectProxyClass GDBusObjectProxyClass;
typedef struct _GDBusObjectProxy GDBusObjectProxy;
typedef struct __GDBusObjectManagerServerPrivate GDBusObjectManagerServerPrivate;
typedef struct _GDBusObjectManagerServerClass GDBusObjectManagerServerClass;
typedef struct _GDBusObjectManagerServer GDBusObjectManagerServer;
typedef struct __GDBusObjectManagerClientPrivate GDBusObjectManagerClientPrivate;
typedef struct _GDBusObjectManagerClientClass GDBusObjectManagerClientClass;
typedef struct _GDBusObjectManagerClient GDBusObjectManagerClient;
typedef struct _GDBusObjectManagerIface GDBusObjectManagerIface;
typedef struct _GDBusObjectIface GDBusObjectIface;
typedef struct __GDBusMenuModel GDBusMenuModel;
typedef struct _GDBusNodeInfo GDBusNodeInfo;
typedef struct _GDBusInterfaceInfo GDBusInterfaceInfo;
typedef struct _GDBusPropertyInfo GDBusPropertyInfo;
typedef struct _GDBusSignalInfo GDBusSignalInfo;
typedef struct _GDBusMethodInfo GDBusMethodInfo;
typedef struct _GDBusArgInfo GDBusArgInfo;
typedef struct _GDBusAnnotationInfo GDBusAnnotationInfo;
typedef struct __GDBusInterfaceSkeletonPrivate GDBusInterfaceSkeletonPrivate;
typedef struct _GDBusInterfaceSkeletonClass GDBusInterfaceSkeletonClass;
typedef struct _GDBusInterfaceSkeleton GDBusInterfaceSkeleton;
typedef struct _GDBusInterfaceIface GDBusInterfaceIface;
typedef struct _GDBusErrorEntry GDBusErrorEntry;
typedef struct _GDBusSubtreeVTable GDBusSubtreeVTable;
typedef struct _GDBusInterfaceVTable GDBusInterfaceVTable;
typedef struct __GDataOutputStreamPrivate GDataOutputStreamPrivate;
typedef struct _GDataOutputStreamClass GDataOutputStreamClass;
typedef struct _GDataOutputStream GDataOutputStream;
typedef struct __GDataInputStreamPrivate GDataInputStreamPrivate;
typedef struct _GDataInputStreamClass GDataInputStreamClass;
typedef struct _GDataInputStream GDataInputStream;
typedef struct _GDatagramBasedInterface GDatagramBasedInterface;
typedef struct __GCredentialsClass GCredentialsClass;
typedef struct __GConverterOutputStreamPrivate GConverterOutputStreamPrivate;
typedef struct _GConverterOutputStreamClass GConverterOutputStreamClass;
typedef struct _GConverterOutputStream GConverterOutputStream;
typedef struct __GConverterInputStreamPrivate GConverterInputStreamPrivate;
typedef struct _GConverterInputStreamClass GConverterInputStreamClass;
typedef struct _GConverterInputStream GConverterInputStream;
typedef struct _GConverterIface GConverterIface;
typedef struct _GCharsetConverterClass GCharsetConverterClass;
typedef struct __GCancellablePrivate GCancellablePrivate;
typedef struct _GCancellableClass GCancellableClass;
typedef struct _GCancellable GCancellable;
typedef struct __GBufferedOutputStreamPrivate GBufferedOutputStreamPrivate;
typedef struct _GBufferedOutputStreamClass GBufferedOutputStreamClass;
typedef struct _GBufferedOutputStream GBufferedOutputStream;
typedef struct __GBufferedInputStreamPrivate GBufferedInputStreamPrivate;
typedef struct _GBufferedInputStreamClass GBufferedInputStreamClass;
typedef struct _GBufferedInputStream GBufferedInputStream;
typedef struct _GAsyncResultIface GAsyncResultIface;
typedef struct _GAsyncInitableIface GAsyncInitableIface;
typedef struct __GApplicationCommandLinePrivate GApplicationCommandLinePrivate;
typedef struct _GApplicationCommandLineClass GApplicationCommandLineClass;
typedef struct _GApplicationCommandLine GApplicationCommandLine;
typedef struct __GApplicationPrivate GApplicationPrivate;
typedef struct _GApplicationClass GApplicationClass;
typedef struct _GApplication GApplication;
typedef struct __GAppLaunchContextPrivate GAppLaunchContextPrivate;
typedef struct __GAppInfoMonitor GAppInfoMonitor;
typedef struct _GAppLaunchContextClass GAppLaunchContextClass;
typedef struct _GAppLaunchContext GAppLaunchContext;
typedef struct _GAppInfoIface GAppInfoIface;
typedef struct _GActionEntry GActionEntry;
typedef struct _GActionMapInterface GActionMapInterface;
typedef struct _GActionGroupInterface GActionGroupInterface;
typedef struct _GActionInterface GActionInterface;
typedef void (*GWin32RegistryKeyWatchCallbackFunc) (GWin32RegistryKey  *key,
                                                    gpointer            user_data);
typedef GFile * (*GVfsFileLookupFunc) (GVfs       *vfs,
                                        const char *identifier,
                                        gpointer    user_data);
typedef void (*GTaskThreadFunc) (GTask           *task,
                                           gpointer         source_object,
                                           gpointer         task_data,
                                           GCancellable    *cancellable);
typedef gboolean (*GSettingsGetMapping) (GVariant           *value,
                                                                         gpointer           *result,
                                                                         gpointer            user_data);
typedef gboolean (*GSettingsBindGetMapping) (GValue             *value,
                                                                         GVariant           *variant,
                                                                         gpointer            user_data);
typedef GVariant * (*GSettingsBindSetMapping) (const GValue       *value,
                                                                         const GVariantType *expected_type,
                                                                         gpointer            user_data);
typedef gpointer (*GReallocFunc) (gpointer data,
                                   gsize    size);
typedef GType (*GDBusProxyTypeFunc) (GDBusObjectManagerClient   *manager,
                                     const gchar                *object_path,
                                     const gchar                *interface_name,
                                     gpointer                    user_data);
typedef gboolean (*GPollableSourceFunc) (GObject  *pollable_stream,
					 gpointer  user_data);
typedef gboolean (*GCancellableSourceFunc) (GCancellable *cancellable,
					    gpointer      user_data);
typedef gboolean (*GDatagramBasedSourceFunc) (GDatagramBased *datagram_based,
                                              GIOCondition    condition,
                                              gpointer        user_data);
typedef gboolean (*GSocketSourceFunc) (GSocket *socket,
				       GIOCondition condition,
				       gpointer user_data);
typedef void (*GSimpleAsyncThreadFunc) (GSimpleAsyncResult *res,
                                        GObject *object,
                                        GCancellable *cancellable);
typedef gboolean (*GIOSchedulerJobFunc) (GIOSchedulerJob *job,
					 GCancellable    *cancellable,
					 gpointer         user_data);
typedef void (*GFileMeasureProgressCallback) (gboolean reporting,
                                               guint64  current_size,
                                               guint64  num_dirs,
                                               guint64  num_files,
                                               gpointer user_data);
typedef gboolean (*GFileReadMoreCallback) (const char *file_contents,
                                            goffset file_size,
                                            gpointer callback_data);
typedef void (*GFileProgressCallback) (goffset current_num_bytes,
                                       goffset total_num_bytes,
                                       gpointer user_data);
typedef void (*GAsyncReadyCallback) (GObject *source_object,
				     GAsyncResult *res,
				     gpointer user_data);
typedef void (*GDesktopAppLaunchCallback) (GDesktopAppInfo  *appinfo,
					   GPid              pid,
					   gpointer          user_data);
typedef void (*GBusNameVanishedCallback) (GDBusConnection *connection,
                                          const gchar     *name,
                                          gpointer         user_data);
typedef void (*GBusNameAppearedCallback) (GDBusConnection *connection,
                                          const gchar     *name,
                                          const gchar     *name_owner,
                                          gpointer         user_data);
typedef void (*GBusNameLostCallback) (GDBusConnection *connection,
                                      const gchar     *name,
                                      gpointer         user_data);
typedef void (*GBusNameAcquiredCallback) (GDBusConnection *connection,
                                          const gchar     *name,
                                          gpointer         user_data);
typedef void (*GBusAcquiredCallback) (GDBusConnection *connection,
                                      const gchar     *name,
                                      gpointer         user_data);
typedef GDBusMessage * (*GDBusMessageFilterFunction) (GDBusConnection *connection,
                                                     GDBusMessage    *message,
                                                     gboolean         incoming,
                                                     gpointer         user_data);
typedef void (*GDBusSignalCallback) (GDBusConnection  *connection,
                                     const gchar      *sender_name,
                                     const gchar      *object_path,
                                     const gchar      *interface_name,
                                     const gchar      *signal_name,
                                     GVariant         *parameters,
                                     gpointer          user_data);
typedef const GDBusInterfaceVTable * (*GDBusSubtreeDispatchFunc) (GDBusConnection             *connection,
                                                                  const gchar                 *sender,
                                                                  const gchar                 *object_path,
                                                                  const gchar                 *interface_name,
                                                                  const gchar                 *node,
                                                                  gpointer                    *out_user_data,
                                                                  gpointer                     user_data);
typedef GDBusInterfaceInfo ** (*GDBusSubtreeIntrospectFunc) (GDBusConnection       *connection,
                                                             const gchar           *sender,
                                                             const gchar           *object_path,
                                                             const gchar           *node,
                                                             gpointer               user_data);
typedef gchar ** (*GDBusSubtreeEnumerateFunc) (GDBusConnection       *connection,
                                              const gchar           *sender,
                                              const gchar           *object_path,
                                              gpointer               user_data);
typedef gboolean (*GDBusInterfaceSetPropertyFunc) (GDBusConnection       *connection,
                                                    const gchar           *sender,
                                                    const gchar           *object_path,
                                                    const gchar           *interface_name,
                                                    const gchar           *property_name,
                                                    GVariant              *value,
                                                    GError               **error,
                                                    gpointer               user_data);
typedef GVariant * (*GDBusInterfaceGetPropertyFunc) (GDBusConnection       *connection,
                                                    const gchar           *sender,
                                                    const gchar           *object_path,
                                                    const gchar           *interface_name,
                                                    const gchar           *property_name,
                                                    GError               **error,
                                                    gpointer               user_data);
typedef void (*GDBusInterfaceMethodCallFunc) (GDBusConnection       *connection,
                                              const gchar           *sender,
                                              const gchar           *object_path,
                                              const gchar           *interface_name,
                                              const gchar           *method_name,
                                              GVariant              *parameters,
                                              GDBusMethodInvocation *invocation,
                                              gpointer               user_data);
typedef enum {
  G_WIN32_REGISTRY_WATCH_NAME = 1 << 0,
  G_WIN32_REGISTRY_WATCH_ATTRIBUTES = 1 << 1,
  G_WIN32_REGISTRY_WATCH_VALUES = 1 << 2,
  G_WIN32_REGISTRY_WATCH_SECURITY = 1 << 3,
} GWin32RegistryKeyWatcherFlags;
typedef enum {
  G_WIN32_REGISTRY_VALUE_NONE = 0,
  G_WIN32_REGISTRY_VALUE_BINARY = 1,
  G_WIN32_REGISTRY_VALUE_UINT32LE = 2,
  G_WIN32_REGISTRY_VALUE_UINT32BE = 3,
#if G_BYTE_ORDER == G_BIG_ENDIAN
  G_WIN32_REGISTRY_VALUE_UINT32 = G_WIN32_REGISTRY_VALUE_UINT32BE,
#else
  G_WIN32_REGISTRY_VALUE_UINT32 = G_WIN32_REGISTRY_VALUE_UINT32LE,
#endif
  G_WIN32_REGISTRY_VALUE_EXPAND_STR = 4,
  G_WIN32_REGISTRY_VALUE_LINK = 5,
  G_WIN32_REGISTRY_VALUE_MULTI_STR = 6,
  G_WIN32_REGISTRY_VALUE_UINT64LE = 7,
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
  G_WIN32_REGISTRY_VALUE_UINT64 = G_WIN32_REGISTRY_VALUE_UINT64LE,
#endif
  G_WIN32_REGISTRY_VALUE_STR = 8
} GWin32RegistryValueType;
typedef enum
{
  G_SETTINGS_BIND_DEFAULT,
  G_SETTINGS_BIND_GET            = (1<<0),
  G_SETTINGS_BIND_SET            = (1<<1),
  G_SETTINGS_BIND_NO_SENSITIVITY = (1<<2),
  G_SETTINGS_BIND_GET_NO_CHANGES = (1<<3),
  G_SETTINGS_BIND_INVERT_BOOLEAN = (1<<4)
} GSettingsBindFlags;
typedef enum {
  G_NETWORK_CONNECTIVITY_LOCAL       = 1,
  G_NETWORK_CONNECTIVITY_LIMITED     = 2,
  G_NETWORK_CONNECTIVITY_PORTAL      = 3,
  G_NETWORK_CONNECTIVITY_FULL        = 4
} GNetworkConnectivity;
typedef enum {
  G_NOTIFICATION_PRIORITY_NORMAL,
  G_NOTIFICATION_PRIORITY_LOW,
  G_NOTIFICATION_PRIORITY_HIGH,
  G_NOTIFICATION_PRIORITY_URGENT
} GNotificationPriority;
typedef enum {
  G_SUBPROCESS_FLAGS_NONE                  = 0,
  G_SUBPROCESS_FLAGS_STDIN_PIPE            = (1u << 0),
  G_SUBPROCESS_FLAGS_STDIN_INHERIT         = (1u << 1),
  G_SUBPROCESS_FLAGS_STDOUT_PIPE           = (1u << 2),
  G_SUBPROCESS_FLAGS_STDOUT_SILENCE        = (1u << 3),
  G_SUBPROCESS_FLAGS_STDERR_PIPE           = (1u << 4),
  G_SUBPROCESS_FLAGS_STDERR_SILENCE        = (1u << 5),
  G_SUBPROCESS_FLAGS_STDERR_MERGE          = (1u << 6),
  G_SUBPROCESS_FLAGS_INHERIT_FDS           = (1u << 7)
} GSubprocessFlags;
typedef enum /*< flags >*/ {
  G_TEST_DBUS_NONE = 0
} GTestDBusFlags;
typedef enum {
  G_SOCKET_LISTENER_BINDING,
  G_SOCKET_LISTENER_BOUND,
  G_SOCKET_LISTENER_LISTENING,
  G_SOCKET_LISTENER_LISTENED
} GSocketListenerEvent;
typedef enum {
  G_SOCKET_CLIENT_RESOLVING,
  G_SOCKET_CLIENT_RESOLVED,
  G_SOCKET_CLIENT_CONNECTING,
  G_SOCKET_CLIENT_CONNECTED,
  G_SOCKET_CLIENT_PROXY_NEGOTIATING,
  G_SOCKET_CLIENT_PROXY_NEGOTIATED,
  G_SOCKET_CLIENT_TLS_HANDSHAKING,
  G_SOCKET_CLIENT_TLS_HANDSHAKED,
  G_SOCKET_CLIENT_COMPLETE
} GSocketClientEvent;
typedef enum {
  G_IO_MODULE_SCOPE_NONE,
  G_IO_MODULE_SCOPE_BLOCK_DUPLICATES
} GIOModuleScopeFlags;
typedef enum {
  G_TLS_CERTIFICATE_REQUEST_NONE = 0
} GTlsCertificateRequestFlags;
typedef enum {
  G_TLS_DATABASE_LOOKUP_NONE = 0,
  G_TLS_DATABASE_LOOKUP_KEYPAIR = 1
} GTlsDatabaseLookupFlags;
typedef enum /*< flags >*/ {
  G_TLS_DATABASE_VERIFY_NONE = 0
} GTlsDatabaseVerifyFlags;
typedef enum
{
  G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
  G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = (1<<0)
} GDBusObjectManagerClientFlags;
typedef enum
{
  G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
  G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = (1<<0)
} GDBusInterfaceSkeletonFlags;
typedef enum {
  G_TLS_INTERACTION_UNHANDLED,
  G_TLS_INTERACTION_HANDLED,
  G_TLS_INTERACTION_FAILED
} GTlsInteractionResult;
typedef enum _GTlsPasswordFlags
{
  G_TLS_PASSWORD_NONE = 0,
  G_TLS_PASSWORD_RETRY = 1 << 1,
  G_TLS_PASSWORD_MANY_TRIES = 1 << 2,
  G_TLS_PASSWORD_FINAL_TRY = 1 << 3
} GTlsPasswordFlags;
typedef enum {
  G_TLS_REHANDSHAKE_NEVER,
  G_TLS_REHANDSHAKE_SAFELY,
  G_TLS_REHANDSHAKE_UNSAFELY
} GTlsRehandshakeMode;
typedef enum {
  G_TLS_AUTHENTICATION_NONE,
  G_TLS_AUTHENTICATION_REQUESTED,
  G_TLS_AUTHENTICATION_REQUIRED
} GTlsAuthenticationMode;
typedef enum {
  G_TLS_CERTIFICATE_UNKNOWN_CA    = (1 << 0),
  G_TLS_CERTIFICATE_BAD_IDENTITY  = (1 << 1),
  G_TLS_CERTIFICATE_NOT_ACTIVATED = (1 << 2),
  G_TLS_CERTIFICATE_EXPIRED       = (1 << 3),
  G_TLS_CERTIFICATE_REVOKED       = (1 << 4),
  G_TLS_CERTIFICATE_INSECURE      = (1 << 5),
  G_TLS_CERTIFICATE_GENERIC_ERROR = (1 << 6),

  G_TLS_CERTIFICATE_VALIDATE_ALL  = 0x007f
} GTlsCertificateFlags;
typedef enum {
  G_TLS_ERROR_UNAVAILABLE,
  G_TLS_ERROR_MISC,
  G_TLS_ERROR_BAD_CERTIFICATE,
  G_TLS_ERROR_NOT_TLS,
  G_TLS_ERROR_HANDSHAKE,
  G_TLS_ERROR_CERTIFICATE_REQUIRED,
  G_TLS_ERROR_EOF
} GTlsError;
typedef enum
{
  G_APPLICATION_FLAGS_NONE,
  G_APPLICATION_IS_SERVICE  =          (1 << 0),
  G_APPLICATION_IS_LAUNCHER =          (1 << 1),

  G_APPLICATION_HANDLES_OPEN =         (1 << 2),
  G_APPLICATION_HANDLES_COMMAND_LINE = (1 << 3),
  G_APPLICATION_SEND_ENVIRONMENT    =  (1 << 4),

  G_APPLICATION_NON_UNIQUE =           (1 << 5),

  G_APPLICATION_CAN_OVERRIDE_APP_ID =  (1 << 6)
} GApplicationFlags;
typedef enum
{
  G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN    = 'B',
  G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 'l'
} GDBusMessageByteOrder;
typedef enum
{
  G_CREDENTIALS_TYPE_INVALID,
  G_CREDENTIALS_TYPE_LINUX_UCRED,
  G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED,
  G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED,
  G_CREDENTIALS_TYPE_SOLARIS_UCRED,
  G_CREDENTIALS_TYPE_NETBSD_UNPCBID
} GCredentialsType;
typedef enum
{
  G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0,
  G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = (1<<0)
} GDBusSendMessageFlags;
typedef enum /*< flags >*/
{
  G_DBUS_SIGNAL_FLAGS_NONE = 0,
  G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = (1<<0),
  G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = (1<<1),
  G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = (1<<2)
} GDBusSignalFlags;
typedef enum
{
  G_DBUS_SERVER_FLAGS_NONE = 0,
  G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = (1<<0),
  G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = (1<<1)
} GDBusServerFlags;
typedef enum
{
  G_DBUS_SUBTREE_FLAGS_NONE = 0,
  G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = (1<<0)
} GDBusSubtreeFlags;
typedef enum
{
  G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0,
  G_DBUS_PROPERTY_INFO_FLAGS_READABLE = (1<<0),
  G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = (1<<1)
} GDBusPropertyInfoFlags;
typedef enum {
  G_DBUS_MESSAGE_HEADER_FIELD_INVALID,
  G_DBUS_MESSAGE_HEADER_FIELD_PATH,
  G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE,
  G_DBUS_MESSAGE_HEADER_FIELD_MEMBER,
  G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME,
  G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL,
  G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION,
  G_DBUS_MESSAGE_HEADER_FIELD_SENDER,
  G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE,
  G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS
} GDBusMessageHeaderField;
typedef enum {
  G_DBUS_MESSAGE_FLAGS_NONE = 0,
  G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = (1<<0),
  G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = (1<<1),
  G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = (1<<2)
} GDBusMessageFlags;
typedef enum {
  G_DBUS_MESSAGE_TYPE_INVALID,
  G_DBUS_MESSAGE_TYPE_METHOD_CALL,
  G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
  G_DBUS_MESSAGE_TYPE_ERROR,
  G_DBUS_MESSAGE_TYPE_SIGNAL
} GDBusMessageType;
typedef enum {
  G_DBUS_CALL_FLAGS_NONE = 0,
  G_DBUS_CALL_FLAGS_NO_AUTO_START = (1<<0),
  G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = (1<<1)
} GDBusCallFlags;
typedef enum {
  G_DBUS_CAPABILITY_FLAGS_NONE = 0,
  G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = (1<<0)
} GDBusCapabilityFlags;
typedef enum {
  G_DBUS_CONNECTION_FLAGS_NONE = 0,
  G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = (1<<0),
  G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = (1<<1),
  G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = (1<<2),
  G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = (1<<3),
  G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = (1<<4)
} GDBusConnectionFlags;
typedef enum
{
  /* Well-known errors in the org.freedesktop.DBus.Error namespace */
  G_DBUS_ERROR_FAILED,                           /* org.freedesktop.DBus.Error.Failed */
  G_DBUS_ERROR_NO_MEMORY,                        /* org.freedesktop.DBus.Error.NoMemory */
  G_DBUS_ERROR_SERVICE_UNKNOWN,                  /* org.freedesktop.DBus.Error.ServiceUnknown */
  G_DBUS_ERROR_NAME_HAS_NO_OWNER,                /* org.freedesktop.DBus.Error.NameHasNoOwner */
  G_DBUS_ERROR_NO_REPLY,                         /* org.freedesktop.DBus.Error.NoReply */
  G_DBUS_ERROR_IO_ERROR,                         /* org.freedesktop.DBus.Error.IOError */
  G_DBUS_ERROR_BAD_ADDRESS,                      /* org.freedesktop.DBus.Error.BadAddress */
  G_DBUS_ERROR_NOT_SUPPORTED,                    /* org.freedesktop.DBus.Error.NotSupported */
  G_DBUS_ERROR_LIMITS_EXCEEDED,                  /* org.freedesktop.DBus.Error.LimitsExceeded */
  G_DBUS_ERROR_ACCESS_DENIED,                    /* org.freedesktop.DBus.Error.AccessDenied */
  G_DBUS_ERROR_AUTH_FAILED,                      /* org.freedesktop.DBus.Error.AuthFailed */
  G_DBUS_ERROR_NO_SERVER,                        /* org.freedesktop.DBus.Error.NoServer */
  G_DBUS_ERROR_TIMEOUT,                          /* org.freedesktop.DBus.Error.Timeout */
  G_DBUS_ERROR_NO_NETWORK,                       /* org.freedesktop.DBus.Error.NoNetwork */
  G_DBUS_ERROR_ADDRESS_IN_USE,                   /* org.freedesktop.DBus.Error.AddressInUse */
  G_DBUS_ERROR_DISCONNECTED,                     /* org.freedesktop.DBus.Error.Disconnected */
  G_DBUS_ERROR_INVALID_ARGS,                     /* org.freedesktop.DBus.Error.InvalidArgs */
  G_DBUS_ERROR_FILE_NOT_FOUND,                   /* org.freedesktop.DBus.Error.FileNotFound */
  G_DBUS_ERROR_FILE_EXISTS,                      /* org.freedesktop.DBus.Error.FileExists */
  G_DBUS_ERROR_UNKNOWN_METHOD,                   /* org.freedesktop.DBus.Error.UnknownMethod */
  G_DBUS_ERROR_TIMED_OUT,                        /* org.freedesktop.DBus.Error.TimedOut */
  G_DBUS_ERROR_MATCH_RULE_NOT_FOUND,             /* org.freedesktop.DBus.Error.MatchRuleNotFound */
  G_DBUS_ERROR_MATCH_RULE_INVALID,               /* org.freedesktop.DBus.Error.MatchRuleInvalid */
  G_DBUS_ERROR_SPAWN_EXEC_FAILED,                /* org.freedesktop.DBus.Error.Spawn.ExecFailed */
  G_DBUS_ERROR_SPAWN_FORK_FAILED,                /* org.freedesktop.DBus.Error.Spawn.ForkFailed */
  G_DBUS_ERROR_SPAWN_CHILD_EXITED,               /* org.freedesktop.DBus.Error.Spawn.ChildExited */
  G_DBUS_ERROR_SPAWN_CHILD_SIGNALED,             /* org.freedesktop.DBus.Error.Spawn.ChildSignaled */
  G_DBUS_ERROR_SPAWN_FAILED,                     /* org.freedesktop.DBus.Error.Spawn.Failed */
  G_DBUS_ERROR_SPAWN_SETUP_FAILED,               /* org.freedesktop.DBus.Error.Spawn.FailedToSetup */
  G_DBUS_ERROR_SPAWN_CONFIG_INVALID,             /* org.freedesktop.DBus.Error.Spawn.ConfigInvalid */
  G_DBUS_ERROR_SPAWN_SERVICE_INVALID,            /* org.freedesktop.DBus.Error.Spawn.ServiceNotValid */
  G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND,          /* org.freedesktop.DBus.Error.Spawn.ServiceNotFound */
  G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID,        /* org.freedesktop.DBus.Error.Spawn.PermissionsInvalid */
  G_DBUS_ERROR_SPAWN_FILE_INVALID,               /* org.freedesktop.DBus.Error.Spawn.FileInvalid */
  G_DBUS_ERROR_SPAWN_NO_MEMORY,                  /* org.freedesktop.DBus.Error.Spawn.NoMemory */
  G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN,          /* org.freedesktop.DBus.Error.UnixProcessIdUnknown */
  G_DBUS_ERROR_INVALID_SIGNATURE,                /* org.freedesktop.DBus.Error.InvalidSignature */
  G_DBUS_ERROR_INVALID_FILE_CONTENT,             /* org.freedesktop.DBus.Error.InvalidFileContent */
  G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN, /* org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown */
  G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN,           /* org.freedesktop.DBus.Error.AdtAuditDataUnknown */
  G_DBUS_ERROR_OBJECT_PATH_IN_USE,               /* org.freedesktop.DBus.Error.ObjectPathInUse */
  G_DBUS_ERROR_UNKNOWN_OBJECT,                   /* org.freedesktop.DBus.Error.UnknownObject */
  G_DBUS_ERROR_UNKNOWN_INTERFACE,                /* org.freedesktop.DBus.Error.UnknownInterface */
  G_DBUS_ERROR_UNKNOWN_PROPERTY,                 /* org.freedesktop.DBus.Error.UnknownProperty */
  G_DBUS_ERROR_PROPERTY_READ_ONLY                /* org.freedesktop.DBus.Error.PropertyReadOnly */
} GDBusError;
typedef enum
{
  G_DBUS_PROXY_FLAGS_NONE = 0,
  G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = (1<<0),
  G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = (1<<1),
  G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = (1<<2),
  G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = (1<<3),
  G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = (1<<4)
} GDBusProxyFlags;
typedef enum
{
  G_BUS_NAME_WATCHER_FLAGS_NONE = 0,
  G_BUS_NAME_WATCHER_FLAGS_AUTO_START = (1<<0)
} GBusNameWatcherFlags;
typedef enum
{
  G_BUS_NAME_OWNER_FLAGS_NONE = 0,                    /*< nick=none >*/
  G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = (1<<0),  /*< nick=allow-replacement >*/
  G_BUS_NAME_OWNER_FLAGS_REPLACE = (1<<1),           /*< nick=replace >*/
  G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = (1<<2)       /*< nick=do-not-queue >*/
} GBusNameOwnerFlags;
typedef enum
{
  G_BUS_TYPE_STARTER = -1,
  G_BUS_TYPE_NONE = 0,
  G_BUS_TYPE_SYSTEM  = 1,
  G_BUS_TYPE_SESSION = 2
} GBusType;
typedef enum {
  G_UNIX_SOCKET_ADDRESS_INVALID,
  G_UNIX_SOCKET_ADDRESS_ANONYMOUS,
  G_UNIX_SOCKET_ADDRESS_PATH,
  G_UNIX_SOCKET_ADDRESS_ABSTRACT,
  G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
} GUnixSocketAddressType;
typedef enum {
  G_ZLIB_COMPRESSOR_FORMAT_ZLIB,
  G_ZLIB_COMPRESSOR_FORMAT_GZIP,
  G_ZLIB_COMPRESSOR_FORMAT_RAW
} GZlibCompressorFormat;
typedef enum {
  G_SOCKET_PROTOCOL_UNKNOWN = -1,
  G_SOCKET_PROTOCOL_DEFAULT = 0,
  G_SOCKET_PROTOCOL_TCP     = 6,
  G_SOCKET_PROTOCOL_UDP     = 17,
  G_SOCKET_PROTOCOL_SCTP    = 132
} GSocketProtocol;
typedef enum /*< flags >*/
{
  G_SOCKET_MSG_NONE,
  G_SOCKET_MSG_OOB = GLIB_SYSDEF_MSG_OOB,
  G_SOCKET_MSG_PEEK = GLIB_SYSDEF_MSG_PEEK,
  G_SOCKET_MSG_DONTROUTE = GLIB_SYSDEF_MSG_DONTROUTE
} GSocketMsgFlags;
typedef enum
{
  G_SOCKET_TYPE_INVALID,
  G_SOCKET_TYPE_STREAM,
  G_SOCKET_TYPE_DATAGRAM,
  G_SOCKET_TYPE_SEQPACKET
} GSocketType;
typedef enum {
  G_SOCKET_FAMILY_INVALID,
  G_SOCKET_FAMILY_UNIX = GLIB_SYSDEF_AF_UNIX,
  G_SOCKET_FAMILY_IPV4 = GLIB_SYSDEF_AF_INET,
  G_SOCKET_FAMILY_IPV6 = GLIB_SYSDEF_AF_INET6
} GSocketFamily;
typedef enum /*< flags >*/ {
  G_RESOURCE_LOOKUP_FLAGS_NONE       = 0
} GResourceLookupFlags;
typedef enum {
  G_RESOURCE_FLAGS_NONE       = 0,
  G_RESOURCE_FLAGS_COMPRESSED = (1<<0)
} GResourceFlags;
typedef enum {
  G_RESOURCE_ERROR_NOT_FOUND,
  G_RESOURCE_ERROR_INTERNAL
} GResourceError;
typedef enum {
  G_RESOLVER_RECORD_SRV = 1,
  G_RESOLVER_RECORD_MX,
  G_RESOLVER_RECORD_TXT,
  G_RESOLVER_RECORD_SOA,
  G_RESOLVER_RECORD_NS
} GResolverRecordType;
typedef enum {
  G_RESOLVER_ERROR_NOT_FOUND,
  G_RESOLVER_ERROR_TEMPORARY_FAILURE,
  G_RESOLVER_ERROR_INTERNAL
} GResolverError;
typedef enum  {
  G_EMBLEM_ORIGIN_UNKNOWN,
  G_EMBLEM_ORIGIN_DEVICE,
  G_EMBLEM_ORIGIN_LIVEMETADATA,
  G_EMBLEM_ORIGIN_TAG
} GEmblemOrigin;
typedef enum {
  G_IO_STREAM_SPLICE_NONE          = 0,
  G_IO_STREAM_SPLICE_CLOSE_STREAM1 = (1 << 0),
  G_IO_STREAM_SPLICE_CLOSE_STREAM2 = (1 << 1),
  G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = (1 << 2)
} GIOStreamSpliceFlags;
typedef enum {
  G_OUTPUT_STREAM_SPLICE_NONE         = 0,
  G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = (1 << 0),
  G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = (1 << 1)
} GOutputStreamSpliceFlags;
typedef enum {
  G_MOUNT_OPERATION_HANDLED,
  G_MOUNT_OPERATION_ABORTED,
  G_MOUNT_OPERATION_UNHANDLED
} GMountOperationResult;
typedef enum {
  G_PASSWORD_SAVE_NEVER,
  G_PASSWORD_SAVE_FOR_SESSION,
  G_PASSWORD_SAVE_PERMANENTLY
} GPasswordSave;
typedef enum {
  G_ASK_PASSWORD_NEED_PASSWORD       = (1 << 0),
  G_ASK_PASSWORD_NEED_USERNAME       = (1 << 1),
  G_ASK_PASSWORD_NEED_DOMAIN         = (1 << 2),
  G_ASK_PASSWORD_SAVING_SUPPORTED    = (1 << 3),
  G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = (1 << 4)
} GAskPasswordFlags;
typedef enum {
  G_IO_ERROR_FAILED,
  G_IO_ERROR_NOT_FOUND,
  G_IO_ERROR_EXISTS,
  G_IO_ERROR_IS_DIRECTORY,
  G_IO_ERROR_NOT_DIRECTORY,
  G_IO_ERROR_NOT_EMPTY,
  G_IO_ERROR_NOT_REGULAR_FILE,
  G_IO_ERROR_NOT_SYMBOLIC_LINK,
  G_IO_ERROR_NOT_MOUNTABLE_FILE,
  G_IO_ERROR_FILENAME_TOO_LONG,
  G_IO_ERROR_INVALID_FILENAME,
  G_IO_ERROR_TOO_MANY_LINKS,
  G_IO_ERROR_NO_SPACE,
  G_IO_ERROR_INVALID_ARGUMENT,
  G_IO_ERROR_PERMISSION_DENIED,
  G_IO_ERROR_NOT_SUPPORTED,
  G_IO_ERROR_NOT_MOUNTED,
  G_IO_ERROR_ALREADY_MOUNTED,
  G_IO_ERROR_CLOSED,
  G_IO_ERROR_CANCELLED,
  G_IO_ERROR_PENDING,
  G_IO_ERROR_READ_ONLY,
  G_IO_ERROR_CANT_CREATE_BACKUP,
  G_IO_ERROR_WRONG_ETAG,
  G_IO_ERROR_TIMED_OUT,
  G_IO_ERROR_WOULD_RECURSE,
  G_IO_ERROR_BUSY,
  G_IO_ERROR_WOULD_BLOCK,
  G_IO_ERROR_HOST_NOT_FOUND,
  G_IO_ERROR_WOULD_MERGE,
  G_IO_ERROR_FAILED_HANDLED,
  G_IO_ERROR_TOO_MANY_OPEN_FILES,
  G_IO_ERROR_NOT_INITIALIZED,
  G_IO_ERROR_ADDRESS_IN_USE,
  G_IO_ERROR_PARTIAL_INPUT,
  G_IO_ERROR_INVALID_DATA,
  G_IO_ERROR_DBUS_ERROR,
  G_IO_ERROR_HOST_UNREACHABLE,
  G_IO_ERROR_NETWORK_UNREACHABLE,
  G_IO_ERROR_CONNECTION_REFUSED,
  G_IO_ERROR_PROXY_FAILED,
  G_IO_ERROR_PROXY_AUTH_FAILED,
  G_IO_ERROR_PROXY_NEED_AUTH,
  G_IO_ERROR_PROXY_NOT_ALLOWED,
  G_IO_ERROR_BROKEN_PIPE,
  G_IO_ERROR_CONNECTION_CLOSED = G_IO_ERROR_BROKEN_PIPE,
  G_IO_ERROR_NOT_CONNECTED,
  G_IO_ERROR_MESSAGE_TOO_LARGE
} GIOErrorEnum;
typedef enum {
  G_FILE_MONITOR_EVENT_CHANGED,
  G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT,
  G_FILE_MONITOR_EVENT_DELETED,
  G_FILE_MONITOR_EVENT_CREATED,
  G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED,
  G_FILE_MONITOR_EVENT_PRE_UNMOUNT,
  G_FILE_MONITOR_EVENT_UNMOUNTED,
  G_FILE_MONITOR_EVENT_MOVED,
  G_FILE_MONITOR_EVENT_RENAMED,
  G_FILE_MONITOR_EVENT_MOVED_IN,
  G_FILE_MONITOR_EVENT_MOVED_OUT
} GFileMonitorEvent;
typedef enum {
  G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0,
  G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL,
  G_FILESYSTEM_PREVIEW_TYPE_NEVER
} GFilesystemPreviewType;
typedef enum {
  G_FILE_TYPE_UNKNOWN = 0,
  G_FILE_TYPE_REGULAR,
  G_FILE_TYPE_DIRECTORY,
  G_FILE_TYPE_SYMBOLIC_LINK,
  G_FILE_TYPE_SPECIAL, /* socket, fifo, blockdev, chardev */
  G_FILE_TYPE_SHORTCUT,
  G_FILE_TYPE_MOUNTABLE
} GFileType;
typedef enum {
  G_FILE_MONITOR_NONE             = 0,
  G_FILE_MONITOR_WATCH_MOUNTS     = (1 << 0),
  G_FILE_MONITOR_SEND_MOVED       = (1 << 1),
  G_FILE_MONITOR_WATCH_HARD_LINKS = (1 << 2),
  G_FILE_MONITOR_WATCH_MOVES      = (1 << 3)
} GFileMonitorFlags;
typedef enum {
  G_FILE_COPY_NONE                 = 0,          /*< nick=none >*/
  G_FILE_COPY_OVERWRITE            = (1 << 0),
  G_FILE_COPY_BACKUP               = (1 << 1),
  G_FILE_COPY_NOFOLLOW_SYMLINKS    = (1 << 2),
  G_FILE_COPY_ALL_METADATA         = (1 << 3),
  G_FILE_COPY_NO_FALLBACK_FOR_MOVE = (1 << 4),
  G_FILE_COPY_TARGET_DEFAULT_PERMS = (1 << 5)
} GFileCopyFlags;
typedef enum {
  G_DRIVE_START_STOP_TYPE_UNKNOWN,
  G_DRIVE_START_STOP_TYPE_SHUTDOWN,
  G_DRIVE_START_STOP_TYPE_NETWORK,
  G_DRIVE_START_STOP_TYPE_MULTIDISK,
  G_DRIVE_START_STOP_TYPE_PASSWORD
} GDriveStartStopType;
typedef enum /*< flags >*/ {
  G_DRIVE_START_NONE = 0
} GDriveStartFlags;
typedef enum {
  G_MOUNT_UNMOUNT_NONE  = 0,
  G_MOUNT_UNMOUNT_FORCE = (1 << 0)
} GMountUnmountFlags;
typedef enum /*< flags >*/ {
  G_MOUNT_MOUNT_NONE = 0
} GMountMountFlags;
typedef enum {
  G_FILE_MEASURE_NONE                 = 0,
  G_FILE_MEASURE_REPORT_ANY_ERROR     = (1 << 1),
  G_FILE_MEASURE_APPARENT_SIZE        = (1 << 2),
  G_FILE_MEASURE_NO_XDEV              = (1 << 3)
} GFileMeasureFlags;
typedef enum {
  G_FILE_CREATE_NONE    = 0,
  G_FILE_CREATE_PRIVATE = (1 << 0),
  G_FILE_CREATE_REPLACE_DESTINATION = (1 << 1)
} GFileCreateFlags;
typedef enum {
  G_FILE_QUERY_INFO_NONE              = 0,
  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = (1 << 0)   /*< nick=nofollow-symlinks >*/
} GFileQueryInfoFlags;
typedef enum {
  G_FILE_ATTRIBUTE_STATUS_UNSET = 0,
  G_FILE_ATTRIBUTE_STATUS_SET,
  G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING
} GFileAttributeStatus;
typedef enum {
  G_FILE_ATTRIBUTE_INFO_NONE            = 0,
  G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE  = (1 << 0),
  G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = (1 << 1)
} GFileAttributeInfoFlags;
typedef enum {
  G_FILE_ATTRIBUTE_TYPE_INVALID = 0,
  G_FILE_ATTRIBUTE_TYPE_STRING,
  G_FILE_ATTRIBUTE_TYPE_BYTE_STRING, /* zero terminated string of non-zero bytes */
  G_FILE_ATTRIBUTE_TYPE_BOOLEAN,
  G_FILE_ATTRIBUTE_TYPE_UINT32,
  G_FILE_ATTRIBUTE_TYPE_INT32,
  G_FILE_ATTRIBUTE_TYPE_UINT64,
  G_FILE_ATTRIBUTE_TYPE_INT64,
  G_FILE_ATTRIBUTE_TYPE_OBJECT,
  G_FILE_ATTRIBUTE_TYPE_STRINGV
} GFileAttributeType;
typedef enum {
  G_DATA_STREAM_NEWLINE_TYPE_LF,
  G_DATA_STREAM_NEWLINE_TYPE_CR,
  G_DATA_STREAM_NEWLINE_TYPE_CR_LF,
  G_DATA_STREAM_NEWLINE_TYPE_ANY
} GDataStreamNewlineType;
typedef enum {
  G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN,
  G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN,
  G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN
} GDataStreamByteOrder;
typedef enum {
  G_CONVERTER_ERROR     = 0,  /*< nick=error >*/
  G_CONVERTER_CONVERTED = 1,  /*< nick=converted >*/
  G_CONVERTER_FINISHED  = 2,  /*< nick=finished >*/
  G_CONVERTER_FLUSHED   = 3   /*< nick=flushed >*/
} GConverterResult;
typedef enum {
  G_CONVERTER_NO_FLAGS     = 0,         /*< nick=none >*/
  G_CONVERTER_INPUT_AT_END = (1 << 0),  /*< nick=input-at-end >*/
  G_CONVERTER_FLUSH        = (1 << 1)   /*< nick=flush >*/
} GConverterFlags;
typedef enum {
  G_APP_INFO_CREATE_NONE                           = 0,         /*< nick=none >*/
  G_APP_INFO_CREATE_NEEDS_TERMINAL                 = (1 << 0),  /*< nick=needs-terminal >*/
  G_APP_INFO_CREATE_SUPPORTS_URIS                  = (1 << 1),  /*< nick=supports-uris >*/
  G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION  = (1 << 2)   /*< nick=supports-startup-notification >*/
} GAppInfoCreateFlags;












struct _GXdpProxyResolverSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};
struct _GXdpProxyResolverSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  GXdpProxyResolverSkeletonPrivate *priv;
};
struct _GXdpProxyResolverProxyClass
{
  GDBusProxyClass parent_class;
};
struct _GXdpProxyResolverProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  GXdpProxyResolverProxyPrivate *priv;
};
struct _GXdpProxyResolverIface
{
  GTypeInterface parent_iface;

  gboolean (*handle_lookup) (
    GXdpProxyResolver *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_uri);

};
struct _GXdpNetworkMonitorSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};
struct _GXdpNetworkMonitorSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  GXdpNetworkMonitorSkeletonPrivate *priv;
};
struct _GXdpNetworkMonitorProxyClass
{
  GDBusProxyClass parent_class;
};
struct _GXdpNetworkMonitorProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  GXdpNetworkMonitorProxyPrivate *priv;
};
struct _GXdpNetworkMonitorIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_get_available) (
    GXdpNetworkMonitor *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_get_connectivity) (
    GXdpNetworkMonitor *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_get_metered) (
    GXdpNetworkMonitor *object,
    GDBusMethodInvocation *invocation);

  guint  (*get_version) (GXdpNetworkMonitor *object);

  void (*changed) (
    GXdpNetworkMonitor *object);

};
struct _GXdpOpenURISkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};
struct _GXdpOpenURISkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  GXdpOpenURISkeletonPrivate *priv;
};
struct _GXdpOpenURIProxyClass
{
  GDBusProxyClass parent_class;
};
struct _GXdpOpenURIProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  GXdpOpenURIProxyPrivate *priv;
};
struct _GXdpOpenURIIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_open_file) (
    GXdpOpenURI *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    const gchar *arg_parent_window,
    GVariant *arg_fd,
    GVariant *arg_options);

  gboolean (*handle_open_uri) (
    GXdpOpenURI *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_parent_window,
    const gchar *arg_uri,
    GVariant *arg_options);

  guint  (*get_version) (GXdpOpenURI *object);

};
struct _GXdpDocumentsSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};
struct _GXdpDocumentsSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  GXdpDocumentsSkeletonPrivate *priv;
};
struct _GXdpDocumentsProxyClass
{
  GDBusProxyClass parent_class;
};
struct _GXdpDocumentsProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  GXdpDocumentsProxyPrivate *priv;
};
struct _GXdpDocumentsIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_add) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_o_path_fd,
    gboolean arg_reuse_existing,
    gboolean arg_persistent);

  gboolean (*handle_add_full) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_o_path_fds,
    guint arg_flags,
    const gchar *arg_app_id,
    const gchar *const *arg_permissions);

  gboolean (*handle_add_named) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_o_path_parent_fd,
    const gchar *arg_filename,
    gboolean arg_reuse_existing,
    gboolean arg_persistent);

  gboolean (*handle_delete) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_doc_id);

  gboolean (*handle_get_mount_point) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_grant_permissions) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_doc_id,
    const gchar *arg_app_id,
    const gchar *const *arg_permissions);

  gboolean (*handle_info) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_doc_id);

  gboolean (*handle_list) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_app_id);

  gboolean (*handle_lookup) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_filename);

  gboolean (*handle_revoke_permissions) (
    GXdpDocuments *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_doc_id,
    const gchar *arg_app_id,
    const gchar *const *arg_permissions);

  guint  (*get_version) (GXdpDocuments *object);

};
struct _GZlibDecompressorClass
{
  GObjectClass parent_class;
};
struct _GZlibCompressorClass
{
  GObjectClass parent_class;
};

struct _GWin32RegistryValueIter {
  /*< private >*/
  GWin32RegistryKey       *key;
  gint                     counter;
  gint                     value_count;

  gunichar2               *value_name;
  gsize                    value_name_size;
  gsize                    value_name_len;
  GWin32RegistryValueType  value_type;
  guint8                  *value_data;
  gsize                    value_data_size;
  gsize                    value_actual_data_size;
  GWin32RegistryValueType  value_expanded_type;
  gunichar2               *value_data_expanded;
  gsize                    value_data_expanded_charsize;

  gchar                   *value_name_u8;
  gsize                    value_name_u8_len;
  gchar                   *value_data_u8;
  gsize                    value_data_u8_size;
  gchar                   *value_data_expanded_u8;
  gsize                    value_data_expanded_u8_size;
};
struct _GWin32RegistrySubkeyIter {
  /*< private >*/
  GWin32RegistryKey *key;
  gint               counter;
  gint               subkey_count;

  gunichar2         *subkey_name;
  gsize              subkey_name_size;
  gsize              subkey_name_len;

  gchar             *subkey_name_u8;
};
struct _GWin32RegistryKeyClass {
  GObjectClass parent_class;
};
struct _GWin32RegistryKey {
  GObject parent_instance;

  /*< private >*/
  GWin32RegistryKeyPrivate *priv;
};

struct _GWin32OutputStreamClass
{
  GOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GWin32OutputStream
{
  GOutputStream parent_instance;

  /*< private >*/
  GWin32OutputStreamPrivate *priv;
};

typedef int uid_t;
typedef int pid_t;

typedef struct _GNetworkMonitorBase        GNetworkMonitorBase;
typedef struct _GNetworkMonitorBaseClass   GNetworkMonitorBaseClass;
typedef struct _GNetworkMonitorBasePrivate GNetworkMonitorBasePrivate;

struct _GNetworkMonitorBase {
  GObject parent_instance;

  GNetworkMonitorBasePrivate *priv;
};

struct _GNetworkMonitorBaseClass {
  GObjectClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[8];
};

struct _GWin32NetworkMonitorClass {
  GNetworkMonitorBaseClass parent_class;
};
struct _GWin32NetworkMonitor {
  GNetworkMonitorBase parent_instance;

  GWin32NetworkMonitorPrivate *priv;
};

struct _GWin32InputStreamClass
{
  GInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GWin32InputStream
{
  GInputStream parent_instance;

  /*< private >*/
  GWin32InputStreamPrivate *priv;
};
struct _GVolumeMonitorClass
{
  GObjectClass parent_class;

  /*< public >*/
  /* signals */
  void      (* volume_added)         (GVolumeMonitor *volume_monitor,
                                      GVolume        *volume);
  void      (* volume_removed)       (GVolumeMonitor *volume_monitor,
                                      GVolume        *volume);
  void      (* volume_changed)       (GVolumeMonitor *volume_monitor,
                                      GVolume        *volume);

  void      (* mount_added)          (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);
  void      (* mount_removed)        (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);
  void      (* mount_pre_unmount)    (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);
  void      (* mount_changed)        (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);

  void      (* drive_connected)      (GVolumeMonitor *volume_monitor,
                                      GDrive	     *drive);
  void      (* drive_disconnected)   (GVolumeMonitor *volume_monitor,
                                      GDrive         *drive);
  void      (* drive_changed)        (GVolumeMonitor *volume_monitor,
                                      GDrive         *drive);

  /* Vtable */

  gboolean  (* is_supported)         (void);

  GList   * (* get_connected_drives) (GVolumeMonitor *volume_monitor);
  GList   * (* get_volumes)          (GVolumeMonitor *volume_monitor);
  GList   * (* get_mounts)           (GVolumeMonitor *volume_monitor);

  GVolume * (* get_volume_for_uuid)  (GVolumeMonitor *volume_monitor,
                                      const char     *uuid);

  GMount  * (* get_mount_for_uuid)   (GVolumeMonitor *volume_monitor,
                                      const char     *uuid);


  /* These arguments are unfortunately backwards by mistake (bug #520169). Deprecated in 2.20. */
  GVolume * (* adopt_orphan_mount)   (GMount         *mount,
                                      GVolumeMonitor *volume_monitor);

  /* signal added in 2.17 */
  void      (* drive_eject_button)   (GVolumeMonitor *volume_monitor,
                                      GDrive         *drive);

  /* signal added in 2.21 */
  void      (* drive_stop_button)   (GVolumeMonitor *volume_monitor,
                                     GDrive         *drive);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
struct _GVolumeMonitor
{
  GObject parent_instance;

  /*< private >*/
  gpointer priv;
};
struct _GVolumeIface
{
  GTypeInterface g_iface;

  /* signals */

  void        (* changed)               (GVolume             *volume);
  void        (* removed)               (GVolume             *volume);

  /* Virtual Table */

  char      * (* get_name)              (GVolume             *volume);
  GIcon     * (* get_icon)              (GVolume             *volume);
  char      * (* get_uuid)              (GVolume             *volume);
  GDrive    * (* get_drive)             (GVolume             *volume);
  GMount    * (* get_mount)             (GVolume             *volume);
  gboolean    (* can_mount)             (GVolume             *volume);
  gboolean    (* can_eject)             (GVolume             *volume);
  void        (* mount_fn)              (GVolume             *volume,
                                         GMountMountFlags     flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean    (* mount_finish)          (GVolume             *volume,
                                         GAsyncResult        *result,
                                         GError             **error);
  void        (* eject)                 (GVolume             *volume,
                                         GMountUnmountFlags   flags,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean    (* eject_finish)          (GVolume             *volume,
                                         GAsyncResult        *result,
                                         GError             **error);

  char      * (* get_identifier)        (GVolume             *volume,
                                         const char          *kind);
  char     ** (* enumerate_identifiers) (GVolume             *volume);

  gboolean    (* should_automount)      (GVolume             *volume);

  GFile     * (* get_activation_root)   (GVolume             *volume);

  void        (* eject_with_operation)      (GVolume             *volume,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_with_operation_finish) (GVolume           *volume,
                                             GAsyncResult        *result,
                                             GError             **error);

  const gchar * (* get_sort_key)        (GVolume             *volume);
  GIcon       * (* get_symbolic_icon)   (GVolume             *volume);
};
struct _GVfsClass
{
  GObjectClass parent_class;

  /* Virtual Table */

  gboolean              (* is_active)                 (GVfs       *vfs);
  GFile               * (* get_file_for_path)         (GVfs       *vfs,
                                                       const char *path);
  GFile               * (* get_file_for_uri)          (GVfs       *vfs,
                                                       const char *uri);
  const gchar * const * (* get_supported_uri_schemes) (GVfs       *vfs);
  GFile               * (* parse_name)                (GVfs       *vfs,
                                                       const char *parse_name);

  /*< private >*/
  void                  (* local_file_add_info)       (GVfs       *vfs,
						       const char *filename,
						       guint64     device,
						       GFileAttributeMatcher *attribute_matcher,
						       GFileInfo  *info,
						       GCancellable *cancellable,
						       gpointer   *extra_data,
						       GDestroyNotify *free_extra_data);
  void                  (* add_writable_namespaces)   (GVfs       *vfs,
						       GFileAttributeInfoList *list);
  gboolean              (* local_file_set_attributes) (GVfs       *vfs,
						       const char *filename,
						       GFileInfo  *info,
                                                       GFileQueryInfoFlags flags,
                                                       GCancellable *cancellable,
						       GError    **error);
  void                  (* local_file_removed)        (GVfs       *vfs,
						       const char *filename);
  void                  (* local_file_moved)          (GVfs       *vfs,
						       const char *source,
						       const char *dest);
  GIcon *               (* deserialize_icon)          (GVfs       *vfs,
                                                       GVariant   *value);
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
struct _GVfs
{
  GObject parent_instance;
};

struct _GUnixSocketAddressClass
{
  GSocketAddressClass parent_class;
};
struct _GUnixSocketAddress
{
  GSocketAddress parent_instance;

  /*< private >*/
  GUnixSocketAddressPrivate *priv;
};

struct _GUnixOutputStreamClass
{
  GOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GUnixOutputStream
{
  GOutputStream parent_instance;

  /*< private >*/
  GUnixOutputStreamPrivate *priv;
};





struct _GUnixInputStreamClass
{
  GInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GUnixInputStream
{
  GInputStream parent_instance;

  /*< private >*/
  GUnixInputStreamPrivate *priv;
};

struct _GUnixFDMessage
{
  GSocketControlMessage parent_instance;
  GUnixFDMessagePrivate *priv;
};
struct _GUnixFDMessageClass
{
  GSocketControlMessageClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
};

struct _GUnixFDList
{
  GObject parent_instance;
  GUnixFDListPrivate *priv;
};
struct _GUnixFDListClass
{
  GObjectClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};

struct _GUnixCredentialsMessage
{
  GSocketControlMessage parent_instance;
  GUnixCredentialsMessagePrivate *priv;
};
struct _GUnixCredentialsMessageClass
{
  GSocketControlMessageClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
};

struct _GUnixConnection
{
  GSocketConnection parent_instance;
  GUnixConnectionPrivate *priv;
};
struct _GUnixConnectionClass
{
  GSocketConnectionClass parent_class;
};
struct _GTlsServerConnectionInterface
{
  GTypeInterface g_iface;

};

struct _GTlsPasswordClass
{
  GObjectClass parent_class;

  /* methods */

  const guchar *    ( *get_value)            (GTlsPassword  *password,
                                              gsize         *length);

  void              ( *set_value)            (GTlsPassword  *password,
                                              guchar        *value,
                                              gssize         length,
                                              GDestroyNotify destroy);

  const gchar*      ( *get_default_warning)  (GTlsPassword  *password);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[4];
};
struct _GTlsPassword
{
  GObject parent_instance;

  GTlsPasswordPrivate *priv;
};

struct _GTlsInteractionClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  GTlsInteractionResult  (* ask_password)        (GTlsInteraction    *interaction,
                                                  GTlsPassword       *password,
                                                  GCancellable       *cancellable,
                                                  GError            **error);

  void                   (* ask_password_async)  (GTlsInteraction    *interaction,
                                                  GTlsPassword       *password,
                                                  GCancellable       *cancellable,
                                                  GAsyncReadyCallback callback,
                                                  gpointer            user_data);

  GTlsInteractionResult  (* ask_password_finish) (GTlsInteraction    *interaction,
                                                  GAsyncResult       *result,
                                                  GError            **error);

  GTlsInteractionResult  (* request_certificate)        (GTlsInteraction              *interaction,
                                                         GTlsConnection               *connection,
                                                         GTlsCertificateRequestFlags   flags,
                                                         GCancellable                 *cancellable,
                                                         GError                      **error);

  void                   (* request_certificate_async)  (GTlsInteraction              *interaction,
                                                         GTlsConnection               *connection,
                                                         GTlsCertificateRequestFlags   flags,
                                                         GCancellable                 *cancellable,
                                                         GAsyncReadyCallback           callback,
                                                         gpointer                      user_data);

  GTlsInteractionResult  (* request_certificate_finish) (GTlsInteraction              *interaction,
                                                         GAsyncResult                 *result,
                                                         GError                      **error);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[21];
};
struct _GTlsInteraction
{
  /*< private >*/
  GObject parent_instance;
  GTlsInteractionPrivate *priv;
};
struct _GTlsFileDatabaseInterface
{
  GTypeInterface g_iface;

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[8];
};

struct _GTlsDatabaseClass
{
  GObjectClass parent_class;

  /* virtual methods */

  GTlsCertificateFlags  (*verify_chain)                         (GTlsDatabase            *self,
                                                                 GTlsCertificate         *chain,
                                                                 const gchar             *purpose,
                                                                 GSocketConnectable      *identity,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseVerifyFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*verify_chain_async)                   (GTlsDatabase            *self,
                                                                 GTlsCertificate         *chain,
                                                                 const gchar             *purpose,
                                                                 GSocketConnectable      *identity,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseVerifyFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GTlsCertificateFlags  (*verify_chain_finish)                  (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  gchar*                (*create_certificate_handle)            (GTlsDatabase            *self,
                                                                 GTlsCertificate         *certificate);

  GTlsCertificate*      (*lookup_certificate_for_handle)        (GTlsDatabase            *self,
                                                                 const gchar             *handle,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*lookup_certificate_for_handle_async)  (GTlsDatabase            *self,
                                                                 const gchar             *handle,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GTlsCertificate*      (*lookup_certificate_for_handle_finish) (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  GTlsCertificate*      (*lookup_certificate_issuer)            (GTlsDatabase            *self,
                                                                 GTlsCertificate         *certificate,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*lookup_certificate_issuer_async)      (GTlsDatabase            *self,
                                                                 GTlsCertificate         *certificate,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GTlsCertificate*      (*lookup_certificate_issuer_finish)     (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  GList*                (*lookup_certificates_issued_by)        (GTlsDatabase            *self,
                                                                 GByteArray              *issuer_raw_dn,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*lookup_certificates_issued_by_async)  (GTlsDatabase            *self,
                                                                 GByteArray              *issuer_raw_dn,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GList*                (*lookup_certificates_issued_by_finish) (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[16];
};
struct _GTlsDatabase
{
  GObject parent_instance;

  GTlsDatabasePrivate *priv;
};

struct _GTlsConnectionClass
{
  GIOStreamClass parent_class;

  /* signals */
  gboolean          ( *accept_certificate) (GTlsConnection       *connection,
					    GTlsCertificate      *peer_cert,
					    GTlsCertificateFlags  errors);

  /* methods */
  gboolean ( *handshake )        (GTlsConnection       *conn,
				  GCancellable         *cancellable,
				  GError              **error);

  void     ( *handshake_async )  (GTlsConnection       *conn,
				  int                   io_priority,
				  GCancellable         *cancellable,
				  GAsyncReadyCallback   callback,
				  gpointer              user_data);
  gboolean ( *handshake_finish ) (GTlsConnection       *conn,
				  GAsyncResult         *result,
				  GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[8];
};
struct _GTlsConnection {
  GIOStream parent_instance;

  GTlsConnectionPrivate *priv;
};
struct _GTlsClientConnectionInterface
{
  GTypeInterface g_iface;

  void     ( *copy_session_state )     (GTlsClientConnection       *conn,
                                        GTlsClientConnection       *source);
};

struct _GTlsCertificateClass
{
  GObjectClass parent_class;

  GTlsCertificateFlags  (* verify) (GTlsCertificate     *cert,
				    GSocketConnectable  *identity,
				    GTlsCertificate     *trusted_ca);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[8];
};
struct _GTlsCertificate {
  GObject parent_instance;

  GTlsCertificatePrivate *priv;
};

struct _GTlsBackendInterface
{
  GTypeInterface g_iface;

  /* methods */
  gboolean       ( *supports_tls)               (GTlsBackend *backend);
  GType          ( *get_certificate_type)       (void);
  GType          ( *get_client_connection_type) (void);
  GType          ( *get_server_connection_type) (void);
  GType          ( *get_file_database_type)     (void);
  GTlsDatabase * ( *get_default_database)       (GTlsBackend *backend);
  gboolean       ( *supports_dtls)              (GTlsBackend *backend);
  GType          ( *get_dtls_client_connection_type) (void);
  GType          ( *get_dtls_server_connection_type) (void);
};

struct _GThreadedSocketService
{
  GSocketService parent_instance;
  GThreadedSocketServicePrivate *priv;
};
struct _GThreadedSocketServiceClass
{
  GSocketServiceClass parent_class;

  gboolean (* run) (GThreadedSocketService *service,
                    GSocketConnection      *connection,
                    GObject                *source_object);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};


struct _GTcpWrapperConnection
{
  GTcpConnection parent_instance;
  GTcpWrapperConnectionPrivate *priv;
};
struct _GTcpWrapperConnectionClass
{
  GTcpConnectionClass parent_class;
};

struct _GTcpConnection
{
  GSocketConnection parent_instance;
  GTcpConnectionPrivate *priv;
};
struct _GTcpConnectionClass
{
  GSocketConnectionClass parent_class;
};


struct _GSocketService
{
  GSocketListener parent_instance;
  GSocketServicePrivate *priv;
};
struct _GSocketServiceClass
{
  GSocketListenerClass parent_class;

  gboolean (* incoming) (GSocketService    *service,
                         GSocketConnection *connection,
			 GObject           *source_object);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};

struct _GSocketListener
{
  GObject parent_instance;
  GSocketListenerPrivate *priv;
};
struct _GSocketListenerClass
{
  GObjectClass parent_class;

  void (* changed) (GSocketListener *listener);

  void (* event) (GSocketListener      *listener,
                  GSocketListenerEvent  event,
                  GSocket              *socket);

  /* Padding for future expansion */
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};

struct _GSocketControlMessage
{
  GObject parent_instance;
  GSocketControlMessagePrivate *priv;
};
struct _GSocketControlMessageClass
{
  GObjectClass parent_class;

  gsize                  (* get_size)  (GSocketControlMessage  *message);
  int                    (* get_level) (GSocketControlMessage  *message);
  int                    (* get_type)  (GSocketControlMessage  *message);
  void                   (* serialize) (GSocketControlMessage  *message,
					gpointer                data);
  GSocketControlMessage *(* deserialize) (int                   level,
					  int                   type,
					  gsize                 size,
					  gpointer              data);

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};

struct _GSocketConnection
{
  GIOStream parent_instance;
  GSocketConnectionPrivate *priv;
};
struct _GSocketConnectionClass
{
  GIOStreamClass parent_class;

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
struct _GSocketConnectableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GSocketAddressEnumerator * (* enumerate)       (GSocketConnectable *connectable);

  GSocketAddressEnumerator * (* proxy_enumerate) (GSocketConnectable *connectable);

  gchar                    * (* to_string)       (GSocketConnectable *connectable);
};

struct _GSocketClient
{
  GObject parent_instance;
  GSocketClientPrivate *priv;
};
struct _GSocketClientClass
{
  GObjectClass parent_class;

  void (* event) (GSocketClient       *client,
		  GSocketClientEvent  event,
		  GSocketConnectable  *connectable,
		  GIOStream           *connection);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
};
struct _GSocketAddressEnumeratorClass
{
  GObjectClass parent_class;

  /* Virtual Table */

  GSocketAddress * (* next)        (GSocketAddressEnumerator  *enumerator,
				    GCancellable              *cancellable,
				    GError                   **error);

  void             (* next_async)  (GSocketAddressEnumerator  *enumerator,
				    GCancellable              *cancellable,
				    GAsyncReadyCallback        callback,
				    gpointer                   user_data);
  GSocketAddress * (* next_finish) (GSocketAddressEnumerator  *enumerator,
				    GAsyncResult              *result,
				    GError                   **error);
};
struct _GSocketAddressEnumerator
{
  GObject parent_instance;

};
struct _GSocketAddressClass
{
  GObjectClass parent_class;

  GSocketFamily  (*get_family)      (GSocketAddress *address);

  gssize         (*get_native_size) (GSocketAddress *address);

  gboolean       (*to_native)       (GSocketAddress *address,
                                     gpointer        dest,
                                     gsize           destlen,
				     GError        **error);
};
struct _GSocketAddress
{
  GObject parent_instance;
};

struct _GSocket
{
  GObject parent_instance;
  GSocketPrivate *priv;
};
struct _GSocketClass
{
  GObjectClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
  void (*_g_reserved9) (void);
  void (*_g_reserved10) (void);
};

struct _GSimpleProxyResolverClass
{
  GObjectClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GSimpleProxyResolver
{
  GObject parent_instance;

  /*< private >*/
  GSimpleProxyResolverPrivate *priv;
};


struct _GSimpleActionGroupClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< private >*/
  gpointer padding[12];
};
struct _GSimpleActionGroup
{
  /*< private >*/
  GObject parent_instance;

  GSimpleActionGroupPrivate *priv;
};




struct _GSettingsBackend
{
  GObject parent_instance;

  /*< private >*/
  GSettingsBackendPrivate *priv;
};
struct _GSettingsBackendClass
{
  GObjectClass parent_class;

  GVariant *    (*read)             (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     const GVariantType  *expected_type,
                                     gboolean             default_value);

  gboolean      (*get_writable)     (GSettingsBackend    *backend,
                                     const gchar         *key);

  gboolean      (*write)            (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     GVariant            *value,
                                     gpointer             origin_tag);
  gboolean      (*write_tree)       (GSettingsBackend    *backend,
                                     GTree               *tree,
                                     gpointer             origin_tag);
  void          (*reset)            (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     gpointer             origin_tag);

  void          (*subscribe)        (GSettingsBackend    *backend,
                                     const gchar         *name);
  void          (*unsubscribe)      (GSettingsBackend    *backend,
                                     const gchar         *name);
  void          (*sync)             (GSettingsBackend    *backend);

  GPermission * (*get_permission)   (GSettingsBackend    *backend,
                                     const gchar         *path);

  GVariant *    (*read_user_value)  (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     const GVariantType  *expected_type);

  /*< private >*/
  gpointer padding[23];
};

struct _GSettings
{
  GObject parent_instance;
  GSettingsPrivate *priv;
};
struct _GSettingsClass
{
  GObjectClass parent_class;

  /* Signals */
  void        (*writable_changed)      (GSettings    *settings,
                                        const gchar  *key);
  void        (*changed)               (GSettings    *settings,
                                        const gchar  *key);
  gboolean    (*writable_change_event) (GSettings    *settings,
                                        GQuark        key);
  gboolean    (*change_event)          (GSettings    *settings,
                                        const GQuark *keys,
                                        gint          n_keys);

  gpointer padding[20];
};
struct _GSeekableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  goffset     (* tell)	         (GSeekable    *seekable);

  gboolean    (* can_seek)       (GSeekable    *seekable);
  gboolean    (* seek)	         (GSeekable    *seekable,
				  goffset       offset,
				  GSeekType     type,
				  GCancellable *cancellable,
				  GError      **error);

  gboolean    (* can_truncate)   (GSeekable    *seekable);
  gboolean    (* truncate_fn)    (GSeekable    *seekable,
				  goffset       offset,
				  GCancellable *cancellable,
				  GError       **error);

  /* TODO: Async seek/truncate */
};
struct _GStaticResource {
  /*< private >*/
  const guint8 *data;
  gsize data_len;
  GResource *resource;
  GStaticResource *next;
  gpointer padding;
};

struct _GResolverClass {
  GObjectClass parent_class;

  /* Signals */
  void    ( *reload)                   (GResolver            *resolver);

  /* Virtual methods */
  GList * ( *lookup_by_name)           (GResolver            *resolver,
					const gchar          *hostname,
					GCancellable         *cancellable,
					GError              **error);
  void    ( *lookup_by_name_async)     (GResolver            *resolver,
					const gchar          *hostname,
					GCancellable         *cancellable,
					GAsyncReadyCallback   callback,
					gpointer              user_data);
  GList * ( *lookup_by_name_finish)    (GResolver            *resolver,
					GAsyncResult         *result,
					GError              **error);

  gchar * ( *lookup_by_address)        (GResolver            *resolver,
					GInetAddress         *address,
					GCancellable         *cancellable,
					GError              **error);
  void    ( *lookup_by_address_async)  (GResolver            *resolver,
					GInetAddress         *address,
					GCancellable         *cancellable,
					GAsyncReadyCallback   callback,
					gpointer              user_data);
  gchar * ( *lookup_by_address_finish) (GResolver            *resolver,
					GAsyncResult         *result,
					GError              **error);

  GList * ( *lookup_service)           (GResolver            *resolver,
					const gchar          *rrname,
					GCancellable         *cancellable,
					GError              **error);
  void    ( *lookup_service_async)     (GResolver            *resolver,
					const gchar          *rrname,
					GCancellable         *cancellable,
					GAsyncReadyCallback   callback,
					gpointer              user_data);
  GList * ( *lookup_service_finish)    (GResolver            *resolver,
					GAsyncResult         *result,
					GError              **error);

  GList * ( *lookup_records)           (GResolver            *resolver,
                                        const gchar          *rrname,
                                        GResolverRecordType   record_type,
                                        GCancellable         *cancellable,
                                        GError              **error);

  void    ( *lookup_records_async)     (GResolver            *resolver,
                                        const gchar          *rrname,
                                        GResolverRecordType   record_type,
                                        GCancellable         *cancellable,
                                        GAsyncReadyCallback   callback,
                                        gpointer              user_data);

  GList * ( *lookup_records_finish)    (GResolver            *resolver,
                                        GAsyncResult         *result,
                                        GError              **error);

  /* Padding for future expansion */
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);

};
struct _GResolver {
  GObject parent_instance;

  GResolverPrivate *priv;
};
struct _GRemoteActionGroupInterface
{
  GTypeInterface g_iface;

  void (* activate_action_full)     (GRemoteActionGroup *remote,
                                     const gchar        *action_name,
                                     GVariant           *parameter,
                                     GVariant           *platform_data);

  void (* change_action_state_full) (GRemoteActionGroup *remote,
                                     const gchar        *action_name,
                                     GVariant           *value,
                                     GVariant           *platform_data);
};

struct _GProxyResolverPortalClass {
  GObjectClass parent_class;
};
struct _GProxyResolverInterface {
  GTypeInterface g_iface;

  /* Virtual Table */
  gboolean (* is_supported)  (GProxyResolver       *resolver);

  gchar	** (* lookup)        (GProxyResolver       *resolver,
			      const gchar          *uri,
			      GCancellable         *cancellable,
			      GError              **error);

  void     (* lookup_async)  (GProxyResolver       *resolver,
			      const gchar          *uri,
			      GCancellable         *cancellable,
			      GAsyncReadyCallback   callback,
			      gpointer              user_data);

  gchar	** (* lookup_finish) (GProxyResolver       *resolver,
			      GAsyncResult         *result,
			      GError              **error);
};

struct _GProxyAddressEnumeratorClass
{
  GSocketAddressEnumeratorClass parent_class;

  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
};
struct _GProxyAddressEnumerator
{
  GSocketAddressEnumerator parent_instance;
  GProxyAddressEnumeratorPrivate *priv;
};

struct _GProxyAddressClass
{
  GInetSocketAddressClass parent_class;
};
struct _GProxyAddress
{
  GInetSocketAddress parent_instance;

  /*< private >*/
  GProxyAddressPrivate *priv;
};
struct _GProxyInterface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GIOStream * (* connect)           (GProxy               *proxy,
				     GIOStream            *connection,
				     GProxyAddress        *proxy_address,
				     GCancellable         *cancellable,
				     GError              **error);

  void        (* connect_async)     (GProxy               *proxy,
				     GIOStream            *connection,
				     GProxyAddress	  *proxy_address,
				     GCancellable         *cancellable,
				     GAsyncReadyCallback   callback,
				     gpointer              user_data);

  GIOStream * (* connect_finish)    (GProxy               *proxy,
				     GAsyncResult         *result,
				     GError              **error);

  gboolean    (* supports_hostname) (GProxy             *proxy);
};
struct _GPollableOutputStreamInterface
{
  GTypeInterface g_iface;

  /* Virtual Table */
  gboolean     (*can_poll)          (GPollableOutputStream  *stream);

  gboolean     (*is_writable)       (GPollableOutputStream  *stream);
  GSource *    (*create_source)     (GPollableOutputStream  *stream,
				     GCancellable           *cancellable);
  gssize       (*write_nonblocking) (GPollableOutputStream  *stream,
				     const void             *buffer,
				     gsize                   count,
				     GError                **error);
};
struct _GPollableInputStreamInterface
{
  GTypeInterface g_iface;

  /* Virtual Table */
  gboolean     (*can_poll)         (GPollableInputStream  *stream);

  gboolean     (*is_readable)      (GPollableInputStream  *stream);
  GSource *    (*create_source)    (GPollableInputStream  *stream,
				    GCancellable          *cancellable);
  gssize       (*read_nonblocking) (GPollableInputStream  *stream,
				    void                  *buffer,
				    gsize                  count,
				    GError               **error);
};

struct _GPermissionClass {
  GObjectClass parent_class;

  gboolean (*acquire)        (GPermission          *permission,
                              GCancellable         *cancellable,
                              GError              **error);
  void     (*acquire_async)  (GPermission          *permission,
                              GCancellable         *cancellable,
                              GAsyncReadyCallback   callback,
                              gpointer              user_data);
  gboolean (*acquire_finish) (GPermission          *permission,
                              GAsyncResult         *result,
                              GError              **error);

  gboolean (*release)        (GPermission          *permission,
                              GCancellable         *cancellable,
                              GError              **error);
  void     (*release_async)  (GPermission          *permission,
                              GCancellable         *cancellable,
                              GAsyncReadyCallback   callback,
                              gpointer              user_data);
  gboolean (*release_finish) (GPermission          *permission,
                              GAsyncResult         *result,
                              GError              **error);

  gpointer reserved[16];
};
struct _GPermission
{
  GObject parent_instance;

  /*< private >*/
  GPermissionPrivate *priv;
};

struct _GOutputStreamClass
{
  GObjectClass parent_class;

  /* Sync ops: */

  gssize      (* write_fn)      (GOutputStream            *stream,
                                 const void               *buffer,
                                 gsize                     count,
                                 GCancellable             *cancellable,
                                 GError                  **error);
  gssize      (* splice)        (GOutputStream            *stream,
                                 GInputStream             *source,
                                 GOutputStreamSpliceFlags  flags,
                                 GCancellable             *cancellable,
                                 GError                  **error);
  gboolean    (* flush)	        (GOutputStream            *stream,
                                 GCancellable             *cancellable,
                                 GError                  **error);
  gboolean    (* close_fn)      (GOutputStream            *stream,
                                 GCancellable             *cancellable,
                                 GError                  **error);

  /* Async ops: (optional in derived classes) */

  void        (* write_async)   (GOutputStream            *stream,
                                 const void               *buffer,
                                 gsize                     count,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gssize      (* write_finish)  (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);
  void        (* splice_async)  (GOutputStream            *stream,
                                 GInputStream             *source,
                                 GOutputStreamSpliceFlags  flags,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gssize      (* splice_finish) (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);
  void        (* flush_async)   (GOutputStream            *stream,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gboolean    (* flush_finish)  (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);
  void        (* close_async)   (GOutputStream            *stream,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gboolean    (* close_finish)  (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
};
struct _GOutputStream
{
  GObject parent_instance;

  /*< private >*/
  GOutputStreamPrivate *priv;
};

struct _GOsxAppInfoClass
{
  GObjectClass parent_class;
};

struct _GNetworkServiceClass
{
  GObjectClass parent_class;

};
struct _GNetworkService
{
  GObject parent_instance;

  /*< private >*/
  GNetworkServicePrivate *priv;
};

struct _GNetworkMonitorPortalClass {
  GNetworkMonitorBaseClass parent_class;
};
struct _GNetworkMonitorPortal {
  GNetworkMonitorBase parent_instance;

  GNetworkMonitorPortalPrivate *priv;
};
struct _GNetworkMonitorInterface {
  GTypeInterface g_iface;

  void     (*network_changed)  (GNetworkMonitor      *monitor,
				gboolean              network_available);

  gboolean (*can_reach)        (GNetworkMonitor      *monitor,
				GSocketConnectable   *connectable,
				GCancellable         *cancellable,
				GError              **error);
  void     (*can_reach_async)  (GNetworkMonitor      *monitor,
				GSocketConnectable   *connectable,
				GCancellable         *cancellable,
				GAsyncReadyCallback   callback,
				gpointer              user_data);
  gboolean (*can_reach_finish) (GNetworkMonitor      *monitor,
				GAsyncResult         *result,
				GError              **error);
};

struct _GNetworkAddressClass
{
  GObjectClass parent_class;

};
struct _GNetworkAddress
{
  GObject parent_instance;

  /*< private >*/
  GNetworkAddressPrivate *priv;
};

struct _GNativeSocketAddressClass
{
  GSocketAddressClass parent_class;
};
struct _GNativeSocketAddress
{
  GSocketAddress parent_instance;

  /*< private >*/
  GNativeSocketAddressPrivate *priv;
};

struct _GMountOperationClass
{
  GObjectClass parent_class;

  /* signals: */

  void (* ask_password) (GMountOperation       *op,
			 const char            *message,
			 const char            *default_user,
			 const char            *default_domain,
			 GAskPasswordFlags      flags);

  /**
   * GMountOperationClass::ask_question:
   * @op:
   * @message:
   * @choices: (array zero-terminated=1) (element-type utf8):
   */
  void (* ask_question) (GMountOperation       *op,
			 const char            *message,
			 const char            *choices[]);

  void (* reply)        (GMountOperation       *op,
			 GMountOperationResult  result);

  void (* aborted)      (GMountOperation       *op);

  /**
   * GMountOperationClass::show_processes:
   * @op:
   * @message:
   * @processes: (element-type GPid):
   * @choices: (array zero-terminated=1) (element-type utf8):
   *
   * Since: 2.22
   */
  void (* show_processes) (GMountOperation      *op,
                           const gchar          *message,
                           GArray               *processes,
                           const gchar          *choices[]);

  void (* show_unmount_progress) (GMountOperation *op,
                                  const gchar     *message,
                                  gint64           time_left,
                                  gint64           bytes_left);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
  void (*_g_reserved9) (void);
};
struct _GMountOperation
{
  GObject parent_instance;

  GMountOperationPrivate *priv;
};
struct _GMountIface
{
  GTypeInterface g_iface;

  /* signals */

  void        (* changed)                   (GMount              *mount);
  void        (* unmounted)                 (GMount              *mount);

  /* Virtual Table */

  GFile     * (* get_root)                  (GMount              *mount);
  char      * (* get_name)                  (GMount              *mount);
  GIcon     * (* get_icon)                  (GMount              *mount);
  char      * (* get_uuid)                  (GMount              *mount);
  GVolume   * (* get_volume)                (GMount              *mount);
  GDrive    * (* get_drive)                 (GMount              *mount);
  gboolean    (* can_unmount)               (GMount              *mount);
  gboolean    (* can_eject)                 (GMount              *mount);

  void        (* unmount)                   (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* unmount_finish)            (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* eject)                     (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_finish)              (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* remount)                   (GMount              *mount,
                                             GMountMountFlags     flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* remount_finish)            (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* guess_content_type)        (GMount              *mount,
                                             gboolean             force_rescan,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gchar    ** (* guess_content_type_finish) (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);
  gchar    ** (* guess_content_type_sync)   (GMount              *mount,
                                             gboolean             force_rescan,
                                             GCancellable        *cancellable,
                                             GError             **error);

  /* Signal, not VFunc */
  void        (* pre_unmount)               (GMount              *mount);

  void        (* unmount_with_operation)    (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* unmount_with_operation_finish) (GMount          *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* eject_with_operation)      (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_with_operation_finish) (GMount            *mount,
                                             GAsyncResult        *result,
                                             GError             **error);
  GFile     * (* get_default_location)      (GMount              *mount);

  const gchar * (* get_sort_key)            (GMount              *mount);
  GIcon       * (* get_symbolic_icon)       (GMount              *mount);
};



struct _GMenuLinkIterClass
{
  GObjectClass parent_class;

  gboolean      (*get_next) (GMenuLinkIter  *iter,
                             const gchar   **out_link,
                             GMenuModel    **value);
};
struct _GMenuLinkIter
{
  GObject parent_instance;
  GMenuLinkIterPrivate *priv;
};
struct _GMenuAttributeIterClass
{
  GObjectClass parent_class;

  gboolean      (*get_next) (GMenuAttributeIter  *iter,
                             const gchar        **out_name,
                             GVariant           **value);
};
struct _GMenuAttributeIter
{
  GObject parent_instance;
  GMenuAttributeIterPrivate *priv;
};
struct _GMenuModelClass
{
  GObjectClass parent_class;

  gboolean              (*is_mutable)                       (GMenuModel          *model);
  gint                  (*get_n_items)                      (GMenuModel          *model);
  void                  (*get_item_attributes)              (GMenuModel          *model,
                                                             gint                 item_index,
                                                             GHashTable         **attributes);
  GMenuAttributeIter *  (*iterate_item_attributes)          (GMenuModel          *model,
                                                             gint                 item_index);
  GVariant *            (*get_item_attribute_value)         (GMenuModel          *model,
                                                             gint                 item_index,
                                                             const gchar         *attribute,
                                                             const GVariantType  *expected_type);
  void                  (*get_item_links)                   (GMenuModel          *model,
                                                             gint                 item_index,
                                                             GHashTable         **links);
  GMenuLinkIter *       (*iterate_item_links)               (GMenuModel          *model,
                                                             gint                 item_index);
  GMenuModel *          (*get_item_link)                    (GMenuModel          *model,
                                                             gint                 item_index,
                                                             const gchar         *link);
};
struct _GMenuModel
{
  GObject            parent_instance;
  GMenuModelPrivate *priv;
};



struct _GMemoryOutputStreamClass
{
  GOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GMemoryOutputStream
{
  GOutputStream parent_instance;

  /*< private >*/
  GMemoryOutputStreamPrivate *priv;
};

struct _GMemoryInputStreamClass
{
  GInputStreamClass parent_class;

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GMemoryInputStream
{
  GInputStream parent_instance;

  /*< private >*/
  GMemoryInputStreamPrivate *priv;
};
struct _GLoadableIconIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GInputStream * (* load)        (GLoadableIcon       *icon,
                                  int                  size,
                                  char               **type,
                                  GCancellable        *cancellable,
                                  GError             **error);
  void           (* load_async)  (GLoadableIcon       *icon,
                                  int                  size,
                                  GCancellable        *cancellable,
                                  GAsyncReadyCallback  callback,
                                  gpointer             user_data);
  GInputStream * (* load_finish) (GLoadableIcon       *icon,
                                  GAsyncResult        *res,
                                  char               **type,
                                  GError             **error);
};


struct _GListModelInterface
{
  GTypeInterface g_iface;

  GType     (* get_item_type)   (GListModel *list);

  guint     (* get_n_items)     (GListModel *list);

  gpointer  (* get_item)        (GListModel *list,
                                 guint       position);
};


































































struct _GOutputMessage {
  GSocketAddress         *address;

  GOutputVector          *vectors;
  guint                   num_vectors;

  guint                   bytes_sent;

  GSocketControlMessage **control_messages;
  guint                   num_control_messages;
};
struct _GOutputVector {
  gconstpointer buffer;
  gsize size;
};
struct _GInputMessage {
  GSocketAddress         **address;

  GInputVector            *vectors;
  guint                    num_vectors;

  gsize                    bytes_received;
  gint                     flags;

  GSocketControlMessage ***control_messages;
  guint                   *num_control_messages;
};
struct _GInputVector {
  gpointer buffer;
  gsize size;
};

struct _GIOStreamClass
{
  GObjectClass parent_class;

  GInputStream *  (*get_input_stream)  (GIOStream *stream);
  GOutputStream * (*get_output_stream) (GIOStream *stream);

  gboolean (* close_fn)	    (GIOStream           *stream,
                             GCancellable        *cancellable,
                             GError             **error);
  void     (* close_async)  (GIOStream           *stream,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gboolean (* close_finish) (GIOStream           *stream,
                             GAsyncResult        *result,
                             GError             **error);
  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
  void (*_g_reserved9) (void);
  void (*_g_reserved10) (void);
};
struct _GIOStream
{
  GObject parent_instance;

  /*< private >*/
  GIOStreamPrivate *priv;
};



struct _GInputStreamClass
{
  GObjectClass parent_class;

  /* Sync ops: */

  gssize   (* read_fn)      (GInputStream        *stream,
                             void                *buffer,
                             gsize                count,
                             GCancellable        *cancellable,
                             GError             **error);
  gssize   (* skip)         (GInputStream        *stream,
                             gsize                count,
                             GCancellable        *cancellable,
                             GError             **error);
  gboolean (* close_fn)	    (GInputStream        *stream,
                             GCancellable        *cancellable,
                             GError             **error);

  /* Async ops: (optional in derived classes) */
  void     (* read_async)   (GInputStream        *stream,
                             void                *buffer,
                             gsize                count,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gssize   (* read_finish)  (GInputStream        *stream,
                             GAsyncResult        *result,
                             GError             **error);
  void     (* skip_async)   (GInputStream        *stream,
                             gsize                count,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gssize   (* skip_finish)  (GInputStream        *stream,
                             GAsyncResult        *result,
                             GError             **error);
  void     (* close_async)  (GInputStream        *stream,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gboolean (* close_finish) (GInputStream        *stream,
                             GAsyncResult        *result,
                             GError             **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GInputStream
{
  GObject parent_instance;

  /*< private >*/
  GInputStreamPrivate *priv;
};
struct _GInitableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  gboolean    (* init) (GInitable    *initable,
			GCancellable *cancellable,
			GError      **error);
};

struct _GInetSocketAddressClass
{
  GSocketAddressClass parent_class;
};
struct _GInetSocketAddress
{
  GSocketAddress parent_instance;

  /*< private >*/
  GInetSocketAddressPrivate *priv;
};

struct _GInetAddressMaskClass
{
  GObjectClass parent_class;

};
struct _GInetAddressMask
{
  GObject parent_instance;

  /*< private >*/
  GInetAddressMaskPrivate *priv;
};

struct _GInetAddressClass
{
  GObjectClass parent_class;

  gchar *        (*to_string) (GInetAddress *address);
  const guint8 * (*to_bytes)  (GInetAddress *address);
};
struct _GInetAddress
{
  GObject parent_instance;

  /*< private >*/
  GInetAddressPrivate *priv;
};
struct _GIconIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  guint       (* hash)        (GIcon   *icon);
  gboolean    (* equal)       (GIcon   *icon1,
                               GIcon   *icon2);
  gboolean    (* to_tokens)   (GIcon   *icon,
			       GPtrArray *tokens,
                               gint    *out_version);
  GIcon *     (* from_tokens) (gchar  **tokens,
                               gint     num_tokens,
                               gint     version,
                               GError **error);

  GVariant *  (* serialize)   (GIcon   *icon);
};
struct _GFilterOutputStreamClass
{
  GOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
};
struct _GFilterOutputStream
{
  GOutputStream parent_instance;

  /*< protected >*/
  GOutputStream *base_stream;
};
struct _GFilterInputStreamClass
{
  GInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
};
struct _GFilterInputStream
{
  GInputStream parent_instance;

  /*<protected >*/
  GInputStream *base_stream;
};

struct _GFileOutputStreamClass
{
  GOutputStreamClass parent_class;

  goffset     (* tell)              (GFileOutputStream    *stream);
  gboolean    (* can_seek)          (GFileOutputStream    *stream);
  gboolean    (* seek)	            (GFileOutputStream    *stream,
                                     goffset               offset,
                                     GSeekType             type,
                                     GCancellable         *cancellable,
                                     GError              **error);
  gboolean    (* can_truncate)      (GFileOutputStream    *stream);
  gboolean    (* truncate_fn)       (GFileOutputStream    *stream,
                                     goffset               size,
                                     GCancellable         *cancellable,
                                     GError              **error);
  GFileInfo * (* query_info)        (GFileOutputStream    *stream,
                                     const char           *attributes,
                                     GCancellable         *cancellable,
                                     GError              **error);
  void        (* query_info_async)  (GFileOutputStream     *stream,
                                     const char            *attributes,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GFileInfo * (* query_info_finish) (GFileOutputStream     *stream,
                                     GAsyncResult         *result,
                                     GError              **error);
  char      * (* get_etag)          (GFileOutputStream    *stream);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GFileOutputStream
{
  GOutputStream parent_instance;

  /*< private >*/
  GFileOutputStreamPrivate *priv;
};
struct _GFilenameCompleterClass
{
  GObjectClass parent_class;

  /*< public >*/
  /* signals */
  void (* got_completion_data) (GFilenameCompleter *filename_completer);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
};

struct _GFileMonitorClass
{
  GObjectClass parent_class;

  /* Signals */
  void     (* changed) (GFileMonitor      *monitor,
                        GFile             *file,
                        GFile             *other_file,
                        GFileMonitorEvent  event_type);

  /* Virtual Table */
  gboolean (* cancel)  (GFileMonitor      *monitor);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GFileMonitor
{
  GObject parent_instance;

  /*< private >*/
  GFileMonitorPrivate *priv;
};

struct _GFileIOStreamClass
{
  GIOStreamClass parent_class;

  goffset     (* tell)              (GFileIOStream    *stream);
  gboolean    (* can_seek)          (GFileIOStream    *stream);
  gboolean    (* seek)	            (GFileIOStream    *stream,
                                     goffset               offset,
                                     GSeekType             type,
                                     GCancellable         *cancellable,
                                     GError              **error);
  gboolean    (* can_truncate)      (GFileIOStream    *stream);
  gboolean    (* truncate_fn)       (GFileIOStream    *stream,
                                     goffset               size,
                                     GCancellable         *cancellable,
                                     GError              **error);
  GFileInfo * (* query_info)        (GFileIOStream    *stream,
                                     const char           *attributes,
                                     GCancellable         *cancellable,
                                     GError              **error);
  void        (* query_info_async)  (GFileIOStream     *stream,
                                     const char            *attributes,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GFileInfo * (* query_info_finish) (GFileIOStream     *stream,
                                     GAsyncResult         *result,
                                     GError              **error);
  char      * (* get_etag)          (GFileIOStream    *stream);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GFileIOStream
{
  GIOStream parent_instance;

  /*< private >*/
  GFileIOStreamPrivate *priv;
};

struct _GFileInputStreamClass
{
  GInputStreamClass parent_class;

  goffset     (* tell)              (GFileInputStream     *stream);
  gboolean    (* can_seek)          (GFileInputStream     *stream);
  gboolean    (* seek)	            (GFileInputStream     *stream,
                                     goffset               offset,
                                     GSeekType             type,
                                     GCancellable         *cancellable,
                                     GError              **error);
  GFileInfo * (* query_info)        (GFileInputStream     *stream,
                                     const char           *attributes,
                                     GCancellable         *cancellable,
                                     GError              **error);
  void        (* query_info_async)  (GFileInputStream     *stream,
                                     const char           *attributes,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GFileInfo * (* query_info_finish) (GFileInputStream     *stream,
                                     GAsyncResult         *result,
                                     GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GFileInputStream
{
  GInputStream parent_instance;

  /*< private >*/
  GFileInputStreamPrivate *priv;
};



struct _GFileEnumeratorClass
{
  GObjectClass parent_class;

  /* Virtual Table */

  GFileInfo * (* next_file)         (GFileEnumerator      *enumerator,
                                     GCancellable         *cancellable,
                                     GError              **error);
  gboolean    (* close_fn)          (GFileEnumerator      *enumerator,
                                     GCancellable         *cancellable,
                                     GError              **error);

  void        (* next_files_async)  (GFileEnumerator      *enumerator,
                                     int                   num_files,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GList *     (* next_files_finish) (GFileEnumerator      *enumerator,
                                     GAsyncResult         *result,
                                     GError              **error);
  void        (* close_async)       (GFileEnumerator      *enumerator,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  gboolean    (* close_finish)      (GFileEnumerator      *enumerator,
                                     GAsyncResult         *result,
                                     GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
};
struct _GFileEnumerator
{
  GObject parent_instance;

  /*< private >*/
  GFileEnumeratorPrivate *priv;
};
struct _GFileDescriptorBasedIface
{
  GTypeInterface g_iface;

  /* Virtual Table */
  int (*get_fd) (GFileDescriptorBased *fd_based);
};
struct _GFileAttributeInfoList
{
  GFileAttributeInfo *infos;
  int                 n_infos;
};
struct _GFileAttributeInfo
{
  char                    *name;
  GFileAttributeType       type;
  GFileAttributeInfoFlags  flags;
};

struct _GFileIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GFile *             (* dup)                         (GFile         *file);
  guint               (* hash)                        (GFile         *file);
  gboolean            (* equal)                       (GFile         *file1,
                                                       GFile         *file2);
  gboolean            (* is_native)                   (GFile         *file);
  gboolean            (* has_uri_scheme)              (GFile         *file,
                                                       const char    *uri_scheme);
  char *              (* get_uri_scheme)              (GFile         *file);
  char *              (* get_basename)                (GFile         *file);
  char *              (* get_path)                    (GFile         *file);
  char *              (* get_uri)                     (GFile         *file);
  char *              (* get_parse_name)              (GFile         *file);
  GFile *             (* get_parent)                  (GFile         *file);
  gboolean            (* prefix_matches)              (GFile         *prefix,
                                                       GFile         *file);
  char *              (* get_relative_path)           (GFile         *parent,
                                                       GFile         *descendant);
  GFile *             (* resolve_relative_path)       (GFile        *file,
                                                       const char   *relative_path);
  GFile *             (* get_child_for_display_name)  (GFile        *file,
                                                       const char   *display_name,
                                                       GError      **error);

  GFileEnumerator *   (* enumerate_children)          (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* enumerate_children_async)    (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileEnumerator *   (* enumerate_children_finish)   (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileInfo *         (* query_info)                  (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* query_info_async)            (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileInfo *         (* query_info_finish)           (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileInfo *         (* query_filesystem_info)       (GFile                *file,
                                                       const char           *attributes,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* query_filesystem_info_async) (GFile                *file,
                                                       const char           *attributes,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileInfo *         (* query_filesystem_info_finish)(GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GMount *            (* find_enclosing_mount)        (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* find_enclosing_mount_async)  (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GMount *            (* find_enclosing_mount_finish) (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFile *             (* set_display_name)            (GFile                *file,
                                                       const char           *display_name,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* set_display_name_async)      (GFile                *file,
                                                       const char           *display_name,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFile *             (* set_display_name_finish)     (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileAttributeInfoList * (* query_settable_attributes)    (GFile          *file,
                                                             GCancellable   *cancellable,
                                                             GError        **error);
  void                (* _query_settable_attributes_async)  (void);
  void                (* _query_settable_attributes_finish) (void);

  GFileAttributeInfoList * (* query_writable_namespaces)    (GFile          *file,
                                                             GCancellable   *cancellable,
                                                             GError        **error);
  void                (* _query_writable_namespaces_async)  (void);
  void                (* _query_writable_namespaces_finish) (void);

  gboolean            (* set_attribute)               (GFile                *file,
                                                       const char           *attribute,
                                                       GFileAttributeType    type,
                                                       gpointer              value_p,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  gboolean            (* set_attributes_from_info)    (GFile                *file,
                                                       GFileInfo            *info,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* set_attributes_async)        (GFile                *file,
                                                       GFileInfo            *info,
                                                       GFileQueryInfoFlags   flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* set_attributes_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GFileInfo           **info,
                                                       GError              **error);

  GFileInputStream *  (* read_fn)                     (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* read_async)                  (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileInputStream *  (* read_finish)                 (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileOutputStream * (* append_to)                   (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* append_to_async)             (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileOutputStream * (* append_to_finish)            (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileOutputStream * (* create)                      (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* create_async)                (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileOutputStream * (* create_finish)               (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileOutputStream * (* replace)                     (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* replace_async)               (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileOutputStream * (* replace_finish)              (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  gboolean            (* delete_file)                 (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* delete_file_async)           (GFile                *file,
						       int                   io_priority,
						       GCancellable         *cancellable,
						       GAsyncReadyCallback   callback,
						       gpointer              user_data);
  gboolean            (* delete_file_finish)          (GFile                *file,
						       GAsyncResult         *result,
						       GError              **error);

  gboolean            (* trash)                       (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* trash_async)                 (GFile                *file,
						       int                   io_priority,
						       GCancellable         *cancellable,
						       GAsyncReadyCallback   callback,
						       gpointer              user_data);
  gboolean            (* trash_finish)                (GFile                *file,
						       GAsyncResult         *result,
						       GError              **error);

  gboolean            (* make_directory)              (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* make_directory_async)        (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* make_directory_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  gboolean            (* make_symbolic_link)          (GFile                *file,
                                                       const char           *symlink_value,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* _make_symbolic_link_async)   (void);
  void                (* _make_symbolic_link_finish)  (void);

  gboolean            (* copy)                        (GFile                *source,
                                                       GFile                *destination,
                                                       GFileCopyFlags        flags,
                                                       GCancellable         *cancellable,
                                                       GFileProgressCallback progress_callback,
                                                       gpointer              progress_callback_data,
                                                       GError              **error);
  void                (* copy_async)                  (GFile                *source,
                                                       GFile                *destination,
                                                       GFileCopyFlags        flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GFileProgressCallback progress_callback,
                                                       gpointer              progress_callback_data,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* copy_finish)                 (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  gboolean            (* move)                        (GFile                *source,
                                                       GFile                *destination,
                                                       GFileCopyFlags        flags,
                                                       GCancellable         *cancellable,
                                                       GFileProgressCallback progress_callback,
                                                       gpointer              progress_callback_data,
                                                       GError              **error);
  void                (* _move_async)                 (void);
  void                (* _move_finish)                (void);

  void                (* mount_mountable)             (GFile                *file,
                                                       GMountMountFlags      flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFile *             (* mount_mountable_finish)      (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* unmount_mountable)           (GFile                *file,
                                                       GMountUnmountFlags    flags,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* unmount_mountable_finish)    (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* eject_mountable)             (GFile                *file,
                                                       GMountUnmountFlags    flags,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* eject_mountable_finish)      (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* mount_enclosing_volume)      (GFile                *location,
                                                       GMountMountFlags      flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean         (* mount_enclosing_volume_finish)  (GFile                *location,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  GFileMonitor *      (* monitor_dir)                 (GFile                *file,
                                                       GFileMonitorFlags     flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  GFileMonitor *      (* monitor_file)                (GFile                *file,
                                                       GFileMonitorFlags     flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);

  GFileIOStream *     (* open_readwrite)              (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* open_readwrite_async)        (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileIOStream *     (* open_readwrite_finish)       (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);
  GFileIOStream *     (* create_readwrite)            (GFile                *file,
						       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* create_readwrite_async)      (GFile                *file,
						       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileIOStream *     (* create_readwrite_finish)      (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);
  GFileIOStream *     (* replace_readwrite)           (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* replace_readwrite_async)     (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileIOStream *     (* replace_readwrite_finish)    (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  void                (* start_mountable)             (GFile                *file,
                                                       GDriveStartFlags      flags,
                                                       GMountOperation      *start_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* start_mountable_finish)      (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* stop_mountable)              (GFile                *file,
                                                       GMountUnmountFlags    flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* stop_mountable_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  gboolean            supports_thread_contexts;

  void                (* unmount_mountable_with_operation) (GFile           *file,
                                                       GMountUnmountFlags    flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* unmount_mountable_with_operation_finish) (GFile    *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* eject_mountable_with_operation) (GFile             *file,
                                                       GMountUnmountFlags    flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* eject_mountable_with_operation_finish) (GFile      *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* poll_mountable)              (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* poll_mountable_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  gboolean            (* measure_disk_usage)          (GFile                         *file,
                                                       GFileMeasureFlags              flags,
                                                       GCancellable                  *cancellable,
                                                       GFileMeasureProgressCallback   progress_callback,
                                                       gpointer                       progress_data,
                                                       guint64                       *disk_usage,
                                                       guint64                       *num_dirs,
                                                       guint64                       *num_files,
                                                       GError                       **error);
  void                (* measure_disk_usage_async)    (GFile                         *file,
                                                       GFileMeasureFlags              flags,
                                                       gint                           io_priority,
                                                       GCancellable                  *cancellable,
                                                       GFileMeasureProgressCallback   progress_callback,
                                                       gpointer                       progress_data,
                                                       GAsyncReadyCallback            callback,
                                                       gpointer                       user_data);
  gboolean            (* measure_disk_usage_finish)   (GFile                         *file,
                                                       GAsyncResult                  *result,
                                                       guint64                       *disk_usage,
                                                       guint64                       *num_dirs,
                                                       guint64                       *num_files,
                                                       GError                       **error);
};

struct _GEmblemedIconClass
{
  GObjectClass parent_class;
};
struct _GEmblemedIcon
{
  GObject parent_instance;

  /*< private >*/
  GEmblemedIconPrivate *priv;
};


struct _GDtlsServerConnectionInterface
{
  GTypeInterface g_iface;
};
struct _GDtlsConnectionInterface
{
  GTypeInterface g_iface;

  /* signals */
  gboolean (*accept_certificate) (GDtlsConnection       *connection,
                                  GTlsCertificate       *peer_cert,
                                  GTlsCertificateFlags   errors);

  /* methods */
  gboolean (*handshake)          (GDtlsConnection       *conn,
                                  GCancellable          *cancellable,
                                  GError               **error);

  void     (*handshake_async)    (GDtlsConnection       *conn,
                                  int                    io_priority,
                                  GCancellable          *cancellable,
                                  GAsyncReadyCallback    callback,
                                  gpointer               user_data);
  gboolean (*handshake_finish)   (GDtlsConnection       *conn,
                                  GAsyncResult          *result,
                                  GError               **error);

  gboolean (*shutdown)           (GDtlsConnection       *conn,
                                  gboolean               shutdown_read,
                                  gboolean               shutdown_write,
                                  GCancellable          *cancellable,
                                  GError               **error);

  void     (*shutdown_async)     (GDtlsConnection       *conn,
                                  gboolean               shutdown_read,
                                  gboolean               shutdown_write,
                                  int                    io_priority,
                                  GCancellable          *cancellable,
                                  GAsyncReadyCallback    callback,
                                  gpointer               user_data);
  gboolean (*shutdown_finish)    (GDtlsConnection       *conn,
                                  GAsyncResult          *result,
                                  GError               **error);
};
struct _GDtlsClientConnectionInterface
{
  GTypeInterface g_iface;
};
struct _GDriveIface
{
  GTypeInterface g_iface;

  /* signals */
  void     (* changed)                  (GDrive              *drive);
  void     (* disconnected)             (GDrive              *drive);
  void     (* eject_button)             (GDrive              *drive);

  /* Virtual Table */
  char *   (* get_name)                 (GDrive              *drive);
  GIcon *  (* get_icon)                 (GDrive              *drive);
  gboolean (* has_volumes)              (GDrive              *drive);
  GList *  (* get_volumes)              (GDrive              *drive);
  gboolean (* is_media_removable)       (GDrive              *drive);
  gboolean (* has_media)                (GDrive              *drive);
  gboolean (* is_media_check_automatic) (GDrive              *drive);
  gboolean (* can_eject)                (GDrive              *drive);
  gboolean (* can_poll_for_media)       (GDrive              *drive);
  void     (* eject)                    (GDrive              *drive,
                                         GMountUnmountFlags   flags,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* eject_finish)             (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);
  void     (* poll_for_media)           (GDrive              *drive,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* poll_for_media_finish)    (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);

  char *   (* get_identifier)           (GDrive              *drive,
                                         const char          *kind);
  char **  (* enumerate_identifiers)    (GDrive              *drive);

  GDriveStartStopType (* get_start_stop_type) (GDrive        *drive);

  gboolean (* can_start)                (GDrive              *drive);
  gboolean (* can_start_degraded)       (GDrive              *drive);
  void     (* start)                    (GDrive              *drive,
                                         GDriveStartFlags     flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* start_finish)             (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);

  gboolean (* can_stop)                 (GDrive              *drive);
  void     (* stop)                     (GDrive              *drive,
                                         GMountUnmountFlags   flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* stop_finish)              (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);
  /* signal, not VFunc */
  void     (* stop_button)              (GDrive              *drive);

  void        (* eject_with_operation)      (GDrive              *drive,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_with_operation_finish) (GDrive            *drive,
                                             GAsyncResult        *result,
                                             GError             **error);

  const gchar * (* get_sort_key)        (GDrive              *drive);
  GIcon *       (* get_symbolic_icon)   (GDrive              *drive);
  gboolean      (* is_removable)        (GDrive              *drive);

};


struct _GDesktopAppInfoLookupIface
{
  GTypeInterface g_iface;

  GAppInfo * (* get_default_for_uri_scheme) (GDesktopAppInfoLookup *lookup,
                                             const char            *uri_scheme);
};
struct _GDesktopAppInfoClass
{
  GObjectClass parent_class;
};

struct _GDBusProxyClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  /* Signals */
  void (*g_properties_changed) (GDBusProxy          *proxy,
                                GVariant            *changed_properties,
                                const gchar* const  *invalidated_properties);
  void (*g_signal)             (GDBusProxy          *proxy,
                                const gchar         *sender_name,
                                const gchar         *signal_name,
                                GVariant            *parameters);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[32];
};
struct _GDBusProxy
{
  /*< private >*/
  GObject parent_instance;
  GDBusProxyPrivate *priv;
};

struct _GDBusObjectSkeletonClass
{
  GObjectClass parent_class;

  /* Signals */
  gboolean (*authorize_method) (GDBusObjectSkeleton       *object,
                                GDBusInterfaceSkeleton    *interface_,
                                GDBusMethodInvocation *invocation);

  /*< private >*/
  gpointer padding[8];
};
struct _GDBusObjectSkeleton
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectSkeletonPrivate *priv;
};

struct _GDBusObjectProxyClass
{
  GObjectClass parent_class;

  /*< private >*/
  gpointer padding[8];
};
struct _GDBusObjectProxy
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectProxyPrivate *priv;
};

struct _GDBusObjectManagerServerClass
{
  GObjectClass parent_class;

  /*< private >*/
  gpointer padding[8];
};
struct _GDBusObjectManagerServer
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectManagerServerPrivate *priv;
};

struct _GDBusObjectManagerClientClass
{
  GObjectClass parent_class;

  /* signals */
  void    (*interface_proxy_signal)             (GDBusObjectManagerClient *manager,
                                                 GDBusObjectProxy         *object_proxy,
                                                 GDBusProxy               *interface_proxy,
                                                 const gchar              *sender_name,
                                                 const gchar              *signal_name,
                                                 GVariant                 *parameters);

  void    (*interface_proxy_properties_changed) (GDBusObjectManagerClient   *manager,
                                                 GDBusObjectProxy           *object_proxy,
                                                 GDBusProxy                 *interface_proxy,
                                                 GVariant                   *changed_properties,
                                                 const gchar* const         *invalidated_properties);

  /*< private >*/
  gpointer padding[8];
};
struct _GDBusObjectManagerClient
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectManagerClientPrivate *priv;
};
struct _GDBusObjectManagerIface
{
  GTypeInterface parent_iface;

  /* Virtual Functions */
  const gchar     *(*get_object_path) (GDBusObjectManager    *manager);
  GList           *(*get_objects)     (GDBusObjectManager    *manager);
  GDBusObject     *(*get_object)      (GDBusObjectManager    *manager,
                                       const gchar           *object_path);
  GDBusInterface  *(*get_interface)   (GDBusObjectManager    *manager,
                                       const gchar           *object_path,
                                       const gchar           *interface_name);

  /* Signals */
  void    (*object_added)                 (GDBusObjectManager   *manager,
                                           GDBusObject          *object);
  void    (*object_removed)               (GDBusObjectManager   *manager,
                                           GDBusObject          *object);

  void    (*interface_added)              (GDBusObjectManager   *manager,
                                           GDBusObject          *object,
                                           GDBusInterface       *interface_);
  void    (*interface_removed)            (GDBusObjectManager   *manager,
                                           GDBusObject          *object,
                                           GDBusInterface       *interface_);
};
struct _GDBusObjectIface
{
  GTypeInterface parent_iface;

  /* Virtual Functions */
  const gchar     *(*get_object_path) (GDBusObject  *object);
  GList           *(*get_interfaces)  (GDBusObject  *object);
  GDBusInterface  *(*get_interface)   (GDBusObject  *object,
                                       const gchar  *interface_name);

  /* Signals */
  void (*interface_added)   (GDBusObject     *object,
                             GDBusInterface  *interface_);
  void (*interface_removed) (GDBusObject     *object,
                             GDBusInterface  *interface_);

};

struct _GDBusNodeInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *path;
  GDBusInterfaceInfo  **interfaces;
  GDBusNodeInfo       **nodes;
  GDBusAnnotationInfo **annotations;
};
struct _GDBusInterfaceInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  GDBusMethodInfo     **methods;
  GDBusSignalInfo     **signals;
  GDBusPropertyInfo   **properties;
  GDBusAnnotationInfo **annotations;
};
struct _GDBusPropertyInfo
{
  /*< public >*/
  volatile gint             ref_count;
  gchar                    *name;
  gchar                    *signature;
  GDBusPropertyInfoFlags    flags;
  GDBusAnnotationInfo     **annotations;
};
struct _GDBusSignalInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  GDBusArgInfo        **args;
  GDBusAnnotationInfo **annotations;
};
struct _GDBusMethodInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  GDBusArgInfo        **in_args;
  GDBusArgInfo        **out_args;
  GDBusAnnotationInfo **annotations;
};
struct _GDBusArgInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  gchar                *signature;
  GDBusAnnotationInfo **annotations;
};
struct _GDBusAnnotationInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *key;
  gchar                *value;
  GDBusAnnotationInfo **annotations;
};

struct _GDBusInterfaceSkeletonClass
{
  GObjectClass parent_class;

  /* Virtual Functions */
  GDBusInterfaceInfo   *(*get_info)       (GDBusInterfaceSkeleton  *interface_);
  GDBusInterfaceVTable *(*get_vtable)     (GDBusInterfaceSkeleton  *interface_);
  GVariant             *(*get_properties) (GDBusInterfaceSkeleton  *interface_);
  void                  (*flush)          (GDBusInterfaceSkeleton  *interface_);

  /*< private >*/
  gpointer vfunc_padding[8];
  /*< public >*/

  /* Signals */
  gboolean (*g_authorize_method) (GDBusInterfaceSkeleton  *interface_,
                                  GDBusMethodInvocation   *invocation);

  /*< private >*/
  gpointer signal_padding[8];
};
struct _GDBusInterfaceSkeleton
{
  /*< private >*/
  GObject parent_instance;
  GDBusInterfaceSkeletonPrivate *priv;
};
struct _GDBusInterfaceIface
{
  GTypeInterface parent_iface;

  /* Virtual Functions */
  GDBusInterfaceInfo   *(*get_info)   (GDBusInterface      *interface_);
  GDBusObject          *(*get_object) (GDBusInterface      *interface_);
  void                  (*set_object) (GDBusInterface      *interface_,
                                       GDBusObject         *object);
  GDBusObject          *(*dup_object) (GDBusInterface      *interface_);
};
struct _GDBusErrorEntry
{
  gint         error_code;
  const gchar *dbus_error_name;
};
struct _GDBusSubtreeVTable
{
  GDBusSubtreeEnumerateFunc  enumerate;
  GDBusSubtreeIntrospectFunc introspect;
  GDBusSubtreeDispatchFunc   dispatch;

  /*< private >*/
  /* Padding for future expansion - also remember to update
   * gdbusconnection.c:_g_dbus_subtree_vtable_copy() when
   * changing this.
   */
  gpointer padding[8];
};
struct _GDBusInterfaceVTable
{
  GDBusInterfaceMethodCallFunc  method_call;
  GDBusInterfaceGetPropertyFunc get_property;
  GDBusInterfaceSetPropertyFunc set_property;

  /*< private >*/
  /* Padding for future expansion - also remember to update
   * gdbusconnection.c:_g_dbus_interface_vtable_copy() when
   * changing this.
   */
  gpointer padding[8];
};

struct _GDataOutputStreamClass
{
  GFilterOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GDataOutputStream
{
  GFilterOutputStream parent_instance;

  /*< private >*/
  GDataOutputStreamPrivate *priv;
};

struct _GDataInputStreamClass
{
  GBufferedInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GDataInputStream
{
  GBufferedInputStream parent_instance;

  /*< private >*/
  GDataInputStreamPrivate *priv;
};
struct _GDatagramBasedInterface
{
  GTypeInterface g_iface;

  /* Virtual table */
  gint          (*receive_messages)     (GDatagramBased       *datagram_based,
                                         GInputMessage        *messages,
                                         guint                 num_messages,
                                         gint                  flags,
                                         gint64                timeout,
                                         GCancellable         *cancellable,
                                         GError              **error);
  gint          (*send_messages)        (GDatagramBased       *datagram_based,
                                         GOutputMessage       *messages,
                                         guint                 num_messages,
                                         gint                  flags,
                                         gint64                timeout,
                                         GCancellable         *cancellable,
                                         GError              **error);

  GSource      *(*create_source)        (GDatagramBased       *datagram_based,
                                         GIOCondition          condition,
                                         GCancellable         *cancellable);
  GIOCondition  (*condition_check)      (GDatagramBased       *datagram_based,
                                         GIOCondition          condition);
  gboolean      (*condition_wait)       (GDatagramBased       *datagram_based,
                                         GIOCondition          condition,
                                         gint64                timeout,
                                         GCancellable         *cancellable,
                                         GError              **error);
};


struct _GConverterOutputStreamClass
{
  GFilterOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GConverterOutputStream
{
  GFilterOutputStream parent_instance;

  /*< private >*/
  GConverterOutputStreamPrivate *priv;
};

struct _GConverterInputStreamClass
{
  GFilterInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GConverterInputStream
{
  GFilterInputStream parent_instance;

  /*< private >*/
  GConverterInputStreamPrivate *priv;
};
struct _GConverterIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GConverterResult (* convert) (GConverter *converter,
				const void *inbuf,
				gsize       inbuf_size,
				void       *outbuf,
				gsize       outbuf_size,
				GConverterFlags flags,
				gsize      *bytes_read,
				gsize      *bytes_written,
				GError    **error);
  void  (* reset)   (GConverter *converter);
};
struct _GCharsetConverterClass
{
  GObjectClass parent_class;
};

struct _GCancellableClass
{
  GObjectClass parent_class;

  void (* cancelled) (GCancellable *cancellable);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GCancellable
{
  GObject parent_instance;

  /*< private >*/
  GCancellablePrivate *priv;
};

struct _GBufferedOutputStreamClass
{
  GFilterOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
};
struct _GBufferedOutputStream
{
  GFilterOutputStream parent_instance;

  /*< protected >*/
  GBufferedOutputStreamPrivate *priv;
};

struct _GBufferedInputStreamClass
{
  GFilterInputStreamClass parent_class;

  gssize   (* fill)        (GBufferedInputStream *stream,
			    gssize                count,
			    GCancellable         *cancellable,
			    GError              **error);

  /* Async ops: (optional in derived classes) */
  void     (* fill_async)  (GBufferedInputStream *stream,
			    gssize                count,
			    int                   io_priority,
			    GCancellable         *cancellable,
			    GAsyncReadyCallback   callback,
			    gpointer              user_data);
  gssize   (* fill_finish) (GBufferedInputStream *stream,
			    GAsyncResult         *result,
			    GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
struct _GBufferedInputStream
{
  GFilterInputStream parent_instance;

  /*< private >*/
  GBufferedInputStreamPrivate *priv;
};
struct _GAsyncResultIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  gpointer  (* get_user_data)     (GAsyncResult *res);
  GObject * (* get_source_object) (GAsyncResult *res);

  gboolean  (* is_tagged)         (GAsyncResult *res,
				   gpointer      source_tag);
};
struct _GAsyncInitableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  void     (* init_async)  (GAsyncInitable      *initable,
			    int                  io_priority,
			    GCancellable        *cancellable,
			    GAsyncReadyCallback  callback,
			    gpointer             user_data);
  gboolean (* init_finish) (GAsyncInitable      *initable,
			    GAsyncResult        *res,
			    GError             **error);
};

struct _GApplicationCommandLineClass
{
  /*< private >*/
  GObjectClass parent_class;

  void                  (* print_literal)       (GApplicationCommandLine *cmdline,
                                                 const gchar             *message);
  void                  (* printerr_literal)    (GApplicationCommandLine *cmdline,
                                                 const gchar             *message);
  GInputStream *        (* get_stdin)           (GApplicationCommandLine *cmdline);

  gpointer padding[11];
};
struct _GApplicationCommandLine
{
  /*< private >*/
  GObject parent_instance;

  GApplicationCommandLinePrivate *priv;
};

struct _GApplicationClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  /* signals */
  void                      (* startup)             (GApplication              *application);

  void                      (* activate)            (GApplication              *application);

  void                      (* open)                (GApplication              *application,
                                                     GFile                    **files,
                                                     gint                       n_files,
                                                     const gchar               *hint);

  int                       (* command_line)        (GApplication              *application,
                                                     GApplicationCommandLine   *command_line);

  /* vfuncs */

  /**
   * GApplicationClass::local_command_line:
   * @application: a #GApplication
   * @arguments: (inout) (array zero-terminated=1): array of command line arguments
   * @exit_status: (out): exit status to fill after processing the command line.
   *
   * This virtual function is always invoked in the local instance. It
   * gets passed a pointer to a %NULL-terminated copy of @argv and is
   * expected to remove arguments that it handled (shifting up remaining
   * arguments).
   *
   * The last argument to local_command_line() is a pointer to the @status
   * variable which can used to set the exit status that is returned from
   * g_application_run().
   *
   * See g_application_run() for more details on #GApplication startup.
   *
   * Returns: %TRUE if the commandline has been completely handled
   */
  gboolean                  (* local_command_line)  (GApplication              *application,
                                                     gchar                   ***arguments,
                                                     int                       *exit_status);

  void                      (* before_emit)         (GApplication              *application,
                                                     GVariant                  *platform_data);
  void                      (* after_emit)          (GApplication              *application,
                                                     GVariant                  *platform_data);
  void                      (* add_platform_data)   (GApplication              *application,
                                                     GVariantBuilder           *builder);
  void                      (* quit_mainloop)       (GApplication              *application);
  void                      (* run_mainloop)        (GApplication              *application);
  void                      (* shutdown)            (GApplication              *application);

  gboolean                  (* dbus_register)       (GApplication              *application,
                                                     GDBusConnection           *connection,
                                                     const gchar               *object_path,
                                                     GError                   **error);
  void                      (* dbus_unregister)     (GApplication              *application,
                                                     GDBusConnection           *connection,
                                                     const gchar               *object_path);
  gint                      (* handle_local_options)(GApplication              *application,
                                                     GVariantDict              *options);

  /*< private >*/
  gpointer padding[8];
};
struct _GApplication
{
  /*< private >*/
  GObject parent_instance;

  GApplicationPrivate *priv;
};


struct _GAppLaunchContextClass
{
  GObjectClass parent_class;

  char * (* get_display)           (GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GList             *files);
  char * (* get_startup_notify_id) (GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GList             *files);
  void   (* launch_failed)         (GAppLaunchContext *context,
                                    const char        *startup_notify_id);
  void   (* launched)              (GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GVariant          *platform_data);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
};
struct _GAppLaunchContext
{
  GObject parent_instance;

  /*< private >*/
  GAppLaunchContextPrivate *priv;
};
struct _GAppInfoIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GAppInfo *   (* dup)                          (GAppInfo           *appinfo);
  gboolean     (* equal)                        (GAppInfo           *appinfo1,
                                                 GAppInfo           *appinfo2);
  const char * (* get_id)                       (GAppInfo           *appinfo);
  const char * (* get_name)                     (GAppInfo           *appinfo);
  const char * (* get_description)              (GAppInfo           *appinfo);
  const char * (* get_executable)               (GAppInfo           *appinfo);
  GIcon *      (* get_icon)                     (GAppInfo           *appinfo);
  gboolean     (* launch)                       (GAppInfo           *appinfo,
                                                 GList              *files,
                                                 GAppLaunchContext  *context,
                                                 GError            **error);
  gboolean     (* supports_uris)                (GAppInfo           *appinfo);
  gboolean     (* supports_files)               (GAppInfo           *appinfo);
  gboolean     (* launch_uris)                  (GAppInfo           *appinfo,
                                                 GList              *uris,
                                                 GAppLaunchContext  *context,
                                                 GError            **error);
  gboolean     (* should_show)                  (GAppInfo           *appinfo);

  /* For changing associations */
  gboolean     (* set_as_default_for_type)      (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  gboolean     (* set_as_default_for_extension) (GAppInfo           *appinfo,
                                                 const char         *extension,
                                                 GError            **error);
  gboolean     (* add_supports_type)            (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  gboolean     (* can_remove_supports_type)     (GAppInfo           *appinfo);
  gboolean     (* remove_supports_type)         (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  gboolean     (* can_delete)                   (GAppInfo           *appinfo);
  gboolean     (* do_delete)                    (GAppInfo           *appinfo);
  const char * (* get_commandline)              (GAppInfo           *appinfo);
  const char * (* get_display_name)             (GAppInfo           *appinfo);
  gboolean     (* set_as_last_used_for_type)    (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  const char ** (* get_supported_types)         (GAppInfo           *appinfo);
};
struct _GActionEntry
{
  const gchar *name;

  void (* activate) (GSimpleAction *action,
                     GVariant      *parameter,
                     gpointer       user_data);

  const gchar *parameter_type;

  const gchar *state;

  void (* change_state) (GSimpleAction *action,
                         GVariant      *value,
                         gpointer       user_data);

  /*< private >*/
  gsize padding[3];
};
struct _GActionMapInterface
{
  GTypeInterface g_iface;

  GAction * (* lookup_action) (GActionMap  *action_map,
                               const gchar *action_name);
  void      (* add_action)    (GActionMap  *action_map,
                               GAction     *action);
  void      (* remove_action) (GActionMap  *action_map,
                               const gchar *action_name);
};
struct _GActionGroupInterface
{
  GTypeInterface g_iface;

  /* virtual functions */
  gboolean              (* has_action)                 (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  gchar **              (* list_actions)               (GActionGroup  *action_group);

  gboolean              (* get_action_enabled)         (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  const GVariantType *  (* get_action_parameter_type)  (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  const GVariantType *  (* get_action_state_type)      (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  GVariant *            (* get_action_state_hint)      (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  GVariant *            (* get_action_state)           (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  void                  (* change_action_state)        (GActionGroup  *action_group,
                                                        const gchar   *action_name,
                                                        GVariant      *value);

  void                  (* activate_action)            (GActionGroup  *action_group,
                                                        const gchar   *action_name,
                                                        GVariant      *parameter);

  /* signals */
  void                  (* action_added)               (GActionGroup  *action_group,
                                                        const gchar   *action_name);
  void                  (* action_removed)             (GActionGroup  *action_group,
                                                        const gchar   *action_name);
  void                  (* action_enabled_changed)     (GActionGroup  *action_group,
                                                        const gchar   *action_name,
                                                        gboolean       enabled);
  void                  (* action_state_changed)       (GActionGroup   *action_group,
                                                        const gchar    *action_name,
                                                        GVariant       *state);

  /* more virtual functions */
  gboolean              (* query_action)               (GActionGroup        *action_group,
                                                        const gchar         *action_name,
                                                        gboolean            *enabled,
                                                        const GVariantType **parameter_type,
                                                        const GVariantType **state_type,
                                                        GVariant           **state_hint,
                                                        GVariant           **state);
};
struct _GActionInterface
{
  GTypeInterface g_iface;

  /* virtual functions */
  const gchar *        (* get_name)             (GAction  *action);
  const GVariantType * (* get_parameter_type)   (GAction  *action);
  const GVariantType * (* get_state_type)       (GAction  *action);
  GVariant *           (* get_state_hint)       (GAction  *action);

  gboolean             (* get_enabled)          (GAction  *action);
  GVariant *           (* get_state)            (GAction  *action);

  void                 (* change_state)         (GAction  *action,
                                                 GVariant *value);
  void                 (* activate)             (GAction  *action,
                                                 GVariant *parameter);
};
GXdpProxyResolver  * gxdp_proxy_resolver_skeleton_new(void);
GType gxdp_proxy_resolver_skeleton_get_type(void);
GXdpProxyResolver  * gxdp_proxy_resolver_proxy_new_for_bus_sync(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpProxyResolver  * gxdp_proxy_resolver_proxy_new_for_bus_finish(GAsyncResult        *res, GError             **error);
void gxdp_proxy_resolver_proxy_new_for_bus(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GXdpProxyResolver  * gxdp_proxy_resolver_proxy_new_sync(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpProxyResolver  * gxdp_proxy_resolver_proxy_new_finish(GAsyncResult        *res, GError             **error);
void gxdp_proxy_resolver_proxy_new(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GType gxdp_proxy_resolver_proxy_get_type(void);
gboolean gxdp_proxy_resolver_call_lookup_sync(GXdpProxyResolver *proxy, const gchar *arg_uri, gchar ***out_proxies, GCancellable *cancellable, GError **error);
gboolean gxdp_proxy_resolver_call_lookup_finish(GXdpProxyResolver *proxy, gchar ***out_proxies, GAsyncResult *res, GError **error);
void gxdp_proxy_resolver_call_lookup(GXdpProxyResolver *proxy, const gchar *arg_uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
void gxdp_proxy_resolver_complete_lookup(GXdpProxyResolver *object, GDBusMethodInvocation *invocation, const gchar *const *proxies);
guint gxdp_proxy_resolver_override_properties(GObjectClass *klass, guint property_id_begin);
GDBusInterfaceInfo  * gxdp_proxy_resolver_interface_info(void);
GType gxdp_proxy_resolver_get_type(void);
GXdpNetworkMonitor  * gxdp_network_monitor_skeleton_new(void);
GType gxdp_network_monitor_skeleton_get_type(void);
GXdpNetworkMonitor  * gxdp_network_monitor_proxy_new_for_bus_sync(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpNetworkMonitor  * gxdp_network_monitor_proxy_new_for_bus_finish(GAsyncResult        *res, GError             **error);
void gxdp_network_monitor_proxy_new_for_bus(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GXdpNetworkMonitor  * gxdp_network_monitor_proxy_new_sync(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpNetworkMonitor  * gxdp_network_monitor_proxy_new_finish(GAsyncResult        *res, GError             **error);
void gxdp_network_monitor_proxy_new(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GType gxdp_network_monitor_proxy_get_type(void);
void gxdp_network_monitor_set_version(GXdpNetworkMonitor *object, guint value);
guint gxdp_network_monitor_get_version(GXdpNetworkMonitor *object);
gboolean gxdp_network_monitor_call_get_connectivity_sync(GXdpNetworkMonitor *proxy, guint *out_connectivity, GCancellable *cancellable, GError **error);
gboolean gxdp_network_monitor_call_get_connectivity_finish(GXdpNetworkMonitor *proxy, guint *out_connectivity, GAsyncResult *res, GError **error);
void gxdp_network_monitor_call_get_connectivity(GXdpNetworkMonitor *proxy, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_network_monitor_call_get_metered_sync(GXdpNetworkMonitor *proxy, gboolean *out_metered, GCancellable *cancellable, GError **error);
gboolean gxdp_network_monitor_call_get_metered_finish(GXdpNetworkMonitor *proxy, gboolean *out_metered, GAsyncResult *res, GError **error);
void gxdp_network_monitor_call_get_metered(GXdpNetworkMonitor *proxy, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_network_monitor_call_get_available_sync(GXdpNetworkMonitor *proxy, gboolean *out_available, GCancellable *cancellable, GError **error);
gboolean gxdp_network_monitor_call_get_available_finish(GXdpNetworkMonitor *proxy, gboolean *out_available, GAsyncResult *res, GError **error);
void gxdp_network_monitor_call_get_available(GXdpNetworkMonitor *proxy, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
void gxdp_network_monitor_emit_changed(GXdpNetworkMonitor *object);
void gxdp_network_monitor_complete_get_connectivity(GXdpNetworkMonitor *object, GDBusMethodInvocation *invocation, guint connectivity);
void gxdp_network_monitor_complete_get_metered(GXdpNetworkMonitor *object, GDBusMethodInvocation *invocation, gboolean metered);
void gxdp_network_monitor_complete_get_available(GXdpNetworkMonitor *object, GDBusMethodInvocation *invocation, gboolean available);
guint gxdp_network_monitor_override_properties(GObjectClass *klass, guint property_id_begin);
GDBusInterfaceInfo  * gxdp_network_monitor_interface_info(void);
GType gxdp_network_monitor_get_type(void);
GXdpOpenURI  * gxdp_open_uri_skeleton_new(void);
GType gxdp_open_uri_skeleton_get_type(void);
GXdpOpenURI  * gxdp_open_uri_proxy_new_for_bus_sync(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpOpenURI  * gxdp_open_uri_proxy_new_for_bus_finish(GAsyncResult        *res, GError             **error);
void gxdp_open_uri_proxy_new_for_bus(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GXdpOpenURI  * gxdp_open_uri_proxy_new_sync(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpOpenURI  * gxdp_open_uri_proxy_new_finish(GAsyncResult        *res, GError             **error);
void gxdp_open_uri_proxy_new(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GType gxdp_open_uri_proxy_get_type(void);
void gxdp_open_uri_set_version(GXdpOpenURI *object, guint value);
guint gxdp_open_uri_get_version(GXdpOpenURI *object);
gboolean gxdp_open_uri_call_open_file_sync(GXdpOpenURI *proxy, const gchar *arg_parent_window, GVariant *arg_fd, GVariant *arg_options, GUnixFDList  *fd_list, gchar **out_handle, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
gboolean gxdp_open_uri_call_open_file_finish(GXdpOpenURI *proxy, gchar **out_handle, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
void gxdp_open_uri_call_open_file(GXdpOpenURI *proxy, const gchar *arg_parent_window, GVariant *arg_fd, GVariant *arg_options, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_open_uri_call_open_uri_sync(GXdpOpenURI *proxy, const gchar *arg_parent_window, const gchar *arg_uri, GVariant *arg_options, gchar **out_handle, GCancellable *cancellable, GError **error);
gboolean gxdp_open_uri_call_open_uri_finish(GXdpOpenURI *proxy, gchar **out_handle, GAsyncResult *res, GError **error);
void gxdp_open_uri_call_open_uri(GXdpOpenURI *proxy, const gchar *arg_parent_window, const gchar *arg_uri, GVariant *arg_options, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
void gxdp_open_uri_complete_open_file(GXdpOpenURI *object, GDBusMethodInvocation *invocation, GUnixFDList *fd_list, const gchar *handle);
void gxdp_open_uri_complete_open_uri(GXdpOpenURI *object, GDBusMethodInvocation *invocation, const gchar *handle);
guint gxdp_open_uri_override_properties(GObjectClass *klass, guint property_id_begin);
GDBusInterfaceInfo  * gxdp_open_uri_interface_info(void);
GType gxdp_open_uri_get_type(void);
GXdpDocuments  * gxdp_documents_skeleton_new(void);
GType gxdp_documents_skeleton_get_type(void);
GXdpDocuments  * gxdp_documents_proxy_new_for_bus_sync(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpDocuments  * gxdp_documents_proxy_new_for_bus_finish(GAsyncResult        *res, GError             **error);
void gxdp_documents_proxy_new_for_bus(GBusType             bus_type, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GXdpDocuments  * gxdp_documents_proxy_new_sync(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GError             **error);
GXdpDocuments  * gxdp_documents_proxy_new_finish(GAsyncResult        *res, GError             **error);
void gxdp_documents_proxy_new(GDBusConnection     *connection, GDBusProxyFlags      flags, const gchar         *name, const gchar         *object_path, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GType gxdp_documents_proxy_get_type(void);
void gxdp_documents_set_version(GXdpDocuments *object, guint value);
guint gxdp_documents_get_version(GXdpDocuments *object);
gboolean gxdp_documents_call_list_sync(GXdpDocuments *proxy, const gchar *arg_app_id, GVariant **out_docs, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_list_finish(GXdpDocuments *proxy, GVariant **out_docs, GAsyncResult *res, GError **error);
void gxdp_documents_call_list(GXdpDocuments *proxy, const gchar *arg_app_id, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_info_sync(GXdpDocuments *proxy, const gchar *arg_doc_id, gchar **out_path, GVariant **out_apps, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_info_finish(GXdpDocuments *proxy, gchar **out_path, GVariant **out_apps, GAsyncResult *res, GError **error);
void gxdp_documents_call_info(GXdpDocuments *proxy, const gchar *arg_doc_id, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_lookup_sync(GXdpDocuments *proxy, const gchar *arg_filename, gchar **out_doc_id, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_lookup_finish(GXdpDocuments *proxy, gchar **out_doc_id, GAsyncResult *res, GError **error);
void gxdp_documents_call_lookup(GXdpDocuments *proxy, const gchar *arg_filename, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_delete_sync(GXdpDocuments *proxy, const gchar *arg_doc_id, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_delete_finish(GXdpDocuments *proxy, GAsyncResult *res, GError **error);
void gxdp_documents_call_delete(GXdpDocuments *proxy, const gchar *arg_doc_id, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_revoke_permissions_sync(GXdpDocuments *proxy, const gchar *arg_doc_id, const gchar *arg_app_id, const gchar *const *arg_permissions, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_revoke_permissions_finish(GXdpDocuments *proxy, GAsyncResult *res, GError **error);
void gxdp_documents_call_revoke_permissions(GXdpDocuments *proxy, const gchar *arg_doc_id, const gchar *arg_app_id, const gchar *const *arg_permissions, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_grant_permissions_sync(GXdpDocuments *proxy, const gchar *arg_doc_id, const gchar *arg_app_id, const gchar *const *arg_permissions, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_grant_permissions_finish(GXdpDocuments *proxy, GAsyncResult *res, GError **error);
void gxdp_documents_call_grant_permissions(GXdpDocuments *proxy, const gchar *arg_doc_id, const gchar *arg_app_id, const gchar *const *arg_permissions, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_add_full_sync(GXdpDocuments *proxy, GVariant *arg_o_path_fds, guint arg_flags, const gchar *arg_app_id, const gchar *const *arg_permissions, GUnixFDList  *fd_list, gchar ***out_doc_ids, GVariant **out_extra_out, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_add_full_finish(GXdpDocuments *proxy, gchar ***out_doc_ids, GVariant **out_extra_out, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
void gxdp_documents_call_add_full(GXdpDocuments *proxy, GVariant *arg_o_path_fds, guint arg_flags, const gchar *arg_app_id, const gchar *const *arg_permissions, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_add_named_sync(GXdpDocuments *proxy, GVariant *arg_o_path_parent_fd, const gchar *arg_filename, gboolean arg_reuse_existing, gboolean arg_persistent, GUnixFDList  *fd_list, gchar **out_doc_id, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_add_named_finish(GXdpDocuments *proxy, gchar **out_doc_id, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
void gxdp_documents_call_add_named(GXdpDocuments *proxy, GVariant *arg_o_path_parent_fd, const gchar *arg_filename, gboolean arg_reuse_existing, gboolean arg_persistent, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_add_sync(GXdpDocuments *proxy, GVariant *arg_o_path_fd, gboolean arg_reuse_existing, gboolean arg_persistent, GUnixFDList  *fd_list, gchar **out_doc_id, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_add_finish(GXdpDocuments *proxy, gchar **out_doc_id, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
void gxdp_documents_call_add(GXdpDocuments *proxy, GVariant *arg_o_path_fd, gboolean arg_reuse_existing, gboolean arg_persistent, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
gboolean gxdp_documents_call_get_mount_point_sync(GXdpDocuments *proxy, gchar **out_path, GCancellable *cancellable, GError **error);
gboolean gxdp_documents_call_get_mount_point_finish(GXdpDocuments *proxy, gchar **out_path, GAsyncResult *res, GError **error);
void gxdp_documents_call_get_mount_point(GXdpDocuments *proxy, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
void gxdp_documents_complete_list(GXdpDocuments *object, GDBusMethodInvocation *invocation, GVariant *docs);
void gxdp_documents_complete_info(GXdpDocuments *object, GDBusMethodInvocation *invocation, const gchar *path, GVariant *apps);
void gxdp_documents_complete_lookup(GXdpDocuments *object, GDBusMethodInvocation *invocation, const gchar *doc_id);
void gxdp_documents_complete_delete(GXdpDocuments *object, GDBusMethodInvocation *invocation);
void gxdp_documents_complete_revoke_permissions(GXdpDocuments *object, GDBusMethodInvocation *invocation);
void gxdp_documents_complete_grant_permissions(GXdpDocuments *object, GDBusMethodInvocation *invocation);
void gxdp_documents_complete_add_full(GXdpDocuments *object, GDBusMethodInvocation *invocation, GUnixFDList *fd_list, const gchar *const *doc_ids, GVariant *extra_out);
void gxdp_documents_complete_add_named(GXdpDocuments *object, GDBusMethodInvocation *invocation, GUnixFDList *fd_list, const gchar *doc_id);
void gxdp_documents_complete_add(GXdpDocuments *object, GDBusMethodInvocation *invocation, GUnixFDList *fd_list, const gchar *doc_id);
void gxdp_documents_complete_get_mount_point(GXdpDocuments *object, GDBusMethodInvocation *invocation, const gchar *path);
guint gxdp_documents_override_properties(GObjectClass *klass, guint property_id_begin);
GDBusInterfaceInfo  * gxdp_documents_interface_info(void);
GType gxdp_documents_get_type(void);
void g_networking_init(void);
GType g_settings_bind_flags_get_type(void);
GType g_network_connectivity_get_type(void);
GType g_notification_priority_get_type(void);
GType g_subprocess_flags_get_type(void);
GType g_test_dbus_flags_get_type(void);
GType g_socket_listener_event_get_type(void);
GType g_socket_client_event_get_type(void);
GType g_io_module_scope_flags_get_type(void);
GType g_tls_certificate_request_flags_get_type(void);
GType g_tls_database_lookup_flags_get_type(void);
GType g_tls_database_verify_flags_get_type(void);
GType g_dbus_object_manager_client_flags_get_type(void);
GType g_dbus_interface_skeleton_flags_get_type(void);
GType g_tls_interaction_result_get_type(void);
GType g_tls_password_flags_get_type(void);
GType g_tls_rehandshake_mode_get_type(void);
GType g_tls_authentication_mode_get_type(void);
GType g_tls_certificate_flags_get_type(void);
GType g_tls_error_get_type(void);
GType g_application_flags_get_type(void);
GType g_dbus_message_byte_order_get_type(void);
GType g_credentials_type_get_type(void);
GType g_dbus_send_message_flags_get_type(void);
GType g_dbus_signal_flags_get_type(void);
GType g_dbus_server_flags_get_type(void);
GType g_dbus_subtree_flags_get_type(void);
GType g_dbus_property_info_flags_get_type(void);
GType g_dbus_message_header_field_get_type(void);
GType g_dbus_message_flags_get_type(void);
GType g_dbus_message_type_get_type(void);
GType g_dbus_call_flags_get_type(void);
GType g_dbus_capability_flags_get_type(void);
GType g_dbus_connection_flags_get_type(void);
GType g_dbus_error_get_type(void);
GType g_dbus_proxy_flags_get_type(void);
GType g_bus_name_watcher_flags_get_type(void);
GType g_bus_name_owner_flags_get_type(void);
GType g_bus_type_get_type(void);
GType g_unix_socket_address_type_get_type(void);
GType g_zlib_compressor_format_get_type(void);
GType g_socket_protocol_get_type(void);
GType g_socket_msg_flags_get_type(void);
GType g_socket_type_get_type(void);
GType g_socket_family_get_type(void);
GType g_resource_lookup_flags_get_type(void);
GType g_resource_flags_get_type(void);
GType g_resource_error_get_type(void);
GType g_resolver_record_type_get_type(void);
GType g_resolver_error_get_type(void);
GType g_emblem_origin_get_type(void);
GType g_io_stream_splice_flags_get_type(void);
GType g_output_stream_splice_flags_get_type(void);
GType g_mount_operation_result_get_type(void);
GType g_password_save_get_type(void);
GType g_ask_password_flags_get_type(void);
GType g_io_error_enum_get_type(void);
GType g_file_monitor_event_get_type(void);
GType g_filesystem_preview_type_get_type(void);
GType g_file_type_get_type(void);
GType g_file_monitor_flags_get_type(void);
GType g_file_copy_flags_get_type(void);
GType g_drive_start_stop_type_get_type(void);
GType g_drive_start_flags_get_type(void);
GType g_mount_unmount_flags_get_type(void);
GType g_mount_mount_flags_get_type(void);
GType g_file_measure_flags_get_type(void);
GType g_file_create_flags_get_type(void);
GType g_file_query_info_flags_get_type(void);
GType g_file_attribute_status_get_type(void);
GType g_file_attribute_info_flags_get_type(void);
GType g_file_attribute_type_get_type(void);
GType g_data_stream_newline_type_get_type(void);
GType g_data_stream_byte_order_get_type(void);
GType g_converter_result_get_type(void);
GType g_converter_flags_get_type(void);
GType g_app_info_create_flags_get_type(void);
GFileInfo          * g_zlib_decompressor_get_file_info(GZlibDecompressor *decompressor);
GZlibDecompressor  * g_zlib_decompressor_new(GZlibCompressorFormat format);
GType g_zlib_decompressor_get_type(void);
void g_zlib_compressor_set_file_info(GZlibCompressor *compressor, GFileInfo       *file_info);
GFileInfo        * g_zlib_compressor_get_file_info(GZlibCompressor *compressor);
GZlibCompressor  * g_zlib_compressor_new(GZlibCompressorFormat format, int level);
GType g_zlib_compressor_get_type(void);
void g_win32_registry_key_erase_change_indicator(GWin32RegistryKey               *key);
gboolean g_win32_registry_key_has_changed(GWin32RegistryKey               *key);
gboolean g_win32_registry_key_watch(GWin32RegistryKey               *key, gboolean                         watch_children, GWin32RegistryKeyWatcherFlags    watch_flags, GWin32RegistryKeyWatchCallbackFunc callback, gpointer                         user_data, GError                         **error);
const gunichar2  * g_win32_registry_key_get_path_w(GWin32RegistryKey               *key);
const gchar      * g_win32_registry_key_get_path(GWin32RegistryKey               *key);
gboolean g_win32_registry_key_get_value_w(GWin32RegistryKey               *key, gboolean                         auto_expand, const gunichar2                 *value_name, GWin32RegistryValueType         *value_type, gpointer                        *value_data, gsize                           *value_data_size, GError                         **error);
gboolean g_win32_registry_key_get_value(GWin32RegistryKey               *key, gboolean                         auto_expand, const gchar                     *value_name, GWin32RegistryValueType         *value_type, gpointer                        *value_data, gsize                           *value_data_size, GError                         **error);
gboolean g_win32_registry_value_iter_get_data_w(GWin32RegistryValueIter         *iter, gboolean                         auto_expand, gpointer                        *value_data, gsize                           *value_data_size, GError                         **error);
gboolean g_win32_registry_value_iter_get_data(GWin32RegistryValueIter         *iter, gboolean                         auto_expand, gpointer                        *value_data, gsize                           *value_data_size, GError                         **error);
gboolean g_win32_registry_value_iter_get_name_w(GWin32RegistryValueIter         *iter, gunichar2                      **value_name, gsize                           *value_name_len, GError                         **error);
gboolean g_win32_registry_value_iter_get_name(GWin32RegistryValueIter         *iter, gchar                          **value_name, gsize                           *value_name_len, GError                         **error);
gboolean g_win32_registry_value_iter_get_value_type(GWin32RegistryValueIter         *iter, GWin32RegistryValueType         *value_type, GError                         **error);
gboolean g_win32_registry_value_iter_next(GWin32RegistryValueIter         *iter, gboolean                         skip_errors, GError                         **error);
gsize g_win32_registry_value_iter_n_values(GWin32RegistryValueIter         *iter);
void g_win32_registry_value_iter_clear(GWin32RegistryValueIter         *iter);
gboolean g_win32_registry_value_iter_init(GWin32RegistryValueIter         *iter, GWin32RegistryKey               *key, GError                         **error);
gboolean g_win32_registry_subkey_iter_get_name_w(GWin32RegistrySubkeyIter        *iter, gunichar2                      **subkey_name, gsize                           *subkey_name_len, GError                         **error);
gboolean g_win32_registry_subkey_iter_get_name(GWin32RegistrySubkeyIter        *iter, gchar                          **subkey_name, gsize                           *subkey_name_len, GError                         **error);
gboolean g_win32_registry_subkey_iter_next(GWin32RegistrySubkeyIter       *iter, gboolean                        skip_errors, GError                        **error);
gsize g_win32_registry_subkey_iter_n_subkeys(GWin32RegistrySubkeyIter       *iter);
void g_win32_registry_subkey_iter_clear(GWin32RegistrySubkeyIter       *iter);
gboolean g_win32_registry_subkey_iter_init(GWin32RegistrySubkeyIter       *iter, GWin32RegistryKey              *key, GError                        **error);
GWin32RegistryKey  * g_win32_registry_key_get_child_w(GWin32RegistryKey              *key, const gunichar2                *subkey, GError                        **error);
GWin32RegistryKey  * g_win32_registry_key_get_child(GWin32RegistryKey              *key, const gchar                    *subkey, GError                        **error);
GWin32RegistryKey  * g_win32_registry_key_new_w(const gunichar2                *path, GError                        **error);
GWin32RegistryKey  * g_win32_registry_key_new(const gchar                    *path, GError                        **error);
GType g_win32_registry_key_get_type(void);
GType g_win32_registry_value_iter_get_type(void);
void g_win32_registry_value_iter_assign(GWin32RegistryValueIter       *iter, const GWin32RegistryValueIter *other);
void g_win32_registry_value_iter_free(GWin32RegistryValueIter       *iter);
GWin32RegistryValueIter   * g_win32_registry_value_iter_copy(const GWin32RegistryValueIter *iter);
GType g_win32_registry_subkey_iter_get_type(void);
void g_win32_registry_subkey_iter_assign(GWin32RegistrySubkeyIter       *iter, const GWin32RegistrySubkeyIter *other);
void g_win32_registry_subkey_iter_free(GWin32RegistrySubkeyIter       *iter);
GWin32RegistrySubkeyIter  * g_win32_registry_subkey_iter_copy(const GWin32RegistrySubkeyIter *iter);
void            * g_win32_output_stream_get_handle(GWin32OutputStream *stream);
gboolean g_win32_output_stream_get_close_handle(GWin32OutputStream *stream);
void g_win32_output_stream_set_close_handle(GWin32OutputStream *stream, gboolean           close_handle);
GOutputStream  * g_win32_output_stream_new(void               *handle, gboolean            close_handle);
GType g_win32_output_stream_get_type(void);
void           * g_win32_input_stream_get_handle(GWin32InputStream *stream);
gboolean g_win32_input_stream_get_close_handle(GWin32InputStream *stream);
void g_win32_input_stream_set_close_handle(GWin32InputStream *stream, gboolean           close_handle);
GInputStream  * g_win32_input_stream_new(void              *handle, gboolean           close_handle);
GType g_win32_input_stream_get_type(void);
GVolume  * g_volume_monitor_adopt_orphan_mount(GMount         *mount);
GMount  * g_volume_monitor_get_mount_for_uuid(GVolumeMonitor *volume_monitor, const char     *uuid);
GVolume  * g_volume_monitor_get_volume_for_uuid(GVolumeMonitor *volume_monitor, const char     *uuid);
GList  * g_volume_monitor_get_mounts(GVolumeMonitor *volume_monitor);
GList  * g_volume_monitor_get_volumes(GVolumeMonitor *volume_monitor);
GList  * g_volume_monitor_get_connected_drives(GVolumeMonitor *volume_monitor);
GVolumeMonitor  * g_volume_monitor_get(void);
GType g_volume_monitor_get_type(void);
const gchar  * g_volume_get_sort_key(GVolume              *volume);
gboolean g_volume_eject_with_operation_finish(GVolume          *volume, GAsyncResult        *result, GError             **error);
void g_volume_eject_with_operation(GVolume             *volume, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GFile  * g_volume_get_activation_root(GVolume              *volume);
char  ** g_volume_enumerate_identifiers(GVolume              *volume);
char  * g_volume_get_identifier(GVolume              *volume, const char           *kind);
gboolean g_volume_eject_finish(GVolume              *volume, GAsyncResult         *result, GError              **error);
void g_volume_eject(GVolume              *volume, GMountUnmountFlags    flags, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_volume_mount_finish(GVolume              *volume, GAsyncResult         *result, GError              **error);
void g_volume_mount(GVolume              *volume, GMountMountFlags      flags, GMountOperation      *mount_operation, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_volume_should_automount(GVolume              *volume);
gboolean g_volume_can_eject(GVolume              *volume);
gboolean g_volume_can_mount(GVolume              *volume);
GMount  * g_volume_get_mount(GVolume              *volume);
GDrive  * g_volume_get_drive(GVolume              *volume);
char  * g_volume_get_uuid(GVolume              *volume);
GIcon  * g_volume_get_symbolic_icon(GVolume              *volume);
GIcon  * g_volume_get_icon(GVolume              *volume);
char  * g_volume_get_name(GVolume              *volume);
GType g_volume_get_type(void);
gboolean g_vfs_unregister_uri_scheme(GVfs               *vfs, const char         *scheme);
gboolean g_vfs_register_uri_scheme(GVfs               *vfs, const char         *scheme, GVfsFileLookupFunc  uri_func, gpointer            uri_data, GDestroyNotify      uri_destroy, GVfsFileLookupFunc  parse_name_func, gpointer            parse_name_data, GDestroyNotify      parse_name_destroy);
GVfs  * g_vfs_get_local(void);
GVfs  * g_vfs_get_default(void);
GFile  * g_vfs_parse_name(GVfs       *vfs, const char *parse_name);
const gchar * const * g_vfs_get_supported_uri_schemes(GVfs       *vfs);
GFile  * g_vfs_get_file_for_uri(GVfs       *vfs, const char *uri);
GFile  * g_vfs_get_file_for_path(GVfs       *vfs, const char *path);
gboolean g_vfs_is_active(GVfs       *vfs);
GType g_vfs_get_type(void);
gboolean g_unix_socket_address_abstract_names_supported(void);
gboolean g_unix_socket_address_get_is_abstract(GUnixSocketAddress *address);
GUnixSocketAddressType g_unix_socket_address_get_address_type(GUnixSocketAddress *address);
gsize g_unix_socket_address_get_path_len(GUnixSocketAddress *address);
const char  * g_unix_socket_address_get_path(GUnixSocketAddress *address);
GSocketAddress  * g_unix_socket_address_new_with_type(const gchar            *path, gint                    path_len, GUnixSocketAddressType  type);
GSocketAddress  * g_unix_socket_address_new_abstract(const gchar        *path, gint                path_len);
GSocketAddress  * g_unix_socket_address_new(const gchar        *path);
GType g_unix_socket_address_get_type(void);
gint g_unix_output_stream_get_fd(GUnixOutputStream *stream);
gboolean g_unix_output_stream_get_close_fd(GUnixOutputStream *stream);
void g_unix_output_stream_set_close_fd(GUnixOutputStream *stream, gboolean           close_fd);
GOutputStream  * g_unix_output_stream_new(gint     fd, gboolean close_fd);
GType g_unix_output_stream_get_type(void);
gboolean g_unix_is_system_device_path(const char *device_path);
gboolean g_unix_is_system_fs_type(const char *fs_type);
gboolean g_unix_is_mount_path_system_internal(const char *mount_path);
void g_unix_mount_monitor_set_rate_limit(GUnixMountMonitor *mount_monitor, int                limit_msec);
GUnixMountMonitor  * g_unix_mount_monitor_new(void);
GUnixMountMonitor  * g_unix_mount_monitor_get(void);
GType g_unix_mount_monitor_get_type(void);
gboolean g_unix_mount_points_changed_since(guint64             time);
gboolean g_unix_mounts_changed_since(guint64             time);
GUnixMountEntry  * g_unix_mount_for(const char         *file_path, guint64            *time_read);
GUnixMountEntry  * g_unix_mount_at(const char         *mount_path, guint64            *time_read);
GList  * g_unix_mounts_get(guint64            *time_read);
GList  * g_unix_mount_points_get(guint64            *time_read);
GIcon  * g_unix_mount_point_guess_symbolic_icon(GUnixMountPoint    *mount_point);
GIcon  * g_unix_mount_point_guess_icon(GUnixMountPoint    *mount_point);
char  * g_unix_mount_point_guess_name(GUnixMountPoint    *mount_point);
gboolean g_unix_mount_point_guess_can_eject(GUnixMountPoint    *mount_point);
gboolean g_unix_mount_point_is_loopback(GUnixMountPoint    *mount_point);
gboolean g_unix_mount_point_is_user_mountable(GUnixMountPoint    *mount_point);
gboolean g_unix_mount_point_is_readonly(GUnixMountPoint    *mount_point);
const char  * g_unix_mount_point_get_options(GUnixMountPoint    *mount_point);
const char  * g_unix_mount_point_get_fs_type(GUnixMountPoint    *mount_point);
const char  * g_unix_mount_point_get_device_path(GUnixMountPoint    *mount_point);
const char  * g_unix_mount_point_get_mount_path(GUnixMountPoint    *mount_point);
gint g_unix_mount_point_compare(GUnixMountPoint    *mount1, GUnixMountPoint    *mount2);
GIcon  * g_unix_mount_guess_symbolic_icon(GUnixMountEntry    *mount_entry);
GIcon  * g_unix_mount_guess_icon(GUnixMountEntry    *mount_entry);
char  * g_unix_mount_guess_name(GUnixMountEntry    *mount_entry);
gboolean g_unix_mount_guess_should_display(GUnixMountEntry    *mount_entry);
gboolean g_unix_mount_guess_can_eject(GUnixMountEntry    *mount_entry);
gboolean g_unix_mount_is_system_internal(GUnixMountEntry    *mount_entry);
gboolean g_unix_mount_is_readonly(GUnixMountEntry    *mount_entry);
const char  * g_unix_mount_get_fs_type(GUnixMountEntry    *mount_entry);
const char  * g_unix_mount_get_device_path(GUnixMountEntry    *mount_entry);
const char  * g_unix_mount_get_mount_path(GUnixMountEntry    *mount_entry);
gint g_unix_mount_compare(GUnixMountEntry    *mount1, GUnixMountEntry    *mount2);
GUnixMountPoint  * g_unix_mount_point_copy(GUnixMountPoint    *mount_point);
void g_unix_mount_point_free(GUnixMountPoint    *mount_point);
GUnixMountEntry  * g_unix_mount_copy(GUnixMountEntry    *mount_entry);
void g_unix_mount_free(GUnixMountEntry    *mount_entry);
GType g_unix_mount_point_get_type(void);
GType g_unix_mount_entry_get_type(void);
gint g_unix_input_stream_get_fd(GUnixInputStream *stream);
gboolean g_unix_input_stream_get_close_fd(GUnixInputStream *stream);
void g_unix_input_stream_set_close_fd(GUnixInputStream *stream, gboolean          close_fd);
GInputStream  * g_unix_input_stream_new(gint              fd, gboolean          close_fd);
GType g_unix_input_stream_get_type(void);
gboolean g_unix_fd_message_append_fd(GUnixFDMessage  *message, gint             fd, GError         **error);
gint  * g_unix_fd_message_steal_fds(GUnixFDMessage  *message, gint            *length);
GUnixFDList  * g_unix_fd_message_get_fd_list(GUnixFDMessage  *message);
GSocketControlMessage  * g_unix_fd_message_new(void);
GSocketControlMessage  * g_unix_fd_message_new_with_fd_list(GUnixFDList     *fd_list);
GType g_unix_fd_message_get_type(void);
gint  * g_unix_fd_list_steal_fds(GUnixFDList  *list, gint         *length);
const gint  * g_unix_fd_list_peek_fds(GUnixFDList  *list, gint         *length);
gint g_unix_fd_list_get(GUnixFDList  *list, gint          index_, GError      **error);
gint g_unix_fd_list_get_length(GUnixFDList  *list);
gint g_unix_fd_list_append(GUnixFDList  *list, gint          fd, GError      **error);
GUnixFDList  * g_unix_fd_list_new_from_array(const gint   *fds, gint          n_fds);
GUnixFDList  * g_unix_fd_list_new(void);
GType g_unix_fd_list_get_type(void);
gboolean g_unix_credentials_message_is_supported(void);
GCredentials           * g_unix_credentials_message_get_credentials(GUnixCredentialsMessage *message);
GSocketControlMessage  * g_unix_credentials_message_new_with_credentials(GCredentials *credentials);
GSocketControlMessage  * g_unix_credentials_message_new(void);
GType g_unix_credentials_message_get_type(void);
GCredentials            * g_unix_connection_receive_credentials_finish(GUnixConnection      *connection, GAsyncResult         *result, GError              **error);
void g_unix_connection_receive_credentials_async(GUnixConnection      *connection, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GCredentials            * g_unix_connection_receive_credentials(GUnixConnection      *connection, GCancellable         *cancellable, GError              **error);
gboolean g_unix_connection_send_credentials_finish(GUnixConnection      *connection, GAsyncResult         *result, GError              **error);
void g_unix_connection_send_credentials_async(GUnixConnection      *connection, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_unix_connection_send_credentials(GUnixConnection      *connection, GCancellable         *cancellable, GError              **error);
gint g_unix_connection_receive_fd(GUnixConnection      *connection, GCancellable         *cancellable, GError              **error);
gboolean g_unix_connection_send_fd(GUnixConnection      *connection, gint                  fd, GCancellable         *cancellable, GError              **error);
GType g_unix_connection_get_type(void);
GIOStream  * g_tls_server_connection_new(GIOStream        *base_io_stream, GTlsCertificate  *certificate, GError          **error);
GType g_tls_server_connection_get_type(void);
void g_tls_password_set_warning(GTlsPassword      *password, const gchar       *warning);
const gchar  * g_tls_password_get_warning(GTlsPassword      *password);
void g_tls_password_set_description(GTlsPassword      *password, const gchar       *description);
const gchar * g_tls_password_get_description(GTlsPassword      *password);
void g_tls_password_set_flags(GTlsPassword      *password, GTlsPasswordFlags  flags);
GTlsPasswordFlags g_tls_password_get_flags(GTlsPassword      *password);
void g_tls_password_set_value_full(GTlsPassword      *password, guchar            *value, gssize             length, GDestroyNotify     destroy);
void g_tls_password_set_value(GTlsPassword      *password, const guchar      *value, gssize             length);
const guchar  * g_tls_password_get_value(GTlsPassword      *password, gsize             *length);
GTlsPassword  * g_tls_password_new(GTlsPasswordFlags  flags, const gchar       *description);
GType g_tls_password_get_type(void);
GTlsInteractionResult g_tls_interaction_request_certificate_finish(GTlsInteraction              *interaction, GAsyncResult                 *result, GError                      **error);
void g_tls_interaction_request_certificate_async(GTlsInteraction              *interaction, GTlsConnection               *connection, GTlsCertificateRequestFlags   flags, GCancellable                 *cancellable, GAsyncReadyCallback           callback, gpointer                      user_data);
GTlsInteractionResult g_tls_interaction_request_certificate(GTlsInteraction              *interaction, GTlsConnection               *connection, GTlsCertificateRequestFlags   flags, GCancellable                 *cancellable, GError                      **error);
GTlsInteractionResult g_tls_interaction_invoke_request_certificate(GTlsInteraction              *interaction, GTlsConnection               *connection, GTlsCertificateRequestFlags   flags, GCancellable                 *cancellable, GError                      **error);
GTlsInteractionResult g_tls_interaction_ask_password_finish(GTlsInteraction    *interaction, GAsyncResult       *result, GError            **error);
void g_tls_interaction_ask_password_async(GTlsInteraction    *interaction, GTlsPassword       *password, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data);
GTlsInteractionResult g_tls_interaction_ask_password(GTlsInteraction    *interaction, GTlsPassword       *password, GCancellable       *cancellable, GError            **error);
GTlsInteractionResult g_tls_interaction_invoke_ask_password(GTlsInteraction    *interaction, GTlsPassword       *password, GCancellable       *cancellable, GError            **error);
GType g_tls_interaction_get_type(void);
GTlsDatabase * g_tls_file_database_new(const gchar  *anchors, GError      **error);
GType g_tls_file_database_get_type(void);
GList * g_tls_database_lookup_certificates_issued_by_finish(GTlsDatabase            *self, GAsyncResult            *result, GError                 **error);
void g_tls_database_lookup_certificates_issued_by_async(GTlsDatabase            *self, GByteArray              *issuer_raw_dn, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
GList * g_tls_database_lookup_certificates_issued_by(GTlsDatabase            *self, GByteArray              *issuer_raw_dn, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GError                 **error);
GTlsCertificate * g_tls_database_lookup_certificate_issuer_finish(GTlsDatabase            *self, GAsyncResult            *result, GError                 **error);
void g_tls_database_lookup_certificate_issuer_async(GTlsDatabase            *self, GTlsCertificate         *certificate, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
GTlsCertificate * g_tls_database_lookup_certificate_issuer(GTlsDatabase            *self, GTlsCertificate         *certificate, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GError                 **error);
GTlsCertificate * g_tls_database_lookup_certificate_for_handle_finish(GTlsDatabase            *self, GAsyncResult            *result, GError                 **error);
void g_tls_database_lookup_certificate_for_handle_async(GTlsDatabase            *self, const gchar             *handle, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
GTlsCertificate * g_tls_database_lookup_certificate_for_handle(GTlsDatabase            *self, const gchar             *handle, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GError                 **error);
gchar * g_tls_database_create_certificate_handle(GTlsDatabase            *self, GTlsCertificate         *certificate);
GTlsCertificateFlags g_tls_database_verify_chain_finish(GTlsDatabase            *self, GAsyncResult            *result, GError                 **error);
void g_tls_database_verify_chain_async(GTlsDatabase            *self, GTlsCertificate         *chain, const gchar             *purpose, GSocketConnectable      *identity, GTlsInteraction         *interaction, GTlsDatabaseVerifyFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
GTlsCertificateFlags g_tls_database_verify_chain(GTlsDatabase            *self, GTlsCertificate         *chain, const gchar             *purpose, GSocketConnectable      *identity, GTlsInteraction         *interaction, GTlsDatabaseVerifyFlags  flags, GCancellable            *cancellable, GError                 **error);
GType g_tls_database_get_type(void);
gboolean g_tls_connection_emit_accept_certificate(GTlsConnection       *conn, GTlsCertificate      *peer_cert, GTlsCertificateFlags  errors);
GQuark g_tls_error_quark(void);
gboolean g_tls_connection_handshake_finish(GTlsConnection       *conn, GAsyncResult         *result, GError              **error);
void g_tls_connection_handshake_async(GTlsConnection       *conn, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_tls_connection_handshake(GTlsConnection       *conn, GCancellable         *cancellable, GError              **error);
GTlsRehandshakeMode g_tls_connection_get_rehandshake_mode(GTlsConnection       *conn);
void g_tls_connection_set_rehandshake_mode(GTlsConnection       *conn, GTlsRehandshakeMode   mode);
gboolean g_tls_connection_get_require_close_notify(GTlsConnection       *conn);
void g_tls_connection_set_require_close_notify(GTlsConnection       *conn, gboolean              require_close_notify);
GTlsCertificateFlags g_tls_connection_get_peer_certificate_errors(GTlsConnection       *conn);
GTlsCertificate       * g_tls_connection_get_peer_certificate(GTlsConnection       *conn);
GTlsInteraction  * g_tls_connection_get_interaction(GTlsConnection       *conn);
void g_tls_connection_set_interaction(GTlsConnection       *conn, GTlsInteraction      *interaction);
GTlsCertificate       * g_tls_connection_get_certificate(GTlsConnection       *conn);
void g_tls_connection_set_certificate(GTlsConnection       *conn, GTlsCertificate      *certificate);
GTlsDatabase  * g_tls_connection_get_database(GTlsConnection       *conn);
void g_tls_connection_set_database(GTlsConnection       *conn, GTlsDatabase         *database);
gboolean g_tls_connection_get_use_system_certdb(GTlsConnection       *conn);
void g_tls_connection_set_use_system_certdb(GTlsConnection       *conn, gboolean              use_system_certdb);
GType g_tls_connection_get_type(void);
void g_tls_client_connection_copy_session_state(GTlsClientConnection    *conn, GTlsClientConnection    *source);
GList  * g_tls_client_connection_get_accepted_cas(GTlsClientConnection    *conn);
void g_tls_client_connection_set_use_ssl3(GTlsClientConnection    *conn, gboolean                 use_ssl3);
gboolean g_tls_client_connection_get_use_ssl3(GTlsClientConnection    *conn);
void g_tls_client_connection_set_server_identity(GTlsClientConnection    *conn, GSocketConnectable      *identity);
GSocketConnectable    * g_tls_client_connection_get_server_identity(GTlsClientConnection    *conn);
void g_tls_client_connection_set_validation_flags(GTlsClientConnection    *conn, GTlsCertificateFlags     flags);
GTlsCertificateFlags g_tls_client_connection_get_validation_flags(GTlsClientConnection    *conn);
GIOStream  * g_tls_client_connection_new(GIOStream               *base_io_stream, GSocketConnectable      *server_identity, GError                 **error);
GType g_tls_client_connection_get_type(void);
gboolean g_tls_certificate_is_same(GTlsCertificate     *cert_one, GTlsCertificate     *cert_two);
GTlsCertificateFlags g_tls_certificate_verify(GTlsCertificate     *cert, GSocketConnectable  *identity, GTlsCertificate     *trusted_ca);
GTlsCertificate       * g_tls_certificate_get_issuer(GTlsCertificate     *cert);
GList                 * g_tls_certificate_list_new_from_file(const gchar         *file, GError             **error);
GTlsCertificate       * g_tls_certificate_new_from_files(const gchar         *cert_file, const gchar         *key_file, GError             **error);
GTlsCertificate       * g_tls_certificate_new_from_file(const gchar         *file, GError             **error);
GTlsCertificate       * g_tls_certificate_new_from_pem(const gchar         *data, gssize               length, GError             **error);
GType g_tls_certificate_get_type(void);
GType g_tls_backend_get_dtls_server_connection_type(GTlsBackend *backend);
GType g_tls_backend_get_dtls_client_connection_type(GTlsBackend *backend);
GType g_tls_backend_get_file_database_type(GTlsBackend *backend);
GType g_tls_backend_get_server_connection_type(GTlsBackend *backend);
GType g_tls_backend_get_client_connection_type(GTlsBackend *backend);
GType g_tls_backend_get_certificate_type(GTlsBackend *backend);
gboolean g_tls_backend_supports_dtls(GTlsBackend *backend);
gboolean g_tls_backend_supports_tls(GTlsBackend *backend);
GTlsDatabase  * g_tls_backend_get_default_database(GTlsBackend *backend);
GTlsBackend  * g_tls_backend_get_default(void);
GType g_tls_backend_get_type(void);
GSocketService  * g_threaded_socket_service_new(int max_threads);
GType g_threaded_socket_service_get_type(void);
const gchar * const * g_themed_icon_get_names(GThemedIcon *icon);
void g_themed_icon_append_name(GThemedIcon *icon, const char  *iconname);
void g_themed_icon_prepend_name(GThemedIcon *icon, const char  *iconname);
GIcon  * g_themed_icon_new_from_names(char       **iconnames, int          len);
GIcon  * g_themed_icon_new_with_default_fallbacks(const char  *iconname);
GIcon  * g_themed_icon_new(const char  *iconname);
GType g_themed_icon_get_type(void);
void g_test_dbus_unset(void);
void g_test_dbus_down(GTestDBus     *self);
void g_test_dbus_stop(GTestDBus     *self);
void g_test_dbus_up(GTestDBus     *self);
void g_test_dbus_add_service_dir(GTestDBus     *self, const gchar   *path);
const gchar  * g_test_dbus_get_bus_address(GTestDBus     *self);
GTestDBusFlags g_test_dbus_get_flags(GTestDBus     *self);
GTestDBus  * g_test_dbus_new(GTestDBusFlags flags);
GType g_test_dbus_get_type(void);
GIOStream          * g_tcp_wrapper_connection_get_base_io_stream(GTcpWrapperConnection *conn);
GSocketConnection  * g_tcp_wrapper_connection_new(GIOStream             *base_io_stream, GSocket               *socket);
GType g_tcp_wrapper_connection_get_type(void);
gboolean g_tcp_connection_get_graceful_disconnect(GTcpConnection *connection);
void g_tcp_connection_set_graceful_disconnect(GTcpConnection *connection, gboolean        graceful_disconnect);
GType g_tcp_connection_get_type(void);
gboolean g_task_get_completed(GTask           *task);
gboolean g_task_had_error(GTask           *task);
gssize g_task_propagate_int(GTask           *task, GError         **error);
gboolean g_task_propagate_boolean(GTask           *task, GError         **error);
gpointer g_task_propagate_pointer(GTask           *task, GError         **error);
gboolean g_task_return_error_if_cancelled(GTask           *task);
void g_task_return_new_error(GTask           *task, GQuark           domain, gint             code, const char      *format, ...);
void g_task_return_error(GTask           *task, GError          *error);
void g_task_return_int(GTask           *task, gssize           result);
void g_task_return_boolean(GTask           *task, gboolean         result);
void g_task_return_pointer(GTask           *task, gpointer         result, GDestroyNotify   result_destroy);
void g_task_attach_source(GTask           *task, GSource         *source, GSourceFunc      callback);
gboolean g_task_get_return_on_cancel(GTask           *task);
gboolean g_task_set_return_on_cancel(GTask           *task, gboolean         return_on_cancel);
void g_task_run_in_thread_sync(GTask           *task, GTaskThreadFunc  task_func);
void g_task_run_in_thread(GTask           *task, GTaskThreadFunc  task_func);
gboolean g_task_is_valid(gpointer             result, gpointer             source_object);
gpointer g_task_get_source_tag(GTask               *task);
gboolean g_task_get_check_cancellable(GTask               *task);
GCancellable  * g_task_get_cancellable(GTask               *task);
GMainContext  * g_task_get_context(GTask               *task);
gint g_task_get_priority(GTask               *task);
gpointer g_task_get_task_data(GTask               *task);
gpointer g_task_get_source_object(GTask               *task);
void g_task_set_source_tag(GTask               *task, gpointer             source_tag);
void g_task_set_check_cancellable(GTask               *task, gboolean             check_cancellable);
void g_task_set_priority(GTask               *task, gint                 priority);
void g_task_set_task_data(GTask               *task, gpointer             task_data, GDestroyNotify       task_data_destroy);
void g_task_report_new_error(gpointer             source_object, GAsyncReadyCallback  callback, gpointer             callback_data, gpointer             source_tag, GQuark               domain, gint                 code, const char          *format, ...);
void g_task_report_error(gpointer             source_object, GAsyncReadyCallback  callback, gpointer             callback_data, gpointer             source_tag, GError              *error);
GTask         * g_task_new(gpointer             source_object, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             callback_data);
GType g_task_get_type(void);
void g_subprocess_launcher_set_child_setup(GSubprocessLauncher   *self, GSpawnChildSetupFunc   child_setup, gpointer               user_data, GDestroyNotify         destroy_notify);
void g_subprocess_launcher_take_fd(GSubprocessLauncher   *self, gint                   source_fd, gint                   target_fd);
void g_subprocess_launcher_take_stderr_fd(GSubprocessLauncher   *self, gint                   fd);
void g_subprocess_launcher_set_stderr_file_path(GSubprocessLauncher   *self, const gchar           *path);
void g_subprocess_launcher_take_stdout_fd(GSubprocessLauncher   *self, gint                   fd);
void g_subprocess_launcher_set_stdout_file_path(GSubprocessLauncher   *self, const gchar           *path);
void g_subprocess_launcher_take_stdin_fd(GSubprocessLauncher   *self, gint                   fd);
void g_subprocess_launcher_set_stdin_file_path(GSubprocessLauncher   *self, const gchar           *path);
void g_subprocess_launcher_set_flags(GSubprocessLauncher   *self, GSubprocessFlags       flags);
void g_subprocess_launcher_set_cwd(GSubprocessLauncher   *self, const gchar           *cwd);
const gchar  * g_subprocess_launcher_getenv(GSubprocessLauncher   *self, const gchar           *variable);
void g_subprocess_launcher_unsetenv(GSubprocessLauncher *self, const gchar         *variable);
void g_subprocess_launcher_setenv(GSubprocessLauncher   *self, const gchar           *variable, const gchar           *value, gboolean               overwrite);
void g_subprocess_launcher_set_environ(GSubprocessLauncher   *self, gchar                **env);
GSubprocess  * g_subprocess_launcher_spawnv(GSubprocessLauncher   *self, const gchar * const   *argv, GError               **error);
GSubprocess  * g_subprocess_launcher_spawn(GSubprocessLauncher   *self, GError               **error, const gchar           *argv0, ...);
GSubprocessLauncher  * g_subprocess_launcher_new(GSubprocessFlags       flags);
GType g_subprocess_launcher_get_type(void);
gboolean g_subprocess_communicate_utf8_finish(GSubprocess          *subprocess, GAsyncResult         *result, char                **stdout_buf, char                **stderr_buf, GError              **error);
void g_subprocess_communicate_utf8_async(GSubprocess          *subprocess, const char           *stdin_buf, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_subprocess_communicate_utf8(GSubprocess          *subprocess, const char           *stdin_buf, GCancellable         *cancellable, char                **stdout_buf, char                **stderr_buf, GError              **error);
gboolean g_subprocess_communicate_finish(GSubprocess          *subprocess, GAsyncResult         *result, GBytes              **stdout_buf, GBytes              **stderr_buf, GError              **error);
void g_subprocess_communicate_async(GSubprocess          *subprocess, GBytes               *stdin_buf, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_subprocess_communicate(GSubprocess          *subprocess, GBytes               *stdin_buf, GCancellable         *cancellable, GBytes              **stdout_buf, GBytes              **stderr_buf, GError              **error);
gint g_subprocess_get_term_sig(GSubprocess          *subprocess);
gboolean g_subprocess_get_if_signaled(GSubprocess          *subprocess);
gint g_subprocess_get_exit_status(GSubprocess          *subprocess);
gboolean g_subprocess_get_if_exited(GSubprocess          *subprocess);
gboolean g_subprocess_get_successful(GSubprocess          *subprocess);
gint g_subprocess_get_status(GSubprocess          *subprocess);
gboolean g_subprocess_wait_check_finish(GSubprocess          *subprocess, GAsyncResult         *result, GError              **error);
void g_subprocess_wait_check_async(GSubprocess          *subprocess, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_subprocess_wait_check(GSubprocess          *subprocess, GCancellable         *cancellable, GError              **error);
gboolean g_subprocess_wait_finish(GSubprocess          *subprocess, GAsyncResult         *result, GError              **error);
void g_subprocess_wait_async(GSubprocess          *subprocess, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_subprocess_wait(GSubprocess          *subprocess, GCancellable         *cancellable, GError              **error);
void g_subprocess_force_exit(GSubprocess          *subprocess);
void g_subprocess_send_signal(GSubprocess          *subprocess, gint                  signal_num);
const gchar  * g_subprocess_get_identifier(GSubprocess          *subprocess);
GInputStream  * g_subprocess_get_stderr_pipe(GSubprocess          *subprocess);
GInputStream  * g_subprocess_get_stdout_pipe(GSubprocess          *subprocess);
GOutputStream  * g_subprocess_get_stdin_pipe(GSubprocess          *subprocess);
GSubprocess  * g_subprocess_newv(const gchar * const  *argv, GSubprocessFlags      flags, GError              **error);
GSubprocess  * g_subprocess_new(GSubprocessFlags        flags, GError                **error, const gchar            *argv0, ...);
GType g_subprocess_get_type(void);
GList        * g_srv_target_list_sort(GList       *targets);
guint16 g_srv_target_get_weight(GSrvTarget  *target);
guint16 g_srv_target_get_priority(GSrvTarget  *target);
guint16 g_srv_target_get_port(GSrvTarget  *target);
const gchar  * g_srv_target_get_hostname(GSrvTarget  *target);
void g_srv_target_free(GSrvTarget  *target);
GSrvTarget   * g_srv_target_copy(GSrvTarget  *target);
GSrvTarget   * g_srv_target_new(const gchar *hostname, guint16      port, guint16      priority, guint16      weight);
GType g_srv_target_get_type(void);
gboolean g_socket_service_is_active(GSocketService *service);
void g_socket_service_stop(GSocketService *service);
void g_socket_service_start(GSocketService *service);
GSocketService  * g_socket_service_new(void);
GType g_socket_service_get_type(void);
void g_socket_listener_close(GSocketListener      *listener);
GSocketConnection  * g_socket_listener_accept_finish(GSocketListener      *listener, GAsyncResult         *result, GObject             **source_object, GError              **error);
void g_socket_listener_accept_async(GSocketListener      *listener, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GSocketConnection  * g_socket_listener_accept(GSocketListener      *listener, GObject             **source_object, GCancellable         *cancellable, GError              **error);
GSocket  * g_socket_listener_accept_socket_finish(GSocketListener      *listener, GAsyncResult         *result, GObject             **source_object, GError              **error);
void g_socket_listener_accept_socket_async(GSocketListener      *listener, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GSocket  * g_socket_listener_accept_socket(GSocketListener      *listener, GObject             **source_object, GCancellable         *cancellable, GError              **error);
guint16 g_socket_listener_add_any_inet_port(GSocketListener     *listener, GObject             *source_object, GError             **error);
gboolean g_socket_listener_add_inet_port(GSocketListener     *listener, guint16              port, GObject             *source_object, GError             **error);
gboolean g_socket_listener_add_address(GSocketListener     *listener, GSocketAddress      *address, GSocketType          type, GSocketProtocol      protocol, GObject             *source_object, GSocketAddress     **effective_address, GError             **error);
gboolean g_socket_listener_add_socket(GSocketListener     *listener, GSocket             *socket, GObject             *source_object, GError             **error);
void g_socket_listener_set_backlog(GSocketListener     *listener, int                  listen_backlog);
GSocketListener  * g_socket_listener_new(void);
GType g_socket_listener_get_type(void);
GSocketControlMessage  * g_socket_control_message_deserialize(int                    level, int                    type, gsize                  size, gpointer               data);
void g_socket_control_message_serialize(GSocketControlMessage *message, gpointer               data);
int g_socket_control_message_get_msg_type(GSocketControlMessage *message);
int g_socket_control_message_get_level(GSocketControlMessage *message);
gsize g_socket_control_message_get_size(GSocketControlMessage *message);
GType g_socket_control_message_get_type(void);
GSocketConnection  * g_socket_connection_factory_create_connection(GSocket            *socket);
GType g_socket_connection_factory_lookup_type(GSocketFamily       family, GSocketType         type, gint                protocol_id);
void g_socket_connection_factory_register_type(GType               g_type, GSocketFamily       family, GSocketType         type, gint                protocol);
GSocketAddress     * g_socket_connection_get_remote_address(GSocketConnection  *connection, GError            **error);
GSocketAddress     * g_socket_connection_get_local_address(GSocketConnection  *connection, GError            **error);
GSocket            * g_socket_connection_get_socket(GSocketConnection  *connection);
gboolean g_socket_connection_connect_finish(GSocketConnection  *connection, GAsyncResult       *result, GError            **error);
void g_socket_connection_connect_async(GSocketConnection  *connection, GSocketAddress     *address, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data);
gboolean g_socket_connection_connect(GSocketConnection  *connection, GSocketAddress     *address, GCancellable       *cancellable, GError            **error);
gboolean g_socket_connection_is_connected(GSocketConnection  *connection);
GType g_socket_connection_get_type(void);
gchar                     * g_socket_connectable_to_string(GSocketConnectable *connectable);
GSocketAddressEnumerator  * g_socket_connectable_proxy_enumerate(GSocketConnectable *connectable);
GSocketAddressEnumerator  * g_socket_connectable_enumerate(GSocketConnectable *connectable);
GType g_socket_connectable_get_type(void);
void g_socket_client_add_application_proxy(GSocketClient        *client, const gchar          *protocol);
GSocketConnection  * g_socket_client_connect_to_uri_finish(GSocketClient        *client, GAsyncResult         *result, GError              **error);
void g_socket_client_connect_to_uri_async(GSocketClient        *client, const gchar          *uri, guint16               default_port, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GSocketConnection  * g_socket_client_connect_to_service_finish(GSocketClient        *client, GAsyncResult         *result, GError              **error);
void g_socket_client_connect_to_service_async(GSocketClient        *client, const gchar          *domain, const gchar          *service, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GSocketConnection  * g_socket_client_connect_to_host_finish(GSocketClient        *client, GAsyncResult         *result, GError              **error);
void g_socket_client_connect_to_host_async(GSocketClient        *client, const gchar          *host_and_port, guint16               default_port, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GSocketConnection  * g_socket_client_connect_finish(GSocketClient        *client, GAsyncResult         *result, GError              **error);
void g_socket_client_connect_async(GSocketClient        *client, GSocketConnectable   *connectable, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GSocketConnection  * g_socket_client_connect_to_uri(GSocketClient        *client, const gchar          *uri, guint16               default_port, GCancellable         *cancellable, GError              **error);
GSocketConnection  * g_socket_client_connect_to_service(GSocketClient        *client, const gchar          *domain, const gchar          *service, GCancellable         *cancellable, GError              **error);
GSocketConnection  * g_socket_client_connect_to_host(GSocketClient        *client, const gchar          *host_and_port, guint16               default_port, GCancellable         *cancellable, GError              **error);
GSocketConnection  * g_socket_client_connect(GSocketClient        *client, GSocketConnectable   *connectable, GCancellable         *cancellable, GError              **error);
void g_socket_client_set_proxy_resolver(GSocketClient        *client, GProxyResolver       *proxy_resolver);
GProxyResolver          * g_socket_client_get_proxy_resolver(GSocketClient        *client);
void g_socket_client_set_tls_validation_flags(GSocketClient        *client, GTlsCertificateFlags  flags);
GTlsCertificateFlags g_socket_client_get_tls_validation_flags(GSocketClient        *client);
void g_socket_client_set_tls(GSocketClient        *client, gboolean              tls);
gboolean g_socket_client_get_tls(GSocketClient        *client);
void g_socket_client_set_enable_proxy(GSocketClient        *client, gboolean	      enable);
gboolean g_socket_client_get_enable_proxy(GSocketClient        *client);
void g_socket_client_set_timeout(GSocketClient        *client, guint                 timeout);
guint g_socket_client_get_timeout(GSocketClient        *client);
void g_socket_client_set_local_address(GSocketClient        *client, GSocketAddress       *address);
GSocketAddress          * g_socket_client_get_local_address(GSocketClient        *client);
void g_socket_client_set_protocol(GSocketClient        *client, GSocketProtocol       protocol);
GSocketProtocol g_socket_client_get_protocol(GSocketClient        *client);
void g_socket_client_set_socket_type(GSocketClient        *client, GSocketType           type);
GSocketType g_socket_client_get_socket_type(GSocketClient        *client);
void g_socket_client_set_family(GSocketClient        *client, GSocketFamily         family);
GSocketFamily g_socket_client_get_family(GSocketClient        *client);
GSocketClient           * g_socket_client_new(void);
GType g_socket_client_get_type(void);
GSocketAddress  * g_socket_address_enumerator_next_finish(GSocketAddressEnumerator  *enumerator, GAsyncResult              *result, GError                   **error);
void g_socket_address_enumerator_next_async(GSocketAddressEnumerator  *enumerator, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data);
GSocketAddress  * g_socket_address_enumerator_next(GSocketAddressEnumerator  *enumerator, GCancellable              *cancellable, GError                   **error);
GType g_socket_address_enumerator_get_type(void);
gssize g_socket_address_get_native_size(GSocketAddress *address);
gboolean g_socket_address_to_native(GSocketAddress *address, gpointer        dest, gsize           destlen, GError        **error);
GSocketAddress  * g_socket_address_new_from_native(gpointer        native, gsize           len);
GSocketFamily g_socket_address_get_family(GSocketAddress *address);
GType g_socket_address_get_type(void);
gboolean g_socket_set_option(GSocket                 *socket, gint                     level, gint                     optname, gint                     value, GError                 **error);
gboolean g_socket_get_option(GSocket                 *socket, gint                     level, gint                     optname, gint                    *value, GError                 **error);
gssize g_socket_send_with_blocking(GSocket                 *socket, const gchar             *buffer, gsize                    size, gboolean                 blocking, GCancellable            *cancellable, GError                 **error);
gssize g_socket_receive_with_blocking(GSocket                 *socket, gchar                   *buffer, gsize                    size, gboolean                 blocking, GCancellable            *cancellable, GError                 **error);
GCredentials           * g_socket_get_credentials(GSocket                 *socket, GError                 **error);
gboolean g_socket_speaks_ipv4(GSocket                 *socket);
GSource  * g_socket_create_source(GSocket                 *socket, GIOCondition             condition, GCancellable            *cancellable);
gboolean g_socket_is_closed(GSocket                 *socket);
gboolean g_socket_shutdown(GSocket                 *socket, gboolean                 shutdown_read, gboolean                 shutdown_write, GError                 **error);
gboolean g_socket_close(GSocket                 *socket, GError                 **error);
gint g_socket_send_messages(GSocket                 *socket, GOutputMessage          *messages, guint                    num_messages, gint                     flags, GCancellable            *cancellable, GError                 **error);
gint g_socket_receive_messages(GSocket                 *socket, GInputMessage           *messages, guint                    num_messages, gint                     flags, GCancellable            *cancellable, GError                 **error);
gssize g_socket_send_message(GSocket                 *socket, GSocketAddress          *address, GOutputVector           *vectors, gint                     num_vectors, GSocketControlMessage  **messages, gint                     num_messages, gint                     flags, GCancellable            *cancellable, GError                 **error);
gssize g_socket_receive_message(GSocket                 *socket, GSocketAddress         **address, GInputVector            *vectors, gint                     num_vectors, GSocketControlMessage ***messages, gint                    *num_messages, gint                    *flags, GCancellable            *cancellable, GError                 **error);
gssize g_socket_send_to(GSocket                 *socket, GSocketAddress          *address, const gchar             *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error);
gssize g_socket_send(GSocket                 *socket, const gchar             *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error);
gssize g_socket_receive_from(GSocket                 *socket, GSocketAddress         **address, gchar                   *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error);
gssize g_socket_receive(GSocket                 *socket, gchar                   *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error);
gboolean g_socket_listen(GSocket                 *socket, GError                 **error);
GSocket  * g_socket_accept(GSocket                 *socket, GCancellable            *cancellable, GError                 **error);
gboolean g_socket_condition_timed_wait(GSocket                 *socket, GIOCondition             condition, gint64                   timeout, GCancellable            *cancellable, GError                 **error);
gboolean g_socket_condition_wait(GSocket                 *socket, GIOCondition             condition, GCancellable            *cancellable, GError                 **error);
GIOCondition g_socket_condition_check(GSocket                 *socket, GIOCondition             condition);
gssize g_socket_get_available_bytes(GSocket                 *socket);
gboolean g_socket_check_connect_result(GSocket                 *socket, GError                 **error);
gboolean g_socket_connect(GSocket                 *socket, GSocketAddress          *address, GCancellable            *cancellable, GError                 **error);
gboolean g_socket_leave_multicast_group_ssm(GSocket                 *socket, GInetAddress            *group, GInetAddress            *source_specific, const gchar             *iface, GError                 **error);
gboolean g_socket_join_multicast_group_ssm(GSocket                 *socket, GInetAddress            *group, GInetAddress            *source_specific, const gchar             *iface, GError                 **error);
gboolean g_socket_leave_multicast_group(GSocket                 *socket, GInetAddress            *group, gboolean                 source_specific, const gchar             *iface, GError                 **error);
gboolean g_socket_join_multicast_group(GSocket                 *socket, GInetAddress            *group, gboolean                 source_specific, const gchar             *iface, GError                 **error);
gboolean g_socket_bind(GSocket                 *socket, GSocketAddress          *address, gboolean                 allow_reuse, GError                 **error);
gboolean g_socket_is_connected(GSocket                 *socket);
void g_socket_set_multicast_ttl(GSocket                 *socket, guint                    ttl);
guint g_socket_get_multicast_ttl(GSocket                 *socket);
void g_socket_set_multicast_loopback(GSocket                 *socket, gboolean		  loopback);
gboolean g_socket_get_multicast_loopback(GSocket                 *socket);
void g_socket_set_broadcast(GSocket                 *socket, gboolean		  broadcast);
gboolean g_socket_get_broadcast(GSocket                 *socket);
void g_socket_set_ttl(GSocket                 *socket, guint                    ttl);
guint g_socket_get_ttl(GSocket                 *socket);
void g_socket_set_timeout(GSocket                 *socket, guint                    timeout);
guint g_socket_get_timeout(GSocket                 *socket);
void g_socket_set_listen_backlog(GSocket                 *socket, gint                     backlog);
gint g_socket_get_listen_backlog(GSocket                 *socket);
gboolean g_socket_get_keepalive(GSocket                 *socket);
void g_socket_set_keepalive(GSocket                 *socket, gboolean                 keepalive);
gboolean g_socket_get_blocking(GSocket                 *socket);
void g_socket_set_blocking(GSocket                 *socket, gboolean                 blocking);
GSocketAddress  * g_socket_get_remote_address(GSocket                 *socket, GError                 **error);
GSocketAddress  * g_socket_get_local_address(GSocket                 *socket, GError                 **error);
GSocketProtocol g_socket_get_protocol(GSocket                 *socket);
GSocketType g_socket_get_socket_type(GSocket                 *socket);
GSocketFamily g_socket_get_family(GSocket                 *socket);
int g_socket_get_fd(GSocket                 *socket);
GSocket  * g_socket_new_from_fd(gint                     fd, GError                 **error);
GSocket  * g_socket_new(GSocketFamily            family, GSocketType              type, GSocketProtocol          protocol, GError                 **error);
GType g_socket_get_type(void);
void g_simple_proxy_resolver_set_uri_proxy(GSimpleProxyResolver  *resolver, const gchar           *uri_scheme, const gchar           *proxy);
void g_simple_proxy_resolver_set_ignore_hosts(GSimpleProxyResolver  *resolver, gchar                **ignore_hosts);
void g_simple_proxy_resolver_set_default_proxy(GSimpleProxyResolver  *resolver, const gchar           *default_proxy);
GProxyResolver  * g_simple_proxy_resolver_new(const gchar           *default_proxy, gchar                **ignore_hosts);
GType g_simple_proxy_resolver_get_type(void);
GPermission  * g_simple_permission_new(gboolean allowed);
GType g_simple_permission_get_type(void);
GIOStream            * g_simple_io_stream_new(GInputStream  *input_stream, GOutputStream *output_stream);
GType g_simple_io_stream_get_type(void);
void g_simple_async_report_take_gerror_in_idle(GObject            *object, GAsyncReadyCallback callback, gpointer            user_data, GError             *error);
void g_simple_async_report_gerror_in_idle(GObject            *object, GAsyncReadyCallback callback, gpointer            user_data, const GError       *error);
void g_simple_async_report_error_in_idle(GObject            *object, GAsyncReadyCallback callback, gpointer            user_data, GQuark              domain, gint                code, const char         *format, ...);
gboolean g_simple_async_result_is_valid(GAsyncResult            *result, GObject                 *source, gpointer                 source_tag);
void g_simple_async_result_set_error_va(GSimpleAsyncResult      *simple, GQuark                   domain, gint                     code, const char              *format, va_list                  args);
void g_simple_async_result_set_error(GSimpleAsyncResult      *simple, GQuark                   domain, gint                     code, const char              *format, ...);
gboolean g_simple_async_result_propagate_error(GSimpleAsyncResult      *simple, GError                 **dest);
void g_simple_async_result_take_error(GSimpleAsyncResult      *simple, GError            *error);
void g_simple_async_result_set_from_error(GSimpleAsyncResult      *simple, const GError            *error);
void g_simple_async_result_run_in_thread(GSimpleAsyncResult      *simple, GSimpleAsyncThreadFunc   func, int                      io_priority, GCancellable            *cancellable);
void g_simple_async_result_complete_in_idle(GSimpleAsyncResult      *simple);
void g_simple_async_result_complete(GSimpleAsyncResult      *simple);
void g_simple_async_result_set_handle_cancellation(GSimpleAsyncResult      *simple, gboolean          handle_cancellation);
gpointer g_simple_async_result_get_source_tag(GSimpleAsyncResult      *simple);
void g_simple_async_result_set_check_cancellable(GSimpleAsyncResult *simple, GCancellable       *check_cancellable);
gboolean g_simple_async_result_get_op_res_gboolean(GSimpleAsyncResult      *simple);
void g_simple_async_result_set_op_res_gboolean(GSimpleAsyncResult      *simple, gboolean                 op_res);
gssize g_simple_async_result_get_op_res_gssize(GSimpleAsyncResult      *simple);
void g_simple_async_result_set_op_res_gssize(GSimpleAsyncResult      *simple, gssize                   op_res);
gpointer g_simple_async_result_get_op_res_gpointer(GSimpleAsyncResult      *simple);
void g_simple_async_result_set_op_res_gpointer(GSimpleAsyncResult      *simple, gpointer                 op_res, GDestroyNotify           destroy_op_res);
GSimpleAsyncResult  * g_simple_async_result_new_take_error(GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, GError                  *error);
GSimpleAsyncResult  * g_simple_async_result_new_from_error(GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, const GError            *error);
GSimpleAsyncResult  * g_simple_async_result_new_error(GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, GQuark                   domain, gint                     code, const char              *format, ...);
GSimpleAsyncResult  * g_simple_async_result_new(GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, gpointer                 source_tag);
GType g_simple_async_result_get_type(void);
void g_simple_action_group_add_entries(GSimpleActionGroup *simple, const GActionEntry *entries, gint                n_entries, gpointer            user_data);
void g_simple_action_group_remove(GSimpleActionGroup *simple, const gchar        *action_name);
void g_simple_action_group_insert(GSimpleActionGroup *simple, GAction            *action);
GAction  * g_simple_action_group_lookup(GSimpleActionGroup *simple, const gchar        *action_name);
GSimpleActionGroup  * g_simple_action_group_new(void);
GType g_simple_action_group_get_type(void);
void g_simple_action_set_state_hint(GSimpleAction      *simple, GVariant           *state_hint);
void g_simple_action_set_state(GSimpleAction      *simple, GVariant           *value);
void g_simple_action_set_enabled(GSimpleAction      *simple, gboolean            enabled);
GSimpleAction  * g_simple_action_new_stateful(const gchar        *name, const GVariantType *parameter_type, GVariant           *state);
GSimpleAction  * g_simple_action_new(const gchar        *name, const GVariantType *parameter_type);
GType g_simple_action_get_type(void);
const gchar  * g_settings_schema_key_get_description(GSettingsSchemaKey     *key);
const gchar  * g_settings_schema_key_get_summary(GSettingsSchemaKey     *key);
const gchar  * g_settings_schema_key_get_name(GSettingsSchemaKey     *key);
gboolean g_settings_schema_key_range_check(GSettingsSchemaKey     *key, GVariant               *value);
GVariant  * g_settings_schema_key_get_range(GSettingsSchemaKey     *key);
GVariant  * g_settings_schema_key_get_default_value(GSettingsSchemaKey     *key);
const GVariantType  * g_settings_schema_key_get_value_type(GSettingsSchemaKey     *key);
void g_settings_schema_key_unref(GSettingsSchemaKey     *key);
GSettingsSchemaKey  * g_settings_schema_key_ref(GSettingsSchemaKey     *key);
GType g_settings_schema_key_get_type(void);
gchar  ** g_settings_schema_list_children(GSettingsSchema        *schema);
gchar ** g_settings_schema_list_keys(GSettingsSchema        *schema);
gboolean g_settings_schema_has_key(GSettingsSchema        *schema, const gchar            *name);
GSettingsSchemaKey  * g_settings_schema_get_key(GSettingsSchema        *schema, const gchar            *name);
const gchar  * g_settings_schema_get_path(GSettingsSchema        *schema);
const gchar  * g_settings_schema_get_id(GSettingsSchema        *schema);
void g_settings_schema_unref(GSettingsSchema        *schema);
GSettingsSchema  * g_settings_schema_ref(GSettingsSchema        *schema);
GType g_settings_schema_get_type(void);
void g_settings_schema_source_list_schemas(GSettingsSchemaSource   *source, gboolean                 recursive, gchar                 ***non_relocatable, gchar                 ***relocatable);
GSettingsSchema  * g_settings_schema_source_lookup(GSettingsSchemaSource  *source, const gchar            *schema_id, gboolean                recursive);
GSettingsSchemaSource  * g_settings_schema_source_new_from_directory(const gchar            *directory, GSettingsSchemaSource  *parent, gboolean                trusted, GError                **error);
void g_settings_schema_source_unref(GSettingsSchemaSource  *source);
GSettingsSchemaSource  * g_settings_schema_source_ref(GSettingsSchemaSource  *source);
GSettingsSchemaSource  * g_settings_schema_source_get_default(void);
GType g_settings_schema_source_get_type(void);
GSettingsBackend  * g_memory_settings_backend_new(void);
GSettingsBackend  * g_null_settings_backend_new(void);
GSettingsBackend  * g_keyfile_settings_backend_new(const gchar         *filename, const gchar         *root_path, const gchar         *root_group);
GSettingsBackend  * g_settings_backend_get_default(void);
void g_settings_backend_changed_tree(GSettingsBackend    *backend, GTree               *tree, gpointer             origin_tag);
void g_settings_backend_writable_changed(GSettingsBackend    *backend, const gchar         *key);
void g_settings_backend_path_writable_changed(GSettingsBackend    *backend, const gchar         *path);
void g_settings_backend_keys_changed(GSettingsBackend    *backend, const gchar         *path, gchar const * const *items, gpointer             origin_tag);
void g_settings_backend_flatten_tree(GTree               *tree, gchar              **path, const gchar       ***keys, GVariant          ***values);
void g_settings_backend_path_changed(GSettingsBackend    *backend, const gchar         *path, gpointer             origin_tag);
void g_settings_backend_changed(GSettingsBackend    *backend, const gchar         *key, gpointer             origin_tag);
GType g_settings_backend_get_type(void);
gpointer g_settings_get_mapped(GSettings               *settings, const gchar             *key, GSettingsGetMapping      mapping, gpointer                 user_data);
GAction  * g_settings_create_action(GSettings               *settings, const gchar             *key);
void g_settings_unbind(gpointer                 object, const gchar             *property);
void g_settings_bind_writable(GSettings               *settings, const gchar             *key, gpointer                 object, const gchar             *property, gboolean                 inverted);
void g_settings_bind_with_mapping(GSettings               *settings, const gchar             *key, gpointer                 object, const gchar             *property, GSettingsBindFlags       flags, GSettingsBindGetMapping  get_mapping, GSettingsBindSetMapping  set_mapping, gpointer                 user_data, GDestroyNotify           destroy);
void g_settings_bind(GSettings               *settings, const gchar             *key, gpointer                 object, const gchar             *property, GSettingsBindFlags       flags);
void g_settings_sync(void);
gboolean g_settings_get_has_unapplied(GSettings          *settings);
void g_settings_revert(GSettings          *settings);
void g_settings_apply(GSettings          *settings);
void g_settings_delay(GSettings          *settings);
gboolean g_settings_is_writable(GSettings          *settings, const gchar        *name);
GSettings  * g_settings_get_child(GSettings          *settings, const gchar        *name);
gboolean g_settings_set_flags(GSettings          *settings, const gchar        *key, guint               value);
guint g_settings_get_flags(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_enum(GSettings          *settings, const gchar        *key, gint                value);
gint g_settings_get_enum(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_strv(GSettings          *settings, const gchar        *key, const gchar *const *value);
gchar  ** g_settings_get_strv(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_double(GSettings          *settings, const gchar        *key, gdouble             value);
gdouble g_settings_get_double(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_boolean(GSettings          *settings, const gchar        *key, gboolean            value);
gboolean g_settings_get_boolean(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_string(GSettings          *settings, const gchar        *key, const gchar        *value);
gchar  * g_settings_get_string(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_uint64(GSettings          *settings, const gchar        *key, guint64             value);
guint64 g_settings_get_uint64(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_uint(GSettings          *settings, const gchar        *key, guint               value);
guint g_settings_get_uint(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_int64(GSettings          *settings, const gchar        *key, gint64              value);
gint64 g_settings_get_int64(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_int(GSettings          *settings, const gchar        *key, gint                value);
gint g_settings_get_int(GSettings          *settings, const gchar        *key);
void g_settings_reset(GSettings          *settings, const gchar        *key);
void g_settings_get(GSettings          *settings, const gchar        *key, const gchar        *format, ...);
gboolean g_settings_set(GSettings          *settings, const gchar        *key, const gchar        *format, ...);
GVariant  * g_settings_get_default_value(GSettings          *settings, const gchar        *key);
GVariant  * g_settings_get_user_value(GSettings          *settings, const gchar        *key);
GVariant  * g_settings_get_value(GSettings          *settings, const gchar        *key);
gboolean g_settings_set_value(GSettings          *settings, const gchar        *key, GVariant           *value);
gboolean g_settings_range_check(GSettings          *settings, const gchar        *key, GVariant           *value);
GVariant  * g_settings_get_range(GSettings          *settings, const gchar        *key);
gchar  ** g_settings_list_keys(GSettings          *settings);
gchar  ** g_settings_list_children(GSettings          *settings);
GSettings  * g_settings_new_full(GSettingsSchema    *schema, GSettingsBackend   *backend, const gchar        *path);
GSettings  * g_settings_new_with_backend_and_path(const gchar        *schema_id, GSettingsBackend   *backend, const gchar        *path);
GSettings  * g_settings_new_with_backend(const gchar        *schema_id, GSettingsBackend   *backend);
GSettings  * g_settings_new_with_path(const gchar        *schema_id, const gchar        *path);
GSettings  * g_settings_new(const gchar        *schema_id);
const gchar  * const * g_settings_list_relocatable_schemas(void);
const gchar  * const * g_settings_list_schemas(void);
GType g_settings_get_type(void);
gboolean g_seekable_truncate(GSeekable     *seekable, goffset        offset, GCancellable  *cancellable, GError       **error);
gboolean g_seekable_can_truncate(GSeekable     *seekable);
gboolean g_seekable_seek(GSeekable     *seekable, goffset        offset, GSeekType      type, GCancellable  *cancellable, GError       **error);
gboolean g_seekable_can_seek(GSeekable     *seekable);
goffset g_seekable_tell(GSeekable     *seekable);
GType g_seekable_get_type(void);
GResource     * g_static_resource_get_resource(GStaticResource *static_resource);
void g_static_resource_fini(GStaticResource *static_resource);
void g_static_resource_init(GStaticResource *static_resource);
gboolean g_resources_get_info(const char            *path, GResourceLookupFlags   lookup_flags, gsize                 *size, guint32               *flags, GError               **error);
char  ** g_resources_enumerate_children(const char            *path, GResourceLookupFlags   lookup_flags, GError               **error);
GBytes  * g_resources_lookup_data(const char            *path, GResourceLookupFlags   lookup_flags, GError               **error);
GInputStream  * g_resources_open_stream(const char            *path, GResourceLookupFlags   lookup_flags, GError               **error);
void g_resources_unregister(GResource             *resource);
void g_resources_register(GResource             *resource);
gboolean g_resource_get_info(GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, gsize                 *size, guint32               *flags, GError               **error);
char  ** g_resource_enumerate_children(GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, GError               **error);
GBytes  * g_resource_lookup_data(GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, GError               **error);
GInputStream  * g_resource_open_stream(GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, GError               **error);
GResource  * g_resource_load(const gchar           *filename, GError               **error);
void g_resource_unref(GResource             *resource);
GResource  * g_resource_ref(GResource             *resource);
GResource  * g_resource_new_from_data(GBytes                *data, GError               **error);
GType g_resource_get_type(void);
GQuark g_resource_error_quark(void);
GQuark g_resolver_error_quark(void);
void g_resolver_free_targets(GList                *targets);
GList      * g_resolver_lookup_records_finish(GResolver            *resolver, GAsyncResult         *result, GError              **error);
void g_resolver_lookup_records_async(GResolver            *resolver, const gchar          *rrname, GResolverRecordType   record_type, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GList      * g_resolver_lookup_records(GResolver            *resolver, const gchar          *rrname, GResolverRecordType   record_type, GCancellable         *cancellable, GError              **error);
GList      * g_resolver_lookup_service_finish(GResolver            *resolver, GAsyncResult         *result, GError              **error);
void g_resolver_lookup_service_async(GResolver            *resolver, const gchar          *service, const gchar          *protocol, const gchar          *domain, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GList      * g_resolver_lookup_service(GResolver            *resolver, const gchar          *service, const gchar          *protocol, const gchar          *domain, GCancellable         *cancellable, GError              **error);
gchar      * g_resolver_lookup_by_address_finish(GResolver            *resolver, GAsyncResult         *result, GError              **error);
void g_resolver_lookup_by_address_async(GResolver            *resolver, GInetAddress         *address, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gchar      * g_resolver_lookup_by_address(GResolver            *resolver, GInetAddress         *address, GCancellable         *cancellable, GError              **error);
void g_resolver_free_addresses(GList                *addresses);
GList      * g_resolver_lookup_by_name_finish(GResolver            *resolver, GAsyncResult         *result, GError              **error);
void g_resolver_lookup_by_name_async(GResolver            *resolver, const gchar          *hostname, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GList      * g_resolver_lookup_by_name(GResolver            *resolver, const gchar          *hostname, GCancellable         *cancellable, GError              **error);
void g_resolver_set_default(GResolver            *resolver);
GResolver  * g_resolver_get_default(void);
GType g_resolver_get_type(void);
void g_remote_action_group_change_action_state_full(GRemoteActionGroup *remote, const gchar        *action_name, GVariant           *value, GVariant           *platform_data);
void g_remote_action_group_activate_action_full(GRemoteActionGroup *remote, const gchar        *action_name, GVariant           *parameter, GVariant           *platform_data);
GType g_remote_action_group_get_type(void);
GType g_proxy_resolver_portal_get_type(void);
gchar 	      ** g_proxy_resolver_lookup_finish(GProxyResolver       *resolver, GAsyncResult         *result, GError              **error);
void g_proxy_resolver_lookup_async(GProxyResolver       *resolver, const gchar          *uri, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gchar 	      ** g_proxy_resolver_lookup(GProxyResolver       *resolver, const gchar          *uri, GCancellable         *cancellable, GError              **error);
gboolean g_proxy_resolver_is_supported(GProxyResolver       *resolver);
GProxyResolver  * g_proxy_resolver_get_default(void);
GType g_proxy_resolver_get_type(void);
GType g_proxy_address_enumerator_get_type(void);
const gchar     * g_proxy_address_get_uri(GProxyAddress *proxy);
const gchar     * g_proxy_address_get_password(GProxyAddress *proxy);
const gchar     * g_proxy_address_get_username(GProxyAddress *proxy);
guint16 g_proxy_address_get_destination_port(GProxyAddress *proxy);
const gchar     * g_proxy_address_get_destination_hostname(GProxyAddress *proxy);
const gchar     * g_proxy_address_get_destination_protocol(GProxyAddress *proxy);
const gchar     * g_proxy_address_get_protocol(GProxyAddress *proxy);
GSocketAddress  * g_proxy_address_new(GInetAddress *inetaddr, guint16       port, const gchar  *protocol, const gchar  *dest_hostname, guint16       dest_port, const gchar  *username, const gchar  *password);
GType g_proxy_address_get_type(void);
gboolean g_proxy_supports_hostname(GProxy               *proxy);
GIOStream  * g_proxy_connect_finish(GProxy               *proxy, GAsyncResult         *result, GError              **error);
void g_proxy_connect_async(GProxy               *proxy, GIOStream            *connection, GProxyAddress        *proxy_address, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GIOStream  * g_proxy_connect(GProxy               *proxy, GIOStream            *connection, GProxyAddress        *proxy_address, GCancellable         *cancellable, GError              **error);
GProxy     * g_proxy_get_default_for_protocol(const gchar *protocol);
GType g_proxy_get_type(void);
GPropertyAction  * g_property_action_new(const gchar *name, gpointer     object, const gchar *property_name);
GType g_property_action_get_type(void);
gboolean glib_network_available_in_sandbox(void);
gboolean glib_should_use_portal(void);
gboolean g_pollable_stream_write_all(GOutputStream  *stream, const void     *buffer, gsize           count, gboolean        blocking, gsize          *bytes_written, GCancellable   *cancellable, GError        **error);
gssize g_pollable_stream_write(GOutputStream  *stream, const void     *buffer, gsize           count, gboolean        blocking, GCancellable   *cancellable, GError        **error);
gssize g_pollable_stream_read(GInputStream   *stream, void           *buffer, gsize           count, gboolean        blocking, GCancellable   *cancellable, GError        **error);
GSource  * g_pollable_source_new_full(gpointer        pollable_stream, GSource        *child_source, GCancellable   *cancellable);
GSource  * g_pollable_source_new(GObject        *pollable_stream);
gssize g_pollable_output_stream_write_nonblocking(GPollableOutputStream  *stream, const void             *buffer, gsize                   count, GCancellable           *cancellable, GError                **error);
GSource  * g_pollable_output_stream_create_source(GPollableOutputStream  *stream, GCancellable           *cancellable);
gboolean g_pollable_output_stream_is_writable(GPollableOutputStream  *stream);
gboolean g_pollable_output_stream_can_poll(GPollableOutputStream  *stream);
GType g_pollable_output_stream_get_type(void);
gssize g_pollable_input_stream_read_nonblocking(GPollableInputStream  *stream, void                  *buffer, gsize                  count, GCancellable          *cancellable, GError               **error);
GSource  * g_pollable_input_stream_create_source(GPollableInputStream  *stream, GCancellable          *cancellable);
gboolean g_pollable_input_stream_is_readable(GPollableInputStream  *stream);
gboolean g_pollable_input_stream_can_poll(GPollableInputStream  *stream);
GType g_pollable_input_stream_get_type(void);
void g_permission_impl_update(GPermission  *permission, gboolean      allowed, gboolean      can_acquire, gboolean      can_release);
gboolean g_permission_get_can_release(GPermission   *permission);
gboolean g_permission_get_can_acquire(GPermission   *permission);
gboolean g_permission_get_allowed(GPermission   *permission);
gboolean g_permission_release_finish(GPermission          *permission, GAsyncResult         *result, GError              **error);
void g_permission_release_async(GPermission          *permission, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_permission_release(GPermission          *permission, GCancellable         *cancellable, GError              **error);
gboolean g_permission_acquire_finish(GPermission          *permission, GAsyncResult         *result, GError              **error);
void g_permission_acquire_async(GPermission          *permission, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_permission_acquire(GPermission          *permission, GCancellable         *cancellable, GError              **error);
GType g_permission_get_type(void);
void g_output_stream_clear_pending(GOutputStream             *stream);
gboolean g_output_stream_set_pending(GOutputStream             *stream, GError                   **error);
gboolean g_output_stream_has_pending(GOutputStream             *stream);
gboolean g_output_stream_is_closing(GOutputStream             *stream);
gboolean g_output_stream_is_closed(GOutputStream             *stream);
gboolean g_output_stream_close_finish(GOutputStream             *stream, GAsyncResult              *result, GError                   **error);
void g_output_stream_close_async(GOutputStream             *stream, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data);
gboolean g_output_stream_flush_finish(GOutputStream             *stream, GAsyncResult              *result, GError                   **error);
void g_output_stream_flush_async(GOutputStream             *stream, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data);
gssize g_output_stream_splice_finish(GOutputStream             *stream, GAsyncResult              *result, GError                   **error);
void g_output_stream_splice_async(GOutputStream             *stream, GInputStream              *source, GOutputStreamSpliceFlags   flags, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data);
gssize g_output_stream_write_bytes_finish(GOutputStream             *stream, GAsyncResult              *result, GError                   **error);
void g_output_stream_write_bytes_async(GOutputStream             *stream, GBytes                    *bytes, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data);
gboolean g_output_stream_write_all_finish(GOutputStream          *stream, GAsyncResult           *result, gsize                  *bytes_written, GError                **error);
void g_output_stream_write_all_async(GOutputStream           *stream, const void              *buffer, gsize                    count, int                      io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
gssize g_output_stream_write_finish(GOutputStream             *stream, GAsyncResult              *result, GError                   **error);
void g_output_stream_write_async(GOutputStream             *stream, const void                *buffer, gsize                      count, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data);
gboolean g_output_stream_close(GOutputStream             *stream, GCancellable              *cancellable, GError                   **error);
gboolean g_output_stream_flush(GOutputStream             *stream, GCancellable              *cancellable, GError                   **error);
gssize g_output_stream_splice(GOutputStream             *stream, GInputStream              *source, GOutputStreamSpliceFlags   flags, GCancellable              *cancellable, GError                   **error);
gssize g_output_stream_write_bytes(GOutputStream             *stream, GBytes                    *bytes, GCancellable              *cancellable, GError                   **error);
gboolean g_output_stream_vprintf(GOutputStream             *stream, gsize                     *bytes_written, GCancellable              *cancellable, GError                   **error, const gchar               *format, va_list                    args);
gboolean g_output_stream_printf(GOutputStream             *stream, gsize                     *bytes_written, GCancellable              *cancellable, GError                   **error, const gchar               *format, ...);
gboolean g_output_stream_write_all(GOutputStream             *stream, const void                *buffer, gsize                      count, gsize                     *bytes_written, GCancellable              *cancellable, GError                   **error);
gssize g_output_stream_write(GOutputStream             *stream, const void                *buffer, gsize                      count, GCancellable              *cancellable, GError                   **error);
GType g_output_stream_get_type(void);
GList  * g_osx_app_info_get_all_for_scheme(const gchar *scheme);
char   * g_osx_app_info_get_filename(GOsxAppInfo *info);
GType g_osx_app_info_get_type(void);
gboolean g_openuri_portal_open_uri_finish(GAsyncResult        *result, GError             **error);
void g_openuri_portal_open_uri_async(const char          *uri, const char          *parent_window, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_openuri_portal_open_uri(const char  *uri, const char  *parent_window, GError     **error);
void g_notification_set_default_action_and_target_value(GNotification *notification, const gchar   *action, GVariant      *target);
void g_notification_set_default_action_and_target(GNotification *notification, const gchar   *action, const gchar   *target_format, ...);
void g_notification_set_default_action(GNotification *notification, const gchar   *detailed_action);
void g_notification_add_button_with_target_value(GNotification *notification, const gchar   *label, const gchar   *action, GVariant      *target);
void g_notification_add_button_with_target(GNotification *notification, const gchar   *label, const gchar   *action, const gchar   *target_format, ...);
void g_notification_add_button(GNotification *notification, const gchar   *label, const gchar   *detailed_action);
void g_notification_set_priority(GNotification         *notification, GNotificationPriority  priority);
void g_notification_set_urgent(GNotification *notification, gboolean       urgent);
void g_notification_set_icon(GNotification *notification, GIcon         *icon);
void g_notification_set_body(GNotification *notification, const gchar   *body);
void g_notification_set_title(GNotification *notification, const gchar   *title);
GNotification  * g_notification_new(const gchar *title);
GType g_notification_get_type(void);
void g_network_service_set_scheme(GNetworkService *srv, const gchar *scheme);
const gchar          * g_network_service_get_scheme(GNetworkService *srv);
const gchar          * g_network_service_get_domain(GNetworkService *srv);
const gchar          * g_network_service_get_protocol(GNetworkService *srv);
const gchar          * g_network_service_get_service(GNetworkService *srv);
GSocketConnectable   * g_network_service_new(const gchar     *service, const gchar     *protocol, const gchar     *domain);
GType g_network_service_get_type(void);
GType g_network_monitor_portal_get_type(void);
gboolean g_network_monitor_can_reach_finish(GNetworkMonitor     *monitor, GAsyncResult        *result, GError             **error);
void g_network_monitor_can_reach_async(GNetworkMonitor     *monitor, GSocketConnectable  *connectable, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_network_monitor_can_reach(GNetworkMonitor     *monitor, GSocketConnectable  *connectable, GCancellable        *cancellable, GError             **error);
GNetworkConnectivity g_network_monitor_get_connectivity(GNetworkMonitor     *monitor);
gboolean g_network_monitor_get_network_metered(GNetworkMonitor     *monitor);
gboolean g_network_monitor_get_network_available(GNetworkMonitor     *monitor);
GNetworkMonitor       * g_network_monitor_get_default(void);
GType g_network_monitor_get_type(void);
const gchar         * g_network_address_get_scheme(GNetworkAddress  *addr);
guint16 g_network_address_get_port(GNetworkAddress  *addr);
const gchar         * g_network_address_get_hostname(GNetworkAddress  *addr);
GSocketConnectable  * g_network_address_parse_uri(const gchar      *uri, guint16           default_port, GError          **error);
GSocketConnectable  * g_network_address_parse(const gchar      *host_and_port, guint16           default_port, GError          **error);
GSocketConnectable  * g_network_address_new_loopback(guint16           port);
GSocketConnectable  * g_network_address_new(const gchar      *hostname, guint16           port);
GType g_network_address_get_type(void);
GSocketAddress  * g_native_socket_address_new(gpointer        native, gsize           len);
GType g_native_socket_address_get_type(void);
void g_mount_operation_reply(GMountOperation *op, GMountOperationResult result);
void g_mount_operation_set_choice(GMountOperation *op, int              choice);
int g_mount_operation_get_choice(GMountOperation *op);
void g_mount_operation_set_password_save(GMountOperation *op, GPasswordSave    save);
GPasswordSave g_mount_operation_get_password_save(GMountOperation *op);
void g_mount_operation_set_domain(GMountOperation *op, const char      *domain);
const char  * g_mount_operation_get_domain(GMountOperation *op);
void g_mount_operation_set_anonymous(GMountOperation *op, gboolean         anonymous);
gboolean g_mount_operation_get_anonymous(GMountOperation *op);
void g_mount_operation_set_password(GMountOperation *op, const char      *password);
const char  * g_mount_operation_get_password(GMountOperation *op);
void g_mount_operation_set_username(GMountOperation *op, const char      *username);
const char  * g_mount_operation_get_username(GMountOperation *op);
GMountOperation  * g_mount_operation_new(void);
GType g_mount_operation_get_type(void);
const gchar  * g_mount_get_sort_key(GMount              *mount);
gboolean g_mount_eject_with_operation_finish(GMount            *mount, GAsyncResult        *result, GError             **error);
void g_mount_eject_with_operation(GMount              *mount, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_mount_unmount_with_operation_finish(GMount          *mount, GAsyncResult        *result, GError             **error);
void g_mount_unmount_with_operation(GMount              *mount, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
void g_mount_unshadow(GMount              *mount);
void g_mount_shadow(GMount              *mount);
gboolean g_mount_is_shadowed(GMount              *mount);
gchar     ** g_mount_guess_content_type_sync(GMount              *mount, gboolean             force_rescan, GCancellable        *cancellable, GError             **error);
gchar     ** g_mount_guess_content_type_finish(GMount              *mount, GAsyncResult        *result, GError             **error);
void g_mount_guess_content_type(GMount              *mount, gboolean             force_rescan, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_mount_remount_finish(GMount              *mount, GAsyncResult        *result, GError             **error);
void g_mount_remount(GMount              *mount, GMountMountFlags     flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_mount_eject_finish(GMount              *mount, GAsyncResult        *result, GError             **error);
void g_mount_eject(GMount              *mount, GMountUnmountFlags   flags, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_mount_unmount_finish(GMount              *mount, GAsyncResult        *result, GError             **error);
void g_mount_unmount(GMount              *mount, GMountUnmountFlags   flags, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_mount_can_eject(GMount              *mount);
gboolean g_mount_can_unmount(GMount              *mount);
GDrive     * g_mount_get_drive(GMount              *mount);
GVolume    * g_mount_get_volume(GMount              *mount);
char       * g_mount_get_uuid(GMount              *mount);
GIcon      * g_mount_get_symbolic_icon(GMount              *mount);
GIcon      * g_mount_get_icon(GMount              *mount);
char       * g_mount_get_name(GMount              *mount);
GFile      * g_mount_get_default_location(GMount              *mount);
GFile      * g_mount_get_root(GMount              *mount);
GType g_mount_get_type(void);
GMenuModel  * g_menu_link_iter_get_value(GMenuLinkIter  *iter);
const gchar  * g_menu_link_iter_get_name(GMenuLinkIter  *iter);
gboolean g_menu_link_iter_next(GMenuLinkIter  *iter);
gboolean g_menu_link_iter_get_next(GMenuLinkIter  *iter, const gchar   **out_link, GMenuModel    **value);
GType g_menu_link_iter_get_type(void);
GVariant  * g_menu_attribute_iter_get_value(GMenuAttributeIter  *iter);
const gchar  * g_menu_attribute_iter_get_name(GMenuAttributeIter  *iter);
gboolean g_menu_attribute_iter_next(GMenuAttributeIter  *iter);
gboolean g_menu_attribute_iter_get_next(GMenuAttributeIter  *iter, const gchar        **out_name, GVariant           **value);
GType g_menu_attribute_iter_get_type(void);
void g_menu_model_items_changed(GMenuModel         *model, gint                position, gint                removed, gint                added);
GMenuModel  * g_menu_model_get_item_link(GMenuModel         *model, gint                item_index, const gchar        *link);
GMenuLinkIter  * g_menu_model_iterate_item_links(GMenuModel         *model, gint                item_index);
gboolean g_menu_model_get_item_attribute(GMenuModel         *model, gint                item_index, const gchar        *attribute, const gchar        *format_string, ...);
GVariant  * g_menu_model_get_item_attribute_value(GMenuModel         *model, gint                item_index, const gchar        *attribute, const GVariantType *expected_type);
GMenuAttributeIter  * g_menu_model_iterate_item_attributes(GMenuModel         *model, gint                item_index);
gint g_menu_model_get_n_items(GMenuModel         *model);
gboolean g_menu_model_is_mutable(GMenuModel         *model);
GType g_menu_model_get_type(void);
void g_dbus_connection_unexport_menu_model(GDBusConnection  *connection, guint             export_id);
guint g_dbus_connection_export_menu_model(GDBusConnection  *connection, const gchar      *object_path, GMenuModel       *menu, GError          **error);
void g_menu_item_set_icon(GMenuItem   *menu_item, GIcon       *icon);
void g_menu_item_set_detailed_action(GMenuItem   *menu_item, const gchar *detailed_action);
void g_menu_item_set_action_and_target(GMenuItem   *menu_item, const gchar *action, const gchar *format_string, ...);
void g_menu_item_set_action_and_target_value(GMenuItem   *menu_item, const gchar *action, GVariant    *target_value);
void g_menu_item_set_section(GMenuItem   *menu_item, GMenuModel  *section);
void g_menu_item_set_submenu(GMenuItem   *menu_item, GMenuModel  *submenu);
void g_menu_item_set_label(GMenuItem   *menu_item, const gchar *label);
void g_menu_item_set_link(GMenuItem   *menu_item, const gchar *link, GMenuModel  *model);
void g_menu_item_set_attribute(GMenuItem   *menu_item, const gchar *attribute, const gchar *format_string, ...);
void g_menu_item_set_attribute_value(GMenuItem   *menu_item, const gchar *attribute, GVariant    *value);
GMenuModel  * g_menu_item_get_link(GMenuItem   *menu_item, const gchar *link);
gboolean g_menu_item_get_attribute(GMenuItem   *menu_item, const gchar *attribute, const gchar *format_string, ...);
GVariant  * g_menu_item_get_attribute_value(GMenuItem   *menu_item, const gchar *attribute, const GVariantType *expected_type);
GMenuItem  * g_menu_item_new_section(const gchar *label, GMenuModel  *section);
GMenuItem  * g_menu_item_new_submenu(const gchar *label, GMenuModel  *submenu);
GMenuItem  * g_menu_item_new_from_model(GMenuModel  *model, gint         item_index);
GMenuItem  * g_menu_item_new(const gchar *label, const gchar *detailed_action);
GType g_menu_item_get_type(void);
void g_menu_append_submenu(GMenu       *menu, const gchar *label, GMenuModel  *submenu);
void g_menu_prepend_submenu(GMenu       *menu, const gchar *label, GMenuModel  *submenu);
void g_menu_insert_submenu(GMenu       *menu, gint        position, const gchar *label, GMenuModel  *submenu);
void g_menu_append_section(GMenu       *menu, const gchar *label, GMenuModel  *section);
void g_menu_prepend_section(GMenu       *menu, const gchar *label, GMenuModel  *section);
void g_menu_insert_section(GMenu       *menu, gint         position, const gchar *label, GMenuModel  *section);
void g_menu_append(GMenu       *menu, const gchar *label, const gchar *detailed_action);
void g_menu_prepend(GMenu       *menu, const gchar *label, const gchar *detailed_action);
void g_menu_insert(GMenu       *menu, gint         position, const gchar *label, const gchar *detailed_action);
void g_menu_remove_all(GMenu       *menu);
void g_menu_remove(GMenu       *menu, gint         position);
void g_menu_append_item(GMenu       *menu, GMenuItem   *item);
void g_menu_prepend_item(GMenu       *menu, GMenuItem   *item);
void g_menu_insert_item(GMenu       *menu, gint         position, GMenuItem   *item);
void g_menu_freeze(GMenu       *menu);
GMenu  * g_menu_new(void);
GType g_menu_get_type(void);
GBytes  * g_memory_output_stream_steal_as_bytes(GMemoryOutputStream *ostream);
gpointer g_memory_output_stream_steal_data(GMemoryOutputStream *ostream);
gsize g_memory_output_stream_get_data_size(GMemoryOutputStream *ostream);
gsize g_memory_output_stream_get_size(GMemoryOutputStream *ostream);
gpointer g_memory_output_stream_get_data(GMemoryOutputStream *ostream);
GOutputStream  * g_memory_output_stream_new_resizable(void);
GOutputStream  * g_memory_output_stream_new(gpointer             data, gsize                size, GReallocFunc         realloc_function, GDestroyNotify       destroy_function);
GType g_memory_output_stream_get_type(void);
void g_memory_input_stream_add_bytes(GMemoryInputStream     *stream, GBytes                 *bytes);
void g_memory_input_stream_add_data(GMemoryInputStream *stream, const void         *data, gssize              len, GDestroyNotify      destroy);
GInputStream  * g_memory_input_stream_new_from_bytes(GBytes            *bytes);
GInputStream  * g_memory_input_stream_new_from_data(const void         *data, gssize              len, GDestroyNotify      destroy);
GInputStream  * g_memory_input_stream_new(void);
GType g_memory_input_stream_get_type(void);
GInputStream  * g_loadable_icon_load_finish(GLoadableIcon        *icon, GAsyncResult         *res, char                **type, GError              **error);
void g_loadable_icon_load_async(GLoadableIcon        *icon, int                   size, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GInputStream  * g_loadable_icon_load(GLoadableIcon        *icon, int                   size, char                **type, GCancellable         *cancellable, GError              **error);
GType g_loadable_icon_get_type(void);
void g_list_store_splice(GListStore *store, guint       position, guint       n_removals, gpointer   *additions, guint       n_additions);
void g_list_store_remove_all(GListStore *store);
void g_list_store_remove(GListStore *store, guint       position);
void g_list_store_append(GListStore *store, gpointer    item);
void g_list_store_sort(GListStore       *store, GCompareDataFunc  compare_func, gpointer          user_data);
guint g_list_store_insert_sorted(GListStore       *store, gpointer          item, GCompareDataFunc  compare_func, gpointer          user_data);
void g_list_store_insert(GListStore *store, guint       position, gpointer    item);
GListStore  * g_list_store_new(GType       item_type);
void g_list_model_items_changed(GListModel *list, guint       position, guint       removed, guint       added);
GObject  * g_list_model_get_object(GListModel *list, guint       position);
gpointer g_list_model_get_item(GListModel *list, guint       position);
guint g_list_model_get_n_items(GListModel *list);
GType g_list_model_get_item_type(GListModel *list);
void g_io_stream_clear_pending(GIOStream            *stream);
gboolean g_io_stream_set_pending(GIOStream            *stream, GError              **error);
gboolean g_io_stream_has_pending(GIOStream            *stream);
gboolean g_io_stream_is_closed(GIOStream            *stream);
gboolean g_io_stream_close_finish(GIOStream            *stream, GAsyncResult         *result, GError              **error);
void g_io_stream_close_async(GIOStream            *stream, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_io_stream_close(GIOStream            *stream, GCancellable         *cancellable, GError              **error);
gboolean g_io_stream_splice_finish(GAsyncResult         *result, GError              **error);
void g_io_stream_splice_async(GIOStream            *stream1, GIOStream            *stream2, GIOStreamSpliceFlags  flags, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GOutputStream  * g_io_stream_get_output_stream(GIOStream            *stream);
GInputStream  * g_io_stream_get_input_stream(GIOStream            *stream);
GType g_io_stream_get_type(void);
void g_io_scheduler_job_send_to_mainloop_async(GIOSchedulerJob     *job, GSourceFunc          func, gpointer             user_data, GDestroyNotify       notify);
gboolean g_io_scheduler_job_send_to_mainloop(GIOSchedulerJob     *job, GSourceFunc          func, gpointer             user_data, GDestroyNotify       notify);
void g_io_scheduler_cancel_all_jobs(void);
void g_io_scheduler_push_job(GIOSchedulerJobFunc  job_func, gpointer             user_data, GDestroyNotify       notify, gint                 io_priority, GCancellable        *cancellable);
char  ** g_io_module_query(void);
void g_io_module_unload(GIOModule *module);
void g_io_module_load(GIOModule *module);
GTypeClass * g_io_extension_ref_class(GIOExtension      *extension);
gint g_io_extension_get_priority(GIOExtension      *extension);
const char  * g_io_extension_get_name(GIOExtension      *extension);
GType g_io_extension_get_type(GIOExtension      *extension);
GIOExtension  * g_io_extension_point_implement(const char        *extension_point_name, GType              type, const char        *extension_name, gint               priority);
GIOExtension  * g_io_extension_point_get_extension_by_name(GIOExtensionPoint *extension_point, const char        *name);
GList              * g_io_extension_point_get_extensions(GIOExtensionPoint *extension_point);
GType g_io_extension_point_get_required_type(GIOExtensionPoint *extension_point);
void g_io_extension_point_set_required_type(GIOExtensionPoint *extension_point, GType              type);
GIOExtensionPoint  * g_io_extension_point_lookup(const char        *name);
GIOExtensionPoint  * g_io_extension_point_register(const char        *name);
GList              * g_io_modules_load_all_in_directory_with_scope(const gchar       *dirname, GIOModuleScope    *scope);
void g_io_modules_scan_all_in_directory_with_scope(const gchar       *dirname, GIOModuleScope    *scope);
GList              * g_io_modules_load_all_in_directory(const gchar       *dirname);
void g_io_modules_scan_all_in_directory(const char        *dirname);
GIOModule          * g_io_module_new(const gchar       *filename);
GType g_io_module_get_type(void);
void g_io_module_scope_block(GIOModuleScope      *scope, const gchar         *basename);
void g_io_module_scope_free(GIOModuleScope      *scope);
GIOModuleScope  * g_io_module_scope_new(GIOModuleScopeFlags  flags);
GIOErrorEnum g_io_error_from_win32_error(gint error_code);
GIOErrorEnum g_io_error_from_errno(gint err_no);
GQuark g_io_error_quark(void);
int handle_tree(int argc, char *argv[], gboolean do_help);
int handle_trash(int argc, char *argv[], gboolean do_help);
int handle_set(int argc, char *argv[], gboolean do_help);
int handle_save(int argc, char *argv[], gboolean do_help);
int handle_remove(int argc, char *argv[], gboolean do_help);
int handle_rename(int argc, char *argv[], gboolean do_help);
int handle_open(int argc, char *argv[], gboolean do_help);
int handle_move(int argc, char *argv[], gboolean do_help);
int handle_mount(int argc, char *argv[], gboolean do_help);
int handle_monitor(int argc, char *argv[], gboolean do_help);
int handle_mkdir(int argc, char *argv[], gboolean do_help);
int handle_mime(int argc, char *argv[], gboolean do_help);
int handle_list(int argc, char *argv[], gboolean do_help);
int handle_info(int argc, char *argv[], gboolean do_help);
int handle_copy(int argc, char *argv[], gboolean do_help);
int handle_cat(int argc, char *argv[], gboolean do_help);
gboolean file_is_dir(GFile *file);
char                * attribute_flags_to_string(GFileAttributeInfoFlags  flags);
GFileAttributeType attribute_type_from_string(const char              *str);
const char          * attribute_type_to_string(GFileAttributeType       type);
const char          * file_type_to_string(GFileType                type);
void show_help(GOptionContext *context, const char     *message);
void print_file_error(GFile          *file, const gchar    *message);
void print_error(const gchar    *format, ...);
void g_input_stream_clear_pending(GInputStream          *stream);
gboolean g_input_stream_set_pending(GInputStream          *stream, GError               **error);
gboolean g_input_stream_has_pending(GInputStream          *stream);
gboolean g_input_stream_is_closed(GInputStream          *stream);
gboolean g_input_stream_close_finish(GInputStream          *stream, GAsyncResult          *result, GError               **error);
void g_input_stream_close_async(GInputStream          *stream, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gssize g_input_stream_skip_finish(GInputStream          *stream, GAsyncResult          *result, GError               **error);
void g_input_stream_skip_async(GInputStream          *stream, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
GBytes   * g_input_stream_read_bytes_finish(GInputStream          *stream, GAsyncResult          *result, GError               **error);
void g_input_stream_read_bytes_async(GInputStream          *stream, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gboolean g_input_stream_read_all_finish(GInputStream          *stream, GAsyncResult          *result, gsize                 *bytes_read, GError               **error);
void g_input_stream_read_all_async(GInputStream          *stream, void                  *buffer, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gssize g_input_stream_read_finish(GInputStream          *stream, GAsyncResult          *result, GError               **error);
void g_input_stream_read_async(GInputStream          *stream, void                  *buffer, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gboolean g_input_stream_close(GInputStream          *stream, GCancellable          *cancellable, GError               **error);
gssize g_input_stream_skip(GInputStream          *stream, gsize                  count, GCancellable          *cancellable, GError               **error);
GBytes   * g_input_stream_read_bytes(GInputStream          *stream, gsize                  count, GCancellable          *cancellable, GError               **error);
gboolean g_input_stream_read_all(GInputStream          *stream, void                  *buffer, gsize                  count, gsize                 *bytes_read, GCancellable          *cancellable, GError               **error);
gssize g_input_stream_read(GInputStream          *stream, void                  *buffer, gsize                  count, GCancellable          *cancellable, GError               **error);
GType g_input_stream_get_type(void);
GObject * g_initable_new_valist(GType          object_type, const gchar   *first_property_name, va_list        var_args, GCancellable  *cancellable, GError       **error);
gpointer g_initable_newv(GType          object_type, guint          n_parameters, GParameter    *parameters, GCancellable  *cancellable, GError       **error);
gpointer g_initable_new(GType          object_type, GCancellable  *cancellable, GError       **error, const gchar   *first_property_name, ...);
gboolean g_initable_init(GInitable     *initable, GCancellable  *cancellable, GError       **error);
GType g_initable_get_type(void);
guint32 g_inet_socket_address_get_scope_id(GInetSocketAddress *address);
guint32 g_inet_socket_address_get_flowinfo(GInetSocketAddress *address);
guint16 g_inet_socket_address_get_port(GInetSocketAddress *address);
GInetAddress  * g_inet_socket_address_get_address(GInetSocketAddress *address);
GSocketAddress  * g_inet_socket_address_new_from_string(const char         *address, guint               port);
GSocketAddress  * g_inet_socket_address_new(GInetAddress       *address, guint16             port);
GType g_inet_socket_address_get_type(void);
gboolean g_inet_address_mask_equal(GInetAddressMask  *mask, GInetAddressMask  *mask2);
gboolean g_inet_address_mask_matches(GInetAddressMask  *mask, GInetAddress      *address);
guint g_inet_address_mask_get_length(GInetAddressMask  *mask);
GInetAddress      * g_inet_address_mask_get_address(GInetAddressMask  *mask);
GSocketFamily g_inet_address_mask_get_family(GInetAddressMask  *mask);
gchar             * g_inet_address_mask_to_string(GInetAddressMask  *mask);
GInetAddressMask  * g_inet_address_mask_new_from_string(const gchar       *mask_string, GError           **error);
GInetAddressMask  * g_inet_address_mask_new(GInetAddress      *addr, guint              length, GError           **error);
GType g_inet_address_mask_get_type(void);
gboolean g_inet_address_get_is_mc_site_local(GInetAddress         *address);
gboolean g_inet_address_get_is_mc_org_local(GInetAddress         *address);
gboolean g_inet_address_get_is_mc_node_local(GInetAddress         *address);
gboolean g_inet_address_get_is_mc_link_local(GInetAddress         *address);
gboolean g_inet_address_get_is_mc_global(GInetAddress         *address);
gboolean g_inet_address_get_is_multicast(GInetAddress         *address);
gboolean g_inet_address_get_is_site_local(GInetAddress         *address);
gboolean g_inet_address_get_is_link_local(GInetAddress         *address);
gboolean g_inet_address_get_is_loopback(GInetAddress         *address);
gboolean g_inet_address_get_is_any(GInetAddress         *address);
GSocketFamily g_inet_address_get_family(GInetAddress         *address);
gsize g_inet_address_get_native_size(GInetAddress         *address);
const guint8  * g_inet_address_to_bytes(GInetAddress         *address);
gchar  * g_inet_address_to_string(GInetAddress         *address);
gboolean g_inet_address_equal(GInetAddress         *address, GInetAddress         *other_address);
GInetAddress  * g_inet_address_new_any(GSocketFamily         family);
GInetAddress  * g_inet_address_new_loopback(GSocketFamily         family);
GInetAddress  * g_inet_address_new_from_bytes(const guint8         *bytes, GSocketFamily         family);
GInetAddress  * g_inet_address_new_from_string(const gchar          *string);
GType g_inet_address_get_type(void);
GIcon  * g_icon_deserialize(GVariant      *value);
GVariant  * g_icon_serialize(GIcon         *icon);
GIcon    * g_icon_new_for_string(const gchar   *str, GError       **error);
gchar    * g_icon_to_string(GIcon         *icon);
gboolean g_icon_equal(GIcon         *icon1, GIcon         *icon2);
guint g_icon_hash(gconstpointer  icon);
GType g_icon_get_type(void);
void g_filter_output_stream_set_close_base_stream(GFilterOutputStream *stream, gboolean             close_base);
gboolean g_filter_output_stream_get_close_base_stream(GFilterOutputStream *stream);
GOutputStream  * g_filter_output_stream_get_base_stream(GFilterOutputStream *stream);
GType g_filter_output_stream_get_type(void);
void g_filter_input_stream_set_close_base_stream(GFilterInputStream *stream, gboolean            close_base);
gboolean g_filter_input_stream_get_close_base_stream(GFilterInputStream *stream);
GInputStream  * g_filter_input_stream_get_base_stream(GFilterInputStream *stream);
GType g_filter_input_stream_get_type(void);
char  * g_file_output_stream_get_etag(GFileOutputStream    *stream);
GFileInfo  * g_file_output_stream_query_info_finish(GFileOutputStream    *stream, GAsyncResult         *result, GError              **error);
void g_file_output_stream_query_info_async(GFileOutputStream    *stream, const char           *attributes, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GFileInfo  * g_file_output_stream_query_info(GFileOutputStream    *stream, const char           *attributes, GCancellable         *cancellable, GError              **error);
GType g_file_output_stream_get_type(void);
void g_filename_completer_set_dirs_only(GFilenameCompleter *completer, gboolean dirs_only);
char  ** g_filename_completer_get_completions(GFilenameCompleter *completer, const char *initial_text);
char  * g_filename_completer_get_completion_suffix(GFilenameCompleter *completer, const char *initial_text);
GFilenameCompleter  * g_filename_completer_new(void);
GType g_filename_completer_get_type(void);
void g_file_monitor_emit_event(GFileMonitor      *monitor, GFile             *child, GFile             *other_file, GFileMonitorEvent  event_type);
void g_file_monitor_set_rate_limit(GFileMonitor      *monitor, gint               limit_msecs);
gboolean g_file_monitor_is_cancelled(GFileMonitor      *monitor);
gboolean g_file_monitor_cancel(GFileMonitor      *monitor);
GType g_file_monitor_get_type(void);
char  * g_file_io_stream_get_etag(GFileIOStream    *stream);
GFileInfo  * g_file_io_stream_query_info_finish(GFileIOStream    *stream, GAsyncResult         *result, GError              **error);
void g_file_io_stream_query_info_async(GFileIOStream    *stream, const char           *attributes, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GFileInfo  * g_file_io_stream_query_info(GFileIOStream    *stream, const char           *attributes, GCancellable         *cancellable, GError              **error);
GType g_file_io_stream_get_type(void);
GFileInfo  * g_file_input_stream_query_info_finish(GFileInputStream     *stream, GAsyncResult         *result, GError              **error);
void g_file_input_stream_query_info_async(GFileInputStream     *stream, const char           *attributes, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GFileInfo  * g_file_input_stream_query_info(GFileInputStream     *stream, const char           *attributes, GCancellable         *cancellable, GError              **error);
GType g_file_input_stream_get_type(void);
char  * g_file_attribute_matcher_to_string(GFileAttributeMatcher *matcher);
const char  * g_file_attribute_matcher_enumerate_next(GFileAttributeMatcher *matcher);
gboolean g_file_attribute_matcher_enumerate_namespace(GFileAttributeMatcher *matcher, const char            *ns);
gboolean g_file_attribute_matcher_matches_only(GFileAttributeMatcher *matcher, const char            *attribute);
gboolean g_file_attribute_matcher_matches(GFileAttributeMatcher *matcher, const char            *attribute);
GFileAttributeMatcher  * g_file_attribute_matcher_subtract(GFileAttributeMatcher *matcher, GFileAttributeMatcher *subtract);
void g_file_attribute_matcher_unref(GFileAttributeMatcher *matcher);
GFileAttributeMatcher  * g_file_attribute_matcher_ref(GFileAttributeMatcher *matcher);
GFileAttributeMatcher  * g_file_attribute_matcher_new(const char            *attributes);
GType g_file_attribute_matcher_get_type(void);
void g_file_info_set_sort_order(GFileInfo         *info, gint32             sort_order);
void g_file_info_set_symlink_target(GFileInfo         *info, const char        *symlink_target);
void g_file_info_set_modification_time(GFileInfo         *info, GTimeVal          *mtime);
void g_file_info_set_size(GFileInfo         *info, goffset            size);
void g_file_info_set_content_type(GFileInfo         *info, const char        *content_type);
void g_file_info_set_symbolic_icon(GFileInfo         *info, GIcon             *icon);
void g_file_info_set_icon(GFileInfo         *info, GIcon             *icon);
void g_file_info_set_edit_name(GFileInfo         *info, const char        *edit_name);
void g_file_info_set_display_name(GFileInfo         *info, const char        *display_name);
void g_file_info_set_name(GFileInfo         *info, const char        *name);
void g_file_info_set_is_symlink(GFileInfo         *info, gboolean           is_symlink);
void g_file_info_set_is_hidden(GFileInfo         *info, gboolean           is_hidden);
void g_file_info_set_file_type(GFileInfo         *info, GFileType          type);
void g_file_info_unset_attribute_mask(GFileInfo         *info);
void g_file_info_set_attribute_mask(GFileInfo         *info, GFileAttributeMatcher *mask);
gint32 g_file_info_get_sort_order(GFileInfo         *info);
const char  * g_file_info_get_etag(GFileInfo         *info);
const char  * g_file_info_get_symlink_target(GFileInfo         *info);
void g_file_info_get_modification_time(GFileInfo         *info, GTimeVal          *result);
goffset g_file_info_get_size(GFileInfo         *info);
const char  * g_file_info_get_content_type(GFileInfo         *info);
GIcon  * g_file_info_get_symbolic_icon(GFileInfo         *info);
GIcon  * g_file_info_get_icon(GFileInfo         *info);
const char  * g_file_info_get_edit_name(GFileInfo         *info);
const char  * g_file_info_get_display_name(GFileInfo         *info);
const char  * g_file_info_get_name(GFileInfo         *info);
gboolean g_file_info_get_is_symlink(GFileInfo         *info);
gboolean g_file_info_get_is_backup(GFileInfo         *info);
gboolean g_file_info_get_is_hidden(GFileInfo         *info);
GFileType g_file_info_get_file_type(GFileInfo         *info);
GDateTime  * g_file_info_get_deletion_date(GFileInfo         *info);
void g_file_info_clear_status(GFileInfo  *info);
void g_file_info_set_attribute_stringv(GFileInfo  *info, const char *attribute, char      **attr_value);
void g_file_info_set_attribute_object(GFileInfo  *info, const char *attribute, GObject    *attr_value);
void g_file_info_set_attribute_int64(GFileInfo  *info, const char *attribute, gint64      attr_value);
void g_file_info_set_attribute_uint64(GFileInfo  *info, const char *attribute, guint64     attr_value);
void g_file_info_set_attribute_int32(GFileInfo  *info, const char *attribute, gint32      attr_value);
void g_file_info_set_attribute_uint32(GFileInfo  *info, const char *attribute, guint32     attr_value);
void g_file_info_set_attribute_boolean(GFileInfo  *info, const char *attribute, gboolean    attr_value);
void g_file_info_set_attribute_byte_string(GFileInfo  *info, const char *attribute, const char *attr_value);
void g_file_info_set_attribute_string(GFileInfo  *info, const char *attribute, const char *attr_value);
void g_file_info_set_attribute(GFileInfo  *info, const char *attribute, GFileAttributeType type, gpointer    value_p);
char  ** g_file_info_get_attribute_stringv(GFileInfo  *info, const char *attribute);
GObject  * g_file_info_get_attribute_object(GFileInfo  *info, const char *attribute);
gint64 g_file_info_get_attribute_int64(GFileInfo  *info, const char *attribute);
guint64 g_file_info_get_attribute_uint64(GFileInfo  *info, const char *attribute);
gint32 g_file_info_get_attribute_int32(GFileInfo  *info, const char *attribute);
guint32 g_file_info_get_attribute_uint32(GFileInfo  *info, const char *attribute);
gboolean g_file_info_get_attribute_boolean(GFileInfo  *info, const char *attribute);
const char  * g_file_info_get_attribute_byte_string(GFileInfo  *info, const char *attribute);
const char  * g_file_info_get_attribute_string(GFileInfo  *info, const char *attribute);
char  * g_file_info_get_attribute_as_string(GFileInfo  *info, const char *attribute);
gboolean g_file_info_set_attribute_status(GFileInfo  *info, const char *attribute, GFileAttributeStatus status);
GFileAttributeStatus g_file_info_get_attribute_status(GFileInfo  *info, const char *attribute);
void g_file_info_remove_attribute(GFileInfo  *info, const char *attribute);
GFileAttributeType g_file_info_get_attribute_type(GFileInfo  *info, const char *attribute);
gboolean g_file_info_get_attribute_data(GFileInfo  *info, const char *attribute, GFileAttributeType *type, gpointer   *value_pp, GFileAttributeStatus *status);
char  ** g_file_info_list_attributes(GFileInfo  *info, const char *name_space);
gboolean g_file_info_has_namespace(GFileInfo  *info, const char *name_space);
gboolean g_file_info_has_attribute(GFileInfo  *info, const char *attribute);
void g_file_info_copy_into(GFileInfo  *src_info, GFileInfo  *dest_info);
GFileInfo  * g_file_info_dup(GFileInfo  *other);
GFileInfo  * g_file_info_new(void);
GType g_file_info_get_type(void);
GFile  * g_file_icon_get_file(GFileIcon *icon);
GIcon  * g_file_icon_new(GFile     *file);
GType g_file_icon_get_type(void);
gboolean g_file_enumerator_iterate(GFileEnumerator  *direnum, GFileInfo       **out_info, GFile           **out_child, GCancellable     *cancellable, GError          **error);
GFile  * g_file_enumerator_get_child(GFileEnumerator *enumerator, GFileInfo       *info);
GFile  * g_file_enumerator_get_container(GFileEnumerator *enumerator);
void g_file_enumerator_set_pending(GFileEnumerator      *enumerator, gboolean              pending);
gboolean g_file_enumerator_has_pending(GFileEnumerator      *enumerator);
gboolean g_file_enumerator_is_closed(GFileEnumerator      *enumerator);
gboolean g_file_enumerator_close_finish(GFileEnumerator      *enumerator, GAsyncResult         *result, GError              **error);
void g_file_enumerator_close_async(GFileEnumerator      *enumerator, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GList  * g_file_enumerator_next_files_finish(GFileEnumerator      *enumerator, GAsyncResult         *result, GError              **error);
void g_file_enumerator_next_files_async(GFileEnumerator      *enumerator, int                   num_files, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_file_enumerator_close(GFileEnumerator      *enumerator, GCancellable         *cancellable, GError              **error);
GFileInfo  * g_file_enumerator_next_file(GFileEnumerator      *enumerator, GCancellable         *cancellable, GError              **error);
GType g_file_enumerator_get_type(void);
int g_file_descriptor_based_get_fd(GFileDescriptorBased *fd_based);
GType g_file_descriptor_based_get_type(void);
void g_file_attribute_info_list_add(GFileAttributeInfoList *list, const char             *name, GFileAttributeType      type, GFileAttributeInfoFlags flags);
const GFileAttributeInfo  * g_file_attribute_info_list_lookup(GFileAttributeInfoList *list, const char             *name);
GFileAttributeInfoList  * g_file_attribute_info_list_dup(GFileAttributeInfoList *list);
void g_file_attribute_info_list_unref(GFileAttributeInfoList *list);
GFileAttributeInfoList  * g_file_attribute_info_list_ref(GFileAttributeInfoList *list);
GFileAttributeInfoList  * g_file_attribute_info_list_new(void);
GType g_file_attribute_info_list_get_type(void);
GBytes   * g_file_load_bytes_finish(GFile                  *file, GAsyncResult           *result, gchar                 **etag_out, GError                **error);
void g_file_load_bytes_async(GFile                  *file, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data);
GBytes   * g_file_load_bytes(GFile                  *file, GCancellable           *cancellable, gchar                 **etag_out, GError                **error);
gboolean g_file_supports_thread_contexts(GFile                  *file);
gboolean g_file_replace_contents_finish(GFile                  *file, GAsyncResult           *res, char                  **new_etag, GError                **error);
void g_file_replace_contents_bytes_async(GFile                  *file, GBytes                 *contents, const char             *etag, gboolean                make_backup, GFileCreateFlags        flags, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data);
void g_file_replace_contents_async(GFile                  *file, const char             *contents, gsize                   length, const char             *etag, gboolean                make_backup, GFileCreateFlags        flags, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data);
gboolean g_file_replace_contents(GFile                  *file, const char             *contents, gsize                   length, const char             *etag, gboolean                make_backup, GFileCreateFlags        flags, char                  **new_etag, GCancellable           *cancellable, GError                **error);
gboolean g_file_load_partial_contents_finish(GFile                  *file, GAsyncResult           *res, char                  **contents, gsize                  *length, char                  **etag_out, GError                **error);
void g_file_load_partial_contents_async(GFile                  *file, GCancellable           *cancellable, GFileReadMoreCallback   read_more_callback, GAsyncReadyCallback     callback, gpointer                user_data);
gboolean g_file_load_contents_finish(GFile                  *file, GAsyncResult           *res, char                  **contents, gsize                  *length, char                  **etag_out, GError                **error);
void g_file_load_contents_async(GFile                  *file, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data);
gboolean g_file_load_contents(GFile                  *file, GCancellable           *cancellable, char                  **contents, gsize                  *length, char                  **etag_out, GError                **error);
GAppInfo  * g_file_query_default_handler(GFile                  *file, GCancellable           *cancellable, GError                **error);
gboolean g_file_poll_mountable_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_poll_mountable(GFile                      *file, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_stop_mountable_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_stop_mountable(GFile                      *file, GMountUnmountFlags          flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_start_mountable_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_start_mountable(GFile                      *file, GDriveStartFlags            flags, GMountOperation            *start_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_measure_disk_usage_finish(GFile                         *file, GAsyncResult                  *result, guint64                       *disk_usage, guint64                       *num_dirs, guint64                       *num_files, GError                       **error);
void g_file_measure_disk_usage_async(GFile                         *file, GFileMeasureFlags              flags, gint                           io_priority, GCancellable                  *cancellable, GFileMeasureProgressCallback   progress_callback, gpointer                       progress_data, GAsyncReadyCallback            callback, gpointer                       user_data);
gboolean g_file_measure_disk_usage(GFile                         *file, GFileMeasureFlags              flags, GCancellable                  *cancellable, GFileMeasureProgressCallback   progress_callback, gpointer                       progress_data, guint64                       *disk_usage, guint64                       *num_dirs, guint64                       *num_files, GError                       **error);
GFileMonitor * g_file_monitor(GFile                  *file, GFileMonitorFlags       flags, GCancellable           *cancellable, GError                **error);
GFileMonitor * g_file_monitor_file(GFile                  *file, GFileMonitorFlags       flags, GCancellable           *cancellable, GError                **error);
GFileMonitor * g_file_monitor_directory(GFile                  *file, GFileMonitorFlags       flags, GCancellable           *cancellable, GError                **error);
gboolean g_file_copy_attributes(GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_eject_mountable_with_operation_finish(GFile           *file, GAsyncResult               *result, GError                    **error);
void g_file_eject_mountable_with_operation(GFile                  *file, GMountUnmountFlags          flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_eject_mountable_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_eject_mountable(GFile                      *file, GMountUnmountFlags          flags, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_unmount_mountable_with_operation_finish(GFile         *file, GAsyncResult               *result, GError                    **error);
void g_file_unmount_mountable_with_operation(GFile                *file, GMountUnmountFlags          flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_unmount_mountable_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_unmount_mountable(GFile                      *file, GMountUnmountFlags          flags, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFile  * g_file_mount_mountable_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_mount_mountable(GFile                      *file, GMountMountFlags            flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_mount_enclosing_volume_finish(GFile                      *location, GAsyncResult               *result, GError                    **error);
void g_file_mount_enclosing_volume(GFile                      *location, GMountMountFlags            flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_set_attribute_int64(GFile                      *file, const char                 *attribute, gint64                      value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_set_attribute_uint64(GFile                      *file, const char                 *attribute, guint64                     value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_set_attribute_int32(GFile                      *file, const char                 *attribute, gint32                      value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_set_attribute_uint32(GFile                      *file, const char                 *attribute, guint32                     value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_set_attribute_byte_string(GFile                      *file, const char                 *attribute, const char                 *value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_set_attribute_string(GFile                      *file, const char                 *attribute, const char                 *value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_set_attributes_finish(GFile                      *file, GAsyncResult               *result, GFileInfo                 **info, GError                    **error);
void g_file_set_attributes_async(GFile                      *file, GFileInfo                  *info, GFileQueryInfoFlags         flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_set_attributes_from_info(GFile                      *file, GFileInfo                  *info, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
gboolean g_file_set_attribute(GFile                      *file, const char                 *attribute, GFileAttributeType          type, gpointer                    value_p, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
GFileAttributeInfoList  * g_file_query_writable_namespaces(GFile                      *file, GCancellable               *cancellable, GError                    **error);
GFileAttributeInfoList  * g_file_query_settable_attributes(GFile                      *file, GCancellable               *cancellable, GError                    **error);
gboolean g_file_make_symbolic_link(GFile                      *file, const char                 *symlink_value, GCancellable               *cancellable, GError                    **error);
gboolean g_file_make_directory_with_parents(GFile                     *file, GCancellable               *cancellable, GError                    **error);
gboolean g_file_make_directory_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_make_directory_async(GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_make_directory(GFile                      *file, GCancellable               *cancellable, GError                    **error);
gboolean g_file_move(GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, GCancellable               *cancellable, GFileProgressCallback       progress_callback, gpointer                    progress_callback_data, GError                    **error);
gboolean g_file_copy_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_copy_async(GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, int                         io_priority, GCancellable               *cancellable, GFileProgressCallback       progress_callback, gpointer                    progress_callback_data, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_copy(GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, GCancellable               *cancellable, GFileProgressCallback       progress_callback, gpointer                    progress_callback_data, GError                    **error);
gboolean g_file_trash_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_trash_async(GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_trash(GFile                      *file, GCancellable               *cancellable, GError                    **error);
gboolean g_file_delete_finish(GFile                      *file, GAsyncResult               *result, GError                    **error);
void g_file_delete_async(GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
gboolean g_file_delete(GFile                      *file, GCancellable               *cancellable, GError                    **error);
GFile  * g_file_set_display_name_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_set_display_name_async(GFile                      *file, const char                 *display_name, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFile  * g_file_set_display_name(GFile                      *file, const char                 *display_name, GCancellable               *cancellable, GError                    **error);
GFileEnumerator  * g_file_enumerate_children_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_enumerate_children_async(GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileEnumerator  * g_file_enumerate_children(GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
GMount  * g_file_find_enclosing_mount_finish(GFile                     *file, GAsyncResult              *res, GError                   **error);
void g_file_find_enclosing_mount_async(GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GMount  * g_file_find_enclosing_mount(GFile                      *file, GCancellable               *cancellable, GError                    **error);
GFileInfo  * g_file_query_filesystem_info_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_query_filesystem_info_async(GFile                      *file, const char                 *attributes, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileInfo  * g_file_query_filesystem_info(GFile                      *file, const char                 *attributes, GCancellable               *cancellable, GError                    **error);
GFileInfo  * g_file_query_info_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_query_info_async(GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileInfo  * g_file_query_info(GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error);
GFileType g_file_query_file_type(GFile                      *file, GFileQueryInfoFlags         flags, GCancellable               *cancellable);
gboolean g_file_query_exists(GFile                      *file, GCancellable               *cancellable);
GFileIOStream  * g_file_replace_readwrite_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_replace_readwrite_async(GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileIOStream  * g_file_replace_readwrite(GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, GCancellable               *cancellable, GError                    **error);
GFileIOStream  * g_file_create_readwrite_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_create_readwrite_async(GFile                      *file, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileIOStream  * g_file_create_readwrite(GFile                      *file, GFileCreateFlags            flags, GCancellable               *cancellable, GError                    **error);
GFileIOStream  * g_file_open_readwrite_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_open_readwrite_async(GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileIOStream  * g_file_open_readwrite(GFile                      *file, GCancellable               *cancellable, GError                    **error);
GFileOutputStream  * g_file_replace_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_replace_async(GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileOutputStream  * g_file_create_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_create_async(GFile                      *file, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileOutputStream  * g_file_append_to_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_append_to_async(GFile                      *file, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileOutputStream  * g_file_replace(GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, GCancellable               *cancellable, GError                    **error);
GFileOutputStream  * g_file_create(GFile                      *file, GFileCreateFlags             flags, GCancellable               *cancellable, GError                    **error);
GFileOutputStream  * g_file_append_to(GFile                      *file, GFileCreateFlags             flags, GCancellable               *cancellable, GError                    **error);
GFileInputStream  * g_file_read_finish(GFile                      *file, GAsyncResult               *res, GError                    **error);
void g_file_read_async(GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data);
GFileInputStream  * g_file_read(GFile                      *file, GCancellable               *cancellable, GError                    **error);
char  * g_file_get_uri_scheme(GFile                      *file);
gboolean g_file_has_uri_scheme(GFile                      *file, const char                 *uri_scheme);
gboolean g_file_is_native(GFile                      *file);
GFile  * g_file_resolve_relative_path(GFile                      *file, const char                 *relative_path);
char  * g_file_get_relative_path(GFile                      *parent, GFile                      *descendant);
gboolean g_file_has_prefix(GFile                      *file, GFile                      *prefix);
GFile  * g_file_get_child_for_display_name(GFile                      *file, const char                 *display_name, GError                    **error);
GFile  * g_file_get_child(GFile                      *file, const char                 *name);
gboolean g_file_has_parent(GFile                      *file, GFile                      *parent);
GFile  * g_file_get_parent(GFile                      *file);
char  * g_file_get_parse_name(GFile                      *file);
char  * g_file_get_uri(GFile                      *file);
const char  * g_file_peek_path(GFile                      *file);
char  * g_file_get_path(GFile                      *file);
char  * g_file_get_basename(GFile                      *file);
gboolean g_file_equal(GFile                      *file1, GFile                      *file2);
guint g_file_hash(gconstpointer               file);
GFile  * g_file_dup(GFile                      *file);
GFile  * g_file_new_build_filename(const gchar                *first_element, ...);
GFile  * g_file_parse_name(const char                 *parse_name);
GFile  * g_file_new_tmp(const char                 *tmpl, GFileIOStream             **iostream, GError                    **error);
GFile  * g_file_new_for_commandline_arg_and_cwd(const gchar           *arg, const gchar           *cwd);
GFile  * g_file_new_for_commandline_arg(const char                 *arg);
GFile  * g_file_new_for_uri(const char                 *uri);
GFile  * g_file_new_for_path(const char                 *path);
GType g_file_get_type(void);
void g_emblemed_icon_clear_emblems(GEmblemedIcon *emblemed);
void g_emblemed_icon_add_emblem(GEmblemedIcon *emblemed, GEmblem       *emblem);
GList  * g_emblemed_icon_get_emblems(GEmblemedIcon *emblemed);
GIcon  * g_emblemed_icon_get_icon(GEmblemedIcon *emblemed);
GIcon  * g_emblemed_icon_new(GIcon         *icon, GEmblem       *emblem);
GType g_emblemed_icon_get_type(void);
GEmblemOrigin g_emblem_get_origin(GEmblem       *emblem);
GIcon          * g_emblem_get_icon(GEmblem       *emblem);
GEmblem        * g_emblem_new_with_origin(GIcon         *icon, GEmblemOrigin  origin);
GEmblem        * g_emblem_new(GIcon         *icon);
GType g_emblem_get_type(void);
GDatagramBased  * g_dtls_server_connection_new(GDatagramBased   *base_socket, GTlsCertificate  *certificate, GError          **error);
GType g_dtls_server_connection_get_type(void);
gboolean g_dtls_connection_emit_accept_certificate(GDtlsConnection       *conn, GTlsCertificate       *peer_cert, GTlsCertificateFlags   errors);
gboolean g_dtls_connection_close_finish(GDtlsConnection       *conn, GAsyncResult          *result, GError               **error);
void g_dtls_connection_close_async(GDtlsConnection       *conn, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gboolean g_dtls_connection_close(GDtlsConnection       *conn, GCancellable          *cancellable, GError               **error);
gboolean g_dtls_connection_shutdown_finish(GDtlsConnection       *conn, GAsyncResult          *result, GError               **error);
void g_dtls_connection_shutdown_async(GDtlsConnection       *conn, gboolean               shutdown_read, gboolean               shutdown_write, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gboolean g_dtls_connection_shutdown(GDtlsConnection       *conn, gboolean               shutdown_read, gboolean               shutdown_write, GCancellable          *cancellable, GError               **error);
gboolean g_dtls_connection_handshake_finish(GDtlsConnection       *conn, GAsyncResult          *result, GError               **error);
void g_dtls_connection_handshake_async(GDtlsConnection       *conn, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gboolean g_dtls_connection_handshake(GDtlsConnection       *conn, GCancellable          *cancellable, GError               **error);
GTlsRehandshakeMode g_dtls_connection_get_rehandshake_mode(GDtlsConnection       *conn);
void g_dtls_connection_set_rehandshake_mode(GDtlsConnection       *conn, GTlsRehandshakeMode    mode);
gboolean g_dtls_connection_get_require_close_notify(GDtlsConnection       *conn);
void g_dtls_connection_set_require_close_notify(GDtlsConnection       *conn, gboolean               require_close_notify);
GTlsCertificateFlags g_dtls_connection_get_peer_certificate_errors(GDtlsConnection       *conn);
GTlsCertificate       * g_dtls_connection_get_peer_certificate(GDtlsConnection       *conn);
GTlsInteraction       * g_dtls_connection_get_interaction(GDtlsConnection       *conn);
void g_dtls_connection_set_interaction(GDtlsConnection       *conn, GTlsInteraction       *interaction);
GTlsCertificate       * g_dtls_connection_get_certificate(GDtlsConnection       *conn);
void g_dtls_connection_set_certificate(GDtlsConnection       *conn, GTlsCertificate       *certificate);
GTlsDatabase          * g_dtls_connection_get_database(GDtlsConnection       *conn);
void g_dtls_connection_set_database(GDtlsConnection       *conn, GTlsDatabase          *database);
GType g_dtls_connection_get_type(void);
GList  * g_dtls_client_connection_get_accepted_cas(GDtlsClientConnection  *conn);
void g_dtls_client_connection_set_server_identity(GDtlsClientConnection  *conn, GSocketConnectable     *identity);
GSocketConnectable   * g_dtls_client_connection_get_server_identity(GDtlsClientConnection  *conn);
void g_dtls_client_connection_set_validation_flags(GDtlsClientConnection  *conn, GTlsCertificateFlags    flags);
GTlsCertificateFlags g_dtls_client_connection_get_validation_flags(GDtlsClientConnection  *conn);
GDatagramBased       * g_dtls_client_connection_new(GDatagramBased         *base_socket, GSocketConnectable     *server_identity, GError                **error);
GType g_dtls_client_connection_get_type(void);
const gchar  * g_drive_get_sort_key(GDrive               *drive);
gboolean g_drive_eject_with_operation_finish(GDrive            *drive, GAsyncResult        *result, GError             **error);
void g_drive_eject_with_operation(GDrive              *drive, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_drive_stop_finish(GDrive               *drive, GAsyncResult         *result, GError              **error);
void g_drive_stop(GDrive               *drive, GMountUnmountFlags    flags, GMountOperation      *mount_operation, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_drive_can_stop(GDrive               *drive);
gboolean g_drive_start_finish(GDrive               *drive, GAsyncResult         *result, GError              **error);
void g_drive_start(GDrive              *drive, GDriveStartFlags     flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_drive_can_start_degraded(GDrive              *drive);
gboolean g_drive_can_start(GDrive              *drive);
GDriveStartStopType g_drive_get_start_stop_type(GDrive        *drive);
char  ** g_drive_enumerate_identifiers(GDrive              *drive);
char  * g_drive_get_identifier(GDrive              *drive, const char          *kind);
gboolean g_drive_poll_for_media_finish(GDrive               *drive, GAsyncResult         *result, GError              **error);
void g_drive_poll_for_media(GDrive               *drive, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_drive_eject_finish(GDrive               *drive, GAsyncResult         *result, GError              **error);
void g_drive_eject(GDrive               *drive, GMountUnmountFlags    flags, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_drive_can_eject(GDrive               *drive);
gboolean g_drive_can_poll_for_media(GDrive               *drive);
gboolean g_drive_is_media_check_automatic(GDrive               *drive);
gboolean g_drive_has_media(GDrive               *drive);
gboolean g_drive_is_media_removable(GDrive               *drive);
gboolean g_drive_is_removable(GDrive               *drive);
GList  * g_drive_get_volumes(GDrive               *drive);
gboolean g_drive_has_volumes(GDrive               *drive);
GIcon  * g_drive_get_symbolic_icon(GDrive               *drive);
GIcon  * g_drive_get_icon(GDrive               *drive);
char  * g_drive_get_name(GDrive               *drive);
GType g_drive_get_type(void);
GList  * g_document_portal_add_documents(GList       *uris, const char  *app_id, GError     **error);
char  * g_document_portal_add_document(GFile   *file, GError **error);
GList  * g_desktop_app_info_get_implementations(const gchar *interface);
gchar  *** g_desktop_app_info_search(const gchar *search_string);
gboolean g_desktop_app_info_launch_uris_as_manager(GDesktopAppInfo            *appinfo, GList                      *uris, GAppLaunchContext          *launch_context, GSpawnFlags                 spawn_flags, GSpawnChildSetupFunc        user_setup, gpointer                    user_setup_data, GDesktopAppLaunchCallback   pid_callback, gpointer                    pid_callback_data, GError                    **error);
GAppInfo  * g_desktop_app_info_lookup_get_default_for_uri_scheme(GDesktopAppInfoLookup *lookup, const char            *uri_scheme);
GType g_desktop_app_info_lookup_get_type(void);
gchar  * g_desktop_app_info_get_action_name(GDesktopAppInfo   *info, const gchar       *action_name);
void g_desktop_app_info_launch_action(GDesktopAppInfo   *info, const gchar       *action_name, GAppLaunchContext *launch_context);
const gchar  * const * g_desktop_app_info_list_actions(GDesktopAppInfo   *info);
gboolean g_desktop_app_info_get_boolean(GDesktopAppInfo *info, const char      *key);
char  * g_desktop_app_info_get_locale_string(GDesktopAppInfo *info, const char      *key);
char  * g_desktop_app_info_get_string(GDesktopAppInfo *info, const char      *key);
gboolean g_desktop_app_info_has_key(GDesktopAppInfo *info, const char      *key);
void g_desktop_app_info_set_desktop_env(const char      *desktop_env);
gboolean g_desktop_app_info_get_is_hidden(GDesktopAppInfo *info);
GDesktopAppInfo  * g_desktop_app_info_new(const char      *desktop_id);
const char  * g_desktop_app_info_get_startup_wm_class(GDesktopAppInfo *info);
gboolean g_desktop_app_info_get_show_in(GDesktopAppInfo *info, const gchar     *desktop_env);
gboolean g_desktop_app_info_get_nodisplay(GDesktopAppInfo *info);
const char  * const * g_desktop_app_info_get_keywords(GDesktopAppInfo *info);
const char  * g_desktop_app_info_get_categories(GDesktopAppInfo *info);
const char  * g_desktop_app_info_get_generic_name(GDesktopAppInfo *info);
const char  * g_desktop_app_info_get_filename(GDesktopAppInfo *info);
GDesktopAppInfo  * g_desktop_app_info_new_from_keyfile(GKeyFile        *key_file);
GDesktopAppInfo  * g_desktop_app_info_new_from_filename(const char      *filename);
GType g_desktop_app_info_get_type(void);
GVariant  * g_dbus_gvalue_to_gvariant(const GValue         *gvalue, const GVariantType   *type);
void g_dbus_gvariant_to_gvalue(GVariant  *value, GValue    *out_gvalue);
gboolean g_dbus_is_interface_name(const gchar *string);
gboolean g_dbus_is_member_name(const gchar *string);
gboolean g_dbus_is_unique_name(const gchar *string);
gboolean g_dbus_is_name(const gchar *string);
gchar  * g_dbus_generate_guid(void);
gboolean g_dbus_is_guid(const gchar *string);
gboolean g_dbus_server_is_active(GDBusServer       *server);
void g_dbus_server_stop(GDBusServer       *server);
void g_dbus_server_start(GDBusServer       *server);
GDBusServerFlags g_dbus_server_get_flags(GDBusServer       *server);
const gchar       * g_dbus_server_get_guid(GDBusServer       *server);
const gchar       * g_dbus_server_get_client_address(GDBusServer       *server);
GDBusServer       * g_dbus_server_new_sync(const gchar       *address, GDBusServerFlags   flags, const gchar       *guid, GDBusAuthObserver *observer, GCancellable      *cancellable, GError           **error);
GType g_dbus_server_get_type(void);
GVariant         * g_dbus_proxy_call_with_unix_fd_list_sync(GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GUnixFDList         *fd_list, GUnixFDList        **out_fd_list, GCancellable        *cancellable, GError             **error);
GVariant         * g_dbus_proxy_call_with_unix_fd_list_finish(GDBusProxy          *proxy, GUnixFDList        **out_fd_list, GAsyncResult        *res, GError             **error);
void g_dbus_proxy_call_with_unix_fd_list(GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GUnixFDList         *fd_list, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GVariant         * g_dbus_proxy_call_sync(GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GCancellable        *cancellable, GError             **error);
GVariant         * g_dbus_proxy_call_finish(GDBusProxy          *proxy, GAsyncResult        *res, GError             **error);
void g_dbus_proxy_call(GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gchar           ** g_dbus_proxy_get_cached_property_names(GDBusProxy          *proxy);
void g_dbus_proxy_set_cached_property(GDBusProxy          *proxy, const gchar         *property_name, GVariant            *value);
GVariant         * g_dbus_proxy_get_cached_property(GDBusProxy          *proxy, const gchar         *property_name);
void g_dbus_proxy_set_interface_info(GDBusProxy           *proxy, GDBusInterfaceInfo   *info);
GDBusInterfaceInfo  * g_dbus_proxy_get_interface_info(GDBusProxy          *proxy);
void g_dbus_proxy_set_default_timeout(GDBusProxy          *proxy, gint                 timeout_msec);
gint g_dbus_proxy_get_default_timeout(GDBusProxy          *proxy);
const gchar      * g_dbus_proxy_get_interface_name(GDBusProxy          *proxy);
const gchar      * g_dbus_proxy_get_object_path(GDBusProxy          *proxy);
gchar            * g_dbus_proxy_get_name_owner(GDBusProxy          *proxy);
const gchar      * g_dbus_proxy_get_name(GDBusProxy          *proxy);
GDBusProxyFlags g_dbus_proxy_get_flags(GDBusProxy          *proxy);
GDBusConnection  * g_dbus_proxy_get_connection(GDBusProxy          *proxy);
GDBusProxy       * g_dbus_proxy_new_for_bus_sync(GBusType             bus_type, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GError             **error);
GDBusProxy       * g_dbus_proxy_new_for_bus_finish(GAsyncResult        *res, GError             **error);
void g_dbus_proxy_new_for_bus(GBusType             bus_type, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GDBusProxy       * g_dbus_proxy_new_sync(GDBusConnection     *connection, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GError             **error);
GDBusProxy       * g_dbus_proxy_new_finish(GAsyncResult        *res, GError             **error);
void g_dbus_proxy_new(GDBusConnection     *connection, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GType g_dbus_proxy_get_type(void);
void g_dbus_object_skeleton_set_object_path(GDBusObjectSkeleton    *object, const gchar            *object_path);
void g_dbus_object_skeleton_remove_interface_by_name(GDBusObjectSkeleton    *object, const gchar            *interface_name);
void g_dbus_object_skeleton_remove_interface(GDBusObjectSkeleton    *object, GDBusInterfaceSkeleton *interface_);
void g_dbus_object_skeleton_add_interface(GDBusObjectSkeleton    *object, GDBusInterfaceSkeleton *interface_);
void g_dbus_object_skeleton_flush(GDBusObjectSkeleton    *object);
GDBusObjectSkeleton  * g_dbus_object_skeleton_new(const gchar            *object_path);
GType g_dbus_object_skeleton_get_type(void);
GDBusConnection   * g_dbus_object_proxy_get_connection(GDBusObjectProxy  *proxy);
GDBusObjectProxy  * g_dbus_object_proxy_new(GDBusConnection   *connection, const gchar       *object_path);
GType g_dbus_object_proxy_get_type(void);
gboolean g_dbus_object_manager_server_unexport(GDBusObjectManagerServer  *manager, const gchar               *object_path);
gboolean g_dbus_object_manager_server_is_exported(GDBusObjectManagerServer  *manager, GDBusObjectSkeleton       *object);
void g_dbus_object_manager_server_export_uniquely(GDBusObjectManagerServer  *manager, GDBusObjectSkeleton       *object);
void g_dbus_object_manager_server_export(GDBusObjectManagerServer  *manager, GDBusObjectSkeleton       *object);
void g_dbus_object_manager_server_set_connection(GDBusObjectManagerServer  *manager, GDBusConnection           *connection);
GDBusConnection           * g_dbus_object_manager_server_get_connection(GDBusObjectManagerServer  *manager);
GDBusObjectManagerServer  * g_dbus_object_manager_server_new(const gchar               *object_path);
GType g_dbus_object_manager_server_get_type(void);
gchar                         * g_dbus_object_manager_client_get_name_owner(GDBusObjectManagerClient      *manager);
const gchar                   * g_dbus_object_manager_client_get_name(GDBusObjectManagerClient      *manager);
GDBusObjectManagerClientFlags g_dbus_object_manager_client_get_flags(GDBusObjectManagerClient      *manager);
GDBusConnection               * g_dbus_object_manager_client_get_connection(GDBusObjectManagerClient      *manager);
GDBusObjectManager            * g_dbus_object_manager_client_new_for_bus_sync(GBusType                       bus_type, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GError                       **error);
GDBusObjectManager            * g_dbus_object_manager_client_new_for_bus_finish(GAsyncResult                  *res, GError                       **error);
void g_dbus_object_manager_client_new_for_bus(GBusType                       bus_type, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GAsyncReadyCallback            callback, gpointer                       user_data);
GDBusObjectManager            * g_dbus_object_manager_client_new_sync(GDBusConnection               *connection, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GError                       **error);
GDBusObjectManager            * g_dbus_object_manager_client_new_finish(GAsyncResult                  *res, GError                       **error);
void g_dbus_object_manager_client_new(GDBusConnection               *connection, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GAsyncReadyCallback            callback, gpointer                       user_data);
GType g_dbus_object_manager_client_get_type(void);
GDBusInterface   * g_dbus_object_manager_get_interface(GDBusObjectManager    *manager, const gchar           *object_path, const gchar           *interface_name);
GDBusObject      * g_dbus_object_manager_get_object(GDBusObjectManager    *manager, const gchar           *object_path);
GList            * g_dbus_object_manager_get_objects(GDBusObjectManager    *manager);
const gchar      * g_dbus_object_manager_get_object_path(GDBusObjectManager    *manager);
GType g_dbus_object_manager_get_type(void);
GDBusInterface   * g_dbus_object_get_interface(GDBusObject  *object, const gchar  *interface_name);
GList            * g_dbus_object_get_interfaces(GDBusObject  *object);
const gchar      * g_dbus_object_get_object_path(GDBusObject  *object);
GType g_dbus_object_get_type(void);
void g_bus_unwatch_name(guint                     watcher_id);
guint g_bus_watch_name_on_connection_with_closures(GDBusConnection          *connection, const gchar              *name, GBusNameWatcherFlags      flags, GClosure                 *name_appeared_closure, GClosure                 *name_vanished_closure);
guint g_bus_watch_name_with_closures(GBusType                  bus_type, const gchar              *name, GBusNameWatcherFlags      flags, GClosure                 *name_appeared_closure, GClosure                 *name_vanished_closure);
guint g_bus_watch_name_on_connection(GDBusConnection          *connection, const gchar              *name, GBusNameWatcherFlags      flags, GBusNameAppearedCallback  name_appeared_handler, GBusNameVanishedCallback  name_vanished_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func);
guint g_bus_watch_name(GBusType                  bus_type, const gchar              *name, GBusNameWatcherFlags      flags, GBusNameAppearedCallback  name_appeared_handler, GBusNameVanishedCallback  name_vanished_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func);
void g_bus_unown_name(guint                     owner_id);
guint g_bus_own_name_on_connection_with_closures(GDBusConnection          *connection, const gchar              *name, GBusNameOwnerFlags        flags, GClosure                 *name_acquired_closure, GClosure                 *name_lost_closure);
guint g_bus_own_name_with_closures(GBusType                  bus_type, const gchar              *name, GBusNameOwnerFlags        flags, GClosure                 *bus_acquired_closure, GClosure                 *name_acquired_closure, GClosure                 *name_lost_closure);
guint g_bus_own_name_on_connection(GDBusConnection          *connection, const gchar              *name, GBusNameOwnerFlags        flags, GBusNameAcquiredCallback  name_acquired_handler, GBusNameLostCallback      name_lost_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func);
guint g_bus_own_name(GBusType                  bus_type, const gchar              *name, GBusNameOwnerFlags        flags, GBusAcquiredCallback      bus_acquired_handler, GBusNameAcquiredCallback  name_acquired_handler, GBusNameLostCallback      name_lost_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func);
void g_dbus_method_invocation_return_dbus_error(GDBusMethodInvocation *invocation, const gchar           *error_name, const gchar           *error_message);
void g_dbus_method_invocation_take_error(GDBusMethodInvocation *invocation, GError                *error);
void g_dbus_method_invocation_return_gerror(GDBusMethodInvocation *invocation, const GError          *error);
void g_dbus_method_invocation_return_error_literal(GDBusMethodInvocation *invocation, GQuark                 domain, gint                   code, const gchar           *message);
void g_dbus_method_invocation_return_error_valist(GDBusMethodInvocation *invocation, GQuark                 domain, gint                   code, const gchar           *format, va_list                var_args);
void g_dbus_method_invocation_return_error(GDBusMethodInvocation *invocation, GQuark                 domain, gint                   code, const gchar           *format, ...);
void g_dbus_method_invocation_return_value_with_unix_fd_list(GDBusMethodInvocation *invocation, GVariant              *parameters, GUnixFDList           *fd_list);
void g_dbus_method_invocation_return_value(GDBusMethodInvocation *invocation, GVariant              *parameters);
gpointer g_dbus_method_invocation_get_user_data(GDBusMethodInvocation *invocation);
GVariant               * g_dbus_method_invocation_get_parameters(GDBusMethodInvocation *invocation);
GDBusMessage           * g_dbus_method_invocation_get_message(GDBusMethodInvocation *invocation);
GDBusConnection        * g_dbus_method_invocation_get_connection(GDBusMethodInvocation *invocation);
const GDBusPropertyInfo  * g_dbus_method_invocation_get_property_info(GDBusMethodInvocation *invocation);
const GDBusMethodInfo  * g_dbus_method_invocation_get_method_info(GDBusMethodInvocation *invocation);
const gchar            * g_dbus_method_invocation_get_method_name(GDBusMethodInvocation *invocation);
const gchar            * g_dbus_method_invocation_get_interface_name(GDBusMethodInvocation *invocation);
const gchar            * g_dbus_method_invocation_get_object_path(GDBusMethodInvocation *invocation);
const gchar            * g_dbus_method_invocation_get_sender(GDBusMethodInvocation *invocation);
GType g_dbus_method_invocation_get_type(void);
gboolean g_dbus_message_to_gerror(GDBusMessage             *message, GError                  **error);
guchar                    * g_dbus_message_to_blob(GDBusMessage             *message, gsize                    *out_size, GDBusCapabilityFlags      capabilities, GError                  **error);
gssize g_dbus_message_bytes_needed(guchar                   *blob, gsize                     blob_len, GError                  **error);
GDBusMessage              * g_dbus_message_new_from_blob(guchar                   *blob, gsize                     blob_len, GDBusCapabilityFlags      capabilities, GError                  **error);
const gchar               * g_dbus_message_get_arg0(GDBusMessage             *message);
void g_dbus_message_set_num_unix_fds(GDBusMessage             *message, guint32                   value);
guint32 g_dbus_message_get_num_unix_fds(GDBusMessage             *message);
void g_dbus_message_set_signature(GDBusMessage             *message, const gchar              *value);
const gchar               * g_dbus_message_get_signature(GDBusMessage             *message);
void g_dbus_message_set_error_name(GDBusMessage             *message, const gchar              *value);
const gchar               * g_dbus_message_get_error_name(GDBusMessage             *message);
void g_dbus_message_set_destination(GDBusMessage             *message, const gchar              *value);
const gchar               * g_dbus_message_get_destination(GDBusMessage             *message);
void g_dbus_message_set_sender(GDBusMessage             *message, const gchar              *value);
const gchar               * g_dbus_message_get_sender(GDBusMessage             *message);
void g_dbus_message_set_path(GDBusMessage             *message, const gchar              *value);
const gchar               * g_dbus_message_get_path(GDBusMessage             *message);
void g_dbus_message_set_member(GDBusMessage             *message, const gchar              *value);
const gchar               * g_dbus_message_get_member(GDBusMessage             *message);
void g_dbus_message_set_interface(GDBusMessage             *message, const gchar              *value);
const gchar               * g_dbus_message_get_interface(GDBusMessage             *message);
void g_dbus_message_set_reply_serial(GDBusMessage             *message, guint32                   value);
guint32 g_dbus_message_get_reply_serial(GDBusMessage             *message);
void g_dbus_message_set_unix_fd_list(GDBusMessage             *message, GUnixFDList              *fd_list);
GUnixFDList               * g_dbus_message_get_unix_fd_list(GDBusMessage             *message);
void g_dbus_message_set_body(GDBusMessage             *message, GVariant                 *body);
GVariant                  * g_dbus_message_get_body(GDBusMessage             *message);
guchar                    * g_dbus_message_get_header_fields(GDBusMessage             *message);
void g_dbus_message_set_header(GDBusMessage             *message, GDBusMessageHeaderField   header_field, GVariant                 *value);
GVariant                  * g_dbus_message_get_header(GDBusMessage             *message, GDBusMessageHeaderField   header_field);
void g_dbus_message_set_serial(GDBusMessage             *message, guint32                   serial);
guint32 g_dbus_message_get_serial(GDBusMessage             *message);
void g_dbus_message_set_flags(GDBusMessage             *message, GDBusMessageFlags         flags);
GDBusMessageFlags g_dbus_message_get_flags(GDBusMessage             *message);
void g_dbus_message_set_message_type(GDBusMessage             *message, GDBusMessageType          type);
GDBusMessageType g_dbus_message_get_message_type(GDBusMessage             *message);
void g_dbus_message_set_byte_order(GDBusMessage             *message, GDBusMessageByteOrder     byte_order);
GDBusMessageByteOrder g_dbus_message_get_byte_order(GDBusMessage             *message);
GDBusMessage              * g_dbus_message_copy(GDBusMessage             *message, GError                  **error);
void g_dbus_message_lock(GDBusMessage             *message);
gboolean g_dbus_message_get_locked(GDBusMessage             *message);
gchar                     * g_dbus_message_print(GDBusMessage             *message, guint                     indent);
GDBusMessage              * g_dbus_message_new_method_error_literal(GDBusMessage             *method_call_message, const gchar              *error_name, const gchar              *error_message);
GDBusMessage              * g_dbus_message_new_method_error_valist(GDBusMessage             *method_call_message, const gchar              *error_name, const gchar              *error_message_format, va_list                   var_args);
GDBusMessage              * g_dbus_message_new_method_error(GDBusMessage             *method_call_message, const gchar              *error_name, const gchar              *error_message_format, ...);
GDBusMessage              * g_dbus_message_new_method_reply(GDBusMessage             *method_call_message);
GDBusMessage              * g_dbus_message_new_method_call(const gchar              *name, const gchar              *path, const gchar              *interface_, const gchar              *method);
GDBusMessage              * g_dbus_message_new_signal(const gchar              *path, const gchar              *interface_, const gchar              *signal);
GDBusMessage              * g_dbus_message_new(void);
GType g_dbus_message_get_type(void);
GDBusMenuModel  * g_dbus_menu_model_get(GDBusConnection *connection, const gchar     *bus_name, const gchar     *object_path);
GType g_dbus_menu_model_get_type(void);
GType g_dbus_annotation_info_get_type(void);
GType g_dbus_arg_info_get_type(void);
GType g_dbus_property_info_get_type(void);
GType g_dbus_signal_info_get_type(void);
GType g_dbus_method_info_get_type(void);
GType g_dbus_interface_info_get_type(void);
GType g_dbus_node_info_get_type(void);
void g_dbus_annotation_info_unref(GDBusAnnotationInfo  *info);
void g_dbus_arg_info_unref(GDBusArgInfo         *info);
void g_dbus_property_info_unref(GDBusPropertyInfo    *info);
void g_dbus_signal_info_unref(GDBusSignalInfo      *info);
void g_dbus_method_info_unref(GDBusMethodInfo      *info);
void g_dbus_interface_info_unref(GDBusInterfaceInfo   *info);
void g_dbus_node_info_unref(GDBusNodeInfo        *info);
GDBusAnnotationInfo  * g_dbus_annotation_info_ref(GDBusAnnotationInfo  *info);
GDBusArgInfo         * g_dbus_arg_info_ref(GDBusArgInfo         *info);
GDBusPropertyInfo    * g_dbus_property_info_ref(GDBusPropertyInfo    *info);
GDBusSignalInfo      * g_dbus_signal_info_ref(GDBusSignalInfo      *info);
GDBusMethodInfo      * g_dbus_method_info_ref(GDBusMethodInfo      *info);
GDBusInterfaceInfo   * g_dbus_interface_info_ref(GDBusInterfaceInfo   *info);
GDBusNodeInfo        * g_dbus_node_info_ref(GDBusNodeInfo        *info);
void g_dbus_node_info_generate_xml(GDBusNodeInfo        *info, guint                 indent, GString              *string_builder);
GDBusInterfaceInfo  * g_dbus_node_info_lookup_interface(GDBusNodeInfo        *info, const gchar          *name);
GDBusNodeInfo       * g_dbus_node_info_new_for_xml(const gchar          *xml_data, GError              **error);
void g_dbus_interface_info_generate_xml(GDBusInterfaceInfo   *info, guint                 indent, GString              *string_builder);
void g_dbus_interface_info_cache_release(GDBusInterfaceInfo   *info);
void g_dbus_interface_info_cache_build(GDBusInterfaceInfo   *info);
GDBusPropertyInfo   * g_dbus_interface_info_lookup_property(GDBusInterfaceInfo   *info, const gchar          *name);
GDBusSignalInfo     * g_dbus_interface_info_lookup_signal(GDBusInterfaceInfo   *info, const gchar          *name);
GDBusMethodInfo     * g_dbus_interface_info_lookup_method(GDBusInterfaceInfo   *info, const gchar          *name);
const gchar         * g_dbus_annotation_info_lookup(GDBusAnnotationInfo **annotations, const gchar          *name);
const gchar                  * g_dbus_interface_skeleton_get_object_path(GDBusInterfaceSkeleton      *interface_);
gboolean g_dbus_interface_skeleton_has_connection(GDBusInterfaceSkeleton      *interface_, GDBusConnection             *connection);
GList                        * g_dbus_interface_skeleton_get_connections(GDBusInterfaceSkeleton      *interface_);
GDBusConnection              * g_dbus_interface_skeleton_get_connection(GDBusInterfaceSkeleton      *interface_);
void g_dbus_interface_skeleton_unexport_from_connection(GDBusInterfaceSkeleton      *interface_, GDBusConnection             *connection);
void g_dbus_interface_skeleton_unexport(GDBusInterfaceSkeleton      *interface_);
gboolean g_dbus_interface_skeleton_export(GDBusInterfaceSkeleton      *interface_, GDBusConnection             *connection, const gchar                 *object_path, GError                     **error);
void g_dbus_interface_skeleton_flush(GDBusInterfaceSkeleton      *interface_);
GVariant                     * g_dbus_interface_skeleton_get_properties(GDBusInterfaceSkeleton      *interface_);
GDBusInterfaceVTable         * g_dbus_interface_skeleton_get_vtable(GDBusInterfaceSkeleton      *interface_);
GDBusInterfaceInfo           * g_dbus_interface_skeleton_get_info(GDBusInterfaceSkeleton      *interface_);
void g_dbus_interface_skeleton_set_flags(GDBusInterfaceSkeleton      *interface_, GDBusInterfaceSkeletonFlags  flags);
GDBusInterfaceSkeletonFlags g_dbus_interface_skeleton_get_flags(GDBusInterfaceSkeleton      *interface_);
GType g_dbus_interface_skeleton_get_type(void);
GDBusObject           * g_dbus_interface_dup_object(GDBusInterface      *interface_);
void g_dbus_interface_set_object(GDBusInterface      *interface_, GDBusObject         *object);
GDBusObject           * g_dbus_interface_get_object(GDBusInterface      *interface_);
GDBusInterfaceInfo    * g_dbus_interface_get_info(GDBusInterface      *interface_);
GType g_dbus_interface_get_type(void);
gchar    * g_dbus_error_encode_gerror(const GError    *error);
void g_dbus_error_set_dbus_error_valist(GError         **error, const gchar     *dbus_error_name, const gchar     *dbus_error_message, const gchar     *format, va_list          var_args);
void g_dbus_error_set_dbus_error(GError         **error, const gchar     *dbus_error_name, const gchar     *dbus_error_message, const gchar     *format, ...);
GError   * g_dbus_error_new_for_dbus_error(const gchar     *dbus_error_name, const gchar     *dbus_error_message);
void g_dbus_error_register_error_domain(const gchar           *error_domain_quark_name, volatile gsize        *quark_volatile, const GDBusErrorEntry *entries, guint                  num_entries);
gboolean g_dbus_error_unregister_error(GQuark                 error_domain, gint                   error_code, const gchar           *dbus_error_name);
gboolean g_dbus_error_register_error(GQuark                 error_domain, gint                   error_code, const gchar           *dbus_error_name);
gboolean g_dbus_error_strip_remote_error(GError          *error);
gchar    * g_dbus_error_get_remote_error(const GError    *error);
gboolean g_dbus_error_is_remote_error(const GError    *error);
GQuark g_dbus_error_quark(void);
void g_dbus_connection_remove_filter(GDBusConnection    *connection, guint               filter_id);
guint g_dbus_connection_add_filter(GDBusConnection            *connection, GDBusMessageFilterFunction  filter_function, gpointer                    user_data, GDestroyNotify              user_data_free_func);
void g_dbus_connection_signal_unsubscribe(GDBusConnection     *connection, guint                subscription_id);
guint g_dbus_connection_signal_subscribe(GDBusConnection     *connection, const gchar         *sender, const gchar         *interface_name, const gchar         *member, const gchar         *object_path, const gchar         *arg0, GDBusSignalFlags     flags, GDBusSignalCallback  callback, gpointer             user_data, GDestroyNotify       user_data_free_func);
gboolean g_dbus_connection_unregister_subtree(GDBusConnection            *connection, guint                       registration_id);
guint g_dbus_connection_register_subtree(GDBusConnection            *connection, const gchar                *object_path, const GDBusSubtreeVTable   *vtable, GDBusSubtreeFlags           flags, gpointer                    user_data, GDestroyNotify              user_data_free_func, GError                    **error);
gboolean g_dbus_connection_unregister_object(GDBusConnection            *connection, guint                       registration_id);
guint g_dbus_connection_register_object_with_closures(GDBusConnection         *connection, const gchar             *object_path, GDBusInterfaceInfo      *interface_info, GClosure                *method_call_closure, GClosure                *get_property_closure, GClosure                *set_property_closure, GError                 **error);
guint g_dbus_connection_register_object(GDBusConnection            *connection, const gchar                *object_path, GDBusInterfaceInfo         *interface_info, const GDBusInterfaceVTable *vtable, gpointer                    user_data, GDestroyNotify              user_data_free_func, GError                    **error);
GVariant  * g_dbus_connection_call_with_unix_fd_list_sync(GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GUnixFDList        *fd_list, GUnixFDList       **out_fd_list, GCancellable       *cancellable, GError            **error);
GVariant  * g_dbus_connection_call_with_unix_fd_list_finish(GDBusConnection    *connection, GUnixFDList       **out_fd_list, GAsyncResult       *res, GError            **error);
void g_dbus_connection_call_with_unix_fd_list(GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GUnixFDList        *fd_list, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data);
GVariant  * g_dbus_connection_call_sync(GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GCancellable       *cancellable, GError            **error);
GVariant  * g_dbus_connection_call_finish(GDBusConnection    *connection, GAsyncResult       *res, GError            **error);
void g_dbus_connection_call(GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data);
gboolean g_dbus_connection_emit_signal(GDBusConnection    *connection, const gchar        *destination_bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *signal_name, GVariant           *parameters, GError            **error);
GDBusMessage     * g_dbus_connection_send_message_with_reply_sync(GDBusConnection     *connection, GDBusMessage        *message, GDBusSendMessageFlags flags, gint                 timeout_msec, volatile guint32    *out_serial, GCancellable        *cancellable, GError             **error);
GDBusMessage     * g_dbus_connection_send_message_with_reply_finish(GDBusConnection     *connection, GAsyncResult        *res, GError             **error);
void g_dbus_connection_send_message_with_reply(GDBusConnection     *connection, GDBusMessage        *message, GDBusSendMessageFlags flags, gint                 timeout_msec, volatile guint32    *out_serial, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_dbus_connection_send_message(GDBusConnection     *connection, GDBusMessage        *message, GDBusSendMessageFlags flags, volatile guint32    *out_serial, GError             **error);
gboolean g_dbus_connection_flush_sync(GDBusConnection     *connection, GCancellable        *cancellable, GError             **error);
gboolean g_dbus_connection_flush_finish(GDBusConnection     *connection, GAsyncResult        *res, GError             **error);
void g_dbus_connection_flush(GDBusConnection     *connection, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
gboolean g_dbus_connection_close_sync(GDBusConnection     *connection, GCancellable        *cancellable, GError             **error);
gboolean g_dbus_connection_close_finish(GDBusConnection     *connection, GAsyncResult        *res, GError             **error);
void g_dbus_connection_close(GDBusConnection     *connection, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GDBusCapabilityFlags g_dbus_connection_get_capabilities(GDBusConnection    *connection);
void g_dbus_connection_set_exit_on_close(GDBusConnection    *connection, gboolean            exit_on_close);
gboolean g_dbus_connection_get_exit_on_close(GDBusConnection    *connection);
guint32 g_dbus_connection_get_last_serial(GDBusConnection    *connection);
GCredentials     * g_dbus_connection_get_peer_credentials(GDBusConnection    *connection);
const gchar      * g_dbus_connection_get_unique_name(GDBusConnection    *connection);
const gchar      * g_dbus_connection_get_guid(GDBusConnection    *connection);
GIOStream        * g_dbus_connection_get_stream(GDBusConnection    *connection);
gboolean g_dbus_connection_is_closed(GDBusConnection    *connection);
void g_dbus_connection_start_message_processing(GDBusConnection    *connection);
GDBusConnection  * g_dbus_connection_new_for_address_sync(const gchar            *address, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GError                **error);
GDBusConnection  * g_dbus_connection_new_for_address_finish(GAsyncResult           *res, GError                **error);
void g_dbus_connection_new_for_address(const gchar            *address, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data);
GDBusConnection  * g_dbus_connection_new_sync(GIOStream              *stream, const gchar            *guid, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GError                **error);
GDBusConnection  * g_dbus_connection_new_finish(GAsyncResult           *res, GError                **error);
void g_dbus_connection_new(GIOStream              *stream, const gchar            *guid, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data);
GDBusConnection   * g_bus_get_sync(GBusType            bus_type, GCancellable       *cancellable, GError            **error);
GDBusConnection   * g_bus_get_finish(GAsyncResult        *res, GError             **error);
void g_bus_get(GBusType             bus_type, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data);
GType g_dbus_connection_get_type(void);
gboolean g_dbus_auth_observer_allow_mechanism(GDBusAuthObserver  *observer, const gchar        *mechanism);
gboolean g_dbus_auth_observer_authorize_authenticated_peer(GDBusAuthObserver  *observer, GIOStream          *stream, GCredentials       *credentials);
GDBusAuthObserver  * g_dbus_auth_observer_new(void);
GType g_dbus_auth_observer_get_type(void);
gchar                * g_dbus_address_get_for_bus_sync(GBusType              bus_type, GCancellable  *cancellable, GError              **error);
GIOStream            * g_dbus_address_get_stream_sync(const gchar          *address, gchar               **out_guid, GCancellable         *cancellable, GError              **error);
GIOStream            * g_dbus_address_get_stream_finish(GAsyncResult         *res, gchar               **out_guid, GError              **error);
void g_dbus_address_get_stream(const gchar          *address, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_dbus_is_supported_address(const gchar  *string, GError      **error);
gboolean g_dbus_is_address(const gchar *string);
gchar  * g_dbus_address_escape_value(const gchar *string);
GDBusActionGroup  * g_dbus_action_group_get(GDBusConnection        *connection, const gchar            *bus_name, const gchar            *object_path);
GType g_dbus_action_group_get_type(void);
gboolean g_data_output_stream_put_string(GDataOutputStream     *stream, const char            *str, GCancellable          *cancellable, GError               **error);
gboolean g_data_output_stream_put_uint64(GDataOutputStream     *stream, guint64                data, GCancellable          *cancellable, GError               **error);
gboolean g_data_output_stream_put_int64(GDataOutputStream     *stream, gint64                 data, GCancellable          *cancellable, GError               **error);
gboolean g_data_output_stream_put_uint32(GDataOutputStream     *stream, guint32                data, GCancellable          *cancellable, GError               **error);
gboolean g_data_output_stream_put_int32(GDataOutputStream     *stream, gint32                 data, GCancellable          *cancellable, GError               **error);
gboolean g_data_output_stream_put_uint16(GDataOutputStream     *stream, guint16                data, GCancellable          *cancellable, GError               **error);
gboolean g_data_output_stream_put_int16(GDataOutputStream     *stream, gint16                 data, GCancellable          *cancellable, GError               **error);
gboolean g_data_output_stream_put_byte(GDataOutputStream     *stream, guchar                 data, GCancellable          *cancellable, GError               **error);
GDataStreamByteOrder g_data_output_stream_get_byte_order(GDataOutputStream     *stream);
void g_data_output_stream_set_byte_order(GDataOutputStream     *stream, GDataStreamByteOrder   order);
GDataOutputStream  * g_data_output_stream_new(GOutputStream         *base_stream);
GType g_data_output_stream_get_type(void);
char  * g_data_input_stream_read_upto_finish(GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error);
void g_data_input_stream_read_upto_async(GDataInputStream        *stream, const gchar             *stop_chars, gssize                   stop_chars_len, gint                     io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
char  * g_data_input_stream_read_upto(GDataInputStream        *stream, const gchar             *stop_chars, gssize                   stop_chars_len, gsize                   *length, GCancellable            *cancellable, GError                 **error);
char  * g_data_input_stream_read_until_finish(GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error);
void g_data_input_stream_read_until_async(GDataInputStream        *stream, const gchar             *stop_chars, gint                     io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
char  * g_data_input_stream_read_until(GDataInputStream        *stream, const gchar             *stop_chars, gsize                   *length, GCancellable            *cancellable, GError                 **error);
char  * g_data_input_stream_read_line_finish_utf8(GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error);
char  * g_data_input_stream_read_line_finish(GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error);
void g_data_input_stream_read_line_async(GDataInputStream        *stream, gint                     io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data);
char  * g_data_input_stream_read_line_utf8(GDataInputStream        *stream, gsize                   *length, GCancellable            *cancellable, GError                 **error);
char  * g_data_input_stream_read_line(GDataInputStream        *stream, gsize                   *length, GCancellable            *cancellable, GError                 **error);
guint64 g_data_input_stream_read_uint64(GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error);
gint64 g_data_input_stream_read_int64(GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error);
guint32 g_data_input_stream_read_uint32(GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error);
gint32 g_data_input_stream_read_int32(GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error);
guint16 g_data_input_stream_read_uint16(GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error);
gint16 g_data_input_stream_read_int16(GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error);
guchar g_data_input_stream_read_byte(GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error);
GDataStreamNewlineType g_data_input_stream_get_newline_type(GDataInputStream        *stream);
void g_data_input_stream_set_newline_type(GDataInputStream        *stream, GDataStreamNewlineType   type);
GDataStreamByteOrder g_data_input_stream_get_byte_order(GDataInputStream        *stream);
void g_data_input_stream_set_byte_order(GDataInputStream        *stream, GDataStreamByteOrder     order);
GDataInputStream  * g_data_input_stream_new(GInputStream            *base_stream);
GType g_data_input_stream_get_type(void);
gboolean g_datagram_based_condition_wait(GDatagramBased       *datagram_based, GIOCondition          condition, gint64                timeout, GCancellable         *cancellable, GError              **error);
GIOCondition g_datagram_based_condition_check(GDatagramBased       *datagram_based, GIOCondition          condition);
GSource  * g_datagram_based_create_source(GDatagramBased       *datagram_based, GIOCondition          condition, GCancellable         *cancellable);
gint g_datagram_based_send_messages(GDatagramBased       *datagram_based, GOutputMessage       *messages, guint                 num_messages, gint                  flags, gint64                timeout, GCancellable         *cancellable, GError              **error);
gint g_datagram_based_receive_messages(GDatagramBased       *datagram_based, GInputMessage        *messages, guint                 num_messages, gint                  flags, gint64                timeout, GCancellable         *cancellable, GError              **error);
GType g_datagram_based_get_type(void);
gboolean g_credentials_set_unix_user(GCredentials    *credentials, uid_t           uid, GError         **error);
uid_t g_credentials_get_unix_user(GCredentials    *credentials, GError         **error);
pid_t g_credentials_get_unix_pid(GCredentials    *credentials, GError         **error);
gboolean g_credentials_is_same_user(GCredentials    *credentials, GCredentials    *other_credentials, GError         **error);
void g_credentials_set_native(GCredentials    *credentials, GCredentialsType native_type, gpointer         native);
gpointer g_credentials_get_native(GCredentials    *credentials, GCredentialsType native_type);
gchar            * g_credentials_to_string(GCredentials    *credentials);
GCredentials     * g_credentials_new(void);
GType g_credentials_get_type(void);
GConverter              * g_converter_output_stream_get_converter(GConverterOutputStream *converter_stream);
GOutputStream           * g_converter_output_stream_new(GOutputStream         *base_stream, GConverter            *converter);
GType g_converter_output_stream_get_type(void);
GConverter             * g_converter_input_stream_get_converter(GConverterInputStream *converter_stream);
GInputStream           * g_converter_input_stream_new(GInputStream          *base_stream, GConverter            *converter);
GType g_converter_input_stream_get_type(void);
void g_converter_reset(GConverter       *converter);
GConverterResult g_converter_convert(GConverter       *converter, const void       *inbuf, gsize             inbuf_size, void             *outbuf, gsize             outbuf_size, GConverterFlags   flags, gsize            *bytes_read, gsize            *bytes_written, GError          **error);
GType g_converter_get_type(void);
GList  * g_content_types_get_registered(void);
gchar  ** g_content_type_guess_for_tree(GFile        *root);
gchar  * g_content_type_guess(const gchar  *filename, const guchar *data, gsize         data_size, gboolean     *result_uncertain);
gchar  * g_content_type_from_mime_type(const gchar  *mime_type);
gboolean g_content_type_can_be_executable(const gchar  *type);
gchar  * g_content_type_get_generic_icon_name(const gchar  *type);
GIcon  * g_content_type_get_symbolic_icon(const gchar  *type);
GIcon  * g_content_type_get_icon(const gchar  *type);
gchar  * g_content_type_get_mime_type(const gchar  *type);
gchar  * g_content_type_get_description(const gchar  *type);
gboolean g_content_type_is_unknown(const gchar  *type);
gboolean g_content_type_is_mime_type(const gchar *type, const gchar *mime_type);
gboolean g_content_type_is_a(const gchar  *type, const gchar  *supertype);
gboolean g_content_type_equals(const gchar  *type1, const gchar  *type2);
guint g_charset_converter_get_num_fallbacks(GCharsetConverter *converter);
gboolean g_charset_converter_get_use_fallback(GCharsetConverter *converter);
void g_charset_converter_set_use_fallback(GCharsetConverter *converter, gboolean use_fallback);
GCharsetConverter  * g_charset_converter_new(const gchar  *to_charset, const gchar  *from_charset, GError **error);
GType g_charset_converter_get_type(void);
void g_cancellable_cancel(GCancellable  *cancellable);
void g_cancellable_disconnect(GCancellable  *cancellable, gulong         handler_id);
gulong g_cancellable_connect(GCancellable  *cancellable, GCallback      callback, gpointer       data, GDestroyNotify data_destroy_func);
void g_cancellable_reset(GCancellable  *cancellable);
void g_cancellable_pop_current(GCancellable  *cancellable);
void g_cancellable_push_current(GCancellable  *cancellable);
GCancellable  * g_cancellable_get_current(void);
GSource  * g_cancellable_source_new(GCancellable  *cancellable);
void g_cancellable_release_fd(GCancellable  *cancellable);
gboolean g_cancellable_make_pollfd(GCancellable  *cancellable, GPollFD       *pollfd);
int g_cancellable_get_fd(GCancellable  *cancellable);
gboolean g_cancellable_set_error_if_cancelled(GCancellable  *cancellable, GError       **error);
gboolean g_cancellable_is_cancelled(GCancellable  *cancellable);
GCancellable  * g_cancellable_new(void);
GType g_cancellable_get_type(void);
GBytes  * g_bytes_icon_get_bytes(GBytesIcon *icon);
GIcon  * g_bytes_icon_new(GBytes     *bytes);
GType g_bytes_icon_get_type(void);
void g_buffered_output_stream_set_auto_grow(GBufferedOutputStream *stream, gboolean               auto_grow);
gboolean g_buffered_output_stream_get_auto_grow(GBufferedOutputStream *stream);
void g_buffered_output_stream_set_buffer_size(GBufferedOutputStream *stream, gsize                  size);
gsize g_buffered_output_stream_get_buffer_size(GBufferedOutputStream *stream);
GOutputStream * g_buffered_output_stream_new_sized(GOutputStream         *base_stream, gsize                  size);
GOutputStream * g_buffered_output_stream_new(GOutputStream         *base_stream);
GType g_buffered_output_stream_get_type(void);
int g_buffered_input_stream_read_byte(GBufferedInputStream  *stream, GCancellable          *cancellable, GError               **error);
gssize g_buffered_input_stream_fill_finish(GBufferedInputStream  *stream, GAsyncResult          *result, GError               **error);
void g_buffered_input_stream_fill_async(GBufferedInputStream  *stream, gssize                 count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data);
gssize g_buffered_input_stream_fill(GBufferedInputStream  *stream, gssize                 count, GCancellable          *cancellable, GError               **error);
const void * g_buffered_input_stream_peek_buffer(GBufferedInputStream  *stream, gsize                 *count);
gsize g_buffered_input_stream_peek(GBufferedInputStream  *stream, void                  *buffer, gsize                  offset, gsize                  count);
gsize g_buffered_input_stream_get_available(GBufferedInputStream  *stream);
void g_buffered_input_stream_set_buffer_size(GBufferedInputStream  *stream, gsize                  size);
gsize g_buffered_input_stream_get_buffer_size(GBufferedInputStream  *stream);
GInputStream * g_buffered_input_stream_new_sized(GInputStream          *base_stream, gsize                  size);
GInputStream * g_buffered_input_stream_new(GInputStream          *base_stream);
GType g_buffered_input_stream_get_type(void);
gboolean g_async_result_is_tagged(GAsyncResult  *res, gpointer       source_tag);
gboolean g_async_result_legacy_propagate_error(GAsyncResult  *res, GError       **error);
GObject  * g_async_result_get_source_object(GAsyncResult *res);
gpointer g_async_result_get_user_data(GAsyncResult *res);
GType g_async_result_get_type(void);
GObject  * g_async_initable_new_finish(GAsyncInitable       *initable, GAsyncResult         *res, GError              **error);
void g_async_initable_new_valist_async(GType                 object_type, const gchar          *first_property_name, va_list               var_args, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
void g_async_initable_newv_async(GType                 object_type, guint                 n_parameters, GParameter           *parameters, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
void g_async_initable_new_async(GType                 object_type, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data, const gchar          *first_property_name, ...);
gboolean g_async_initable_init_finish(GAsyncInitable       *initable, GAsyncResult         *res, GError              **error);
void g_async_initable_init_async(GAsyncInitable       *initable, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
GType g_async_initable_get_type(void);
GFile  * g_application_command_line_create_file_for_arg(GApplicationCommandLine   *cmdline, const gchar               *arg);
GVariant  * g_application_command_line_get_platform_data(GApplicationCommandLine   *cmdline);
void g_application_command_line_set_exit_status(GApplicationCommandLine   *cmdline, int                        exit_status);
int g_application_command_line_get_exit_status(GApplicationCommandLine   *cmdline);
void g_application_command_line_printerr(GApplicationCommandLine   *cmdline, const gchar               *format, ...);
void g_application_command_line_print(GApplicationCommandLine   *cmdline, const gchar               *format, ...);
gboolean g_application_command_line_get_is_remote(GApplicationCommandLine   *cmdline);
const gchar  * g_application_command_line_get_cwd(GApplicationCommandLine   *cmdline);
const gchar  * g_application_command_line_getenv(GApplicationCommandLine   *cmdline, const gchar               *name);
const gchar  * const * g_application_command_line_get_environ(GApplicationCommandLine   *cmdline);
GInputStream  * g_application_command_line_get_stdin(GApplicationCommandLine   *cmdline);
GVariantDict  * g_application_command_line_get_options_dict(GApplicationCommandLine   *cmdline);
gchar  ** g_application_command_line_get_arguments(GApplicationCommandLine   *cmdline, int                       *argc);
GType g_application_command_line_get_type(void);
void g_application_unbind_busy_property(GApplication             *application, gpointer                  object, const gchar              *property);
void g_application_bind_busy_property(GApplication             *application, gpointer                  object, const gchar              *property);
void g_application_withdraw_notification(GApplication             *application, const gchar              *id);
void g_application_send_notification(GApplication             *application, const gchar              *id, GNotification            *notification);
gboolean g_application_get_is_busy(GApplication             *application);
void g_application_unmark_busy(GApplication             *application);
void g_application_mark_busy(GApplication             *application);
void g_application_set_default(GApplication             *application);
GApplication  * g_application_get_default(void);
void g_application_quit(GApplication             *application);
int g_application_run(GApplication             *application, int                       argc, char                    **argv);
void g_application_open(GApplication             *application, GFile                   **files, gint                      n_files, const gchar              *hint);
void g_application_activate(GApplication             *application);
void g_application_release(GApplication             *application);
void g_application_hold(GApplication             *application);
gboolean g_application_register(GApplication             *application, GCancellable             *cancellable, GError                  **error);
gboolean g_application_get_is_remote(GApplication             *application);
gboolean g_application_get_is_registered(GApplication             *application);
void g_application_set_option_context_description(GApplication             *application, const gchar              *description);
void g_application_set_option_context_summary(GApplication             *application, const gchar              *summary);
void g_application_set_option_context_parameter_string(GApplication             *application, const gchar              *parameter_string);
void g_application_add_option_group(GApplication             *application, GOptionGroup             *group);
void g_application_add_main_option(GApplication             *application, const char               *long_name, char                      short_name, GOptionFlags              flags, GOptionArg                arg, const char               *description, const char               *arg_description);
void g_application_add_main_option_entries(GApplication             *application, const GOptionEntry       *entries);
void g_application_set_action_group(GApplication             *application, GActionGroup             *action_group);
void g_application_set_resource_base_path(GApplication             *application, const gchar              *resource_path);
const gchar  * g_application_get_resource_base_path(GApplication             *application);
void g_application_set_flags(GApplication             *application, GApplicationFlags         flags);
GApplicationFlags g_application_get_flags(GApplication             *application);
void g_application_set_inactivity_timeout(GApplication             *application, guint                     inactivity_timeout);
guint g_application_get_inactivity_timeout(GApplication             *application);
const gchar  * g_application_get_dbus_object_path(GApplication             *application);
GDBusConnection  * g_application_get_dbus_connection(GApplication             *application);
void g_application_set_application_id(GApplication             *application, const gchar              *application_id);
const gchar  * g_application_get_application_id(GApplication             *application);
GApplication  * g_application_new(const gchar              *application_id, GApplicationFlags         flags);
gboolean g_application_id_is_valid(const gchar              *application_id);
GType g_application_get_type(void);
GAppInfoMonitor  * g_app_info_monitor_get(void);
GType g_app_info_monitor_get_type(void);
void g_app_launch_context_launch_failed(GAppLaunchContext *context, const char *       startup_notify_id);
char  * g_app_launch_context_get_startup_notify_id(GAppLaunchContext *context, GAppInfo          *info, GList             *files);
char  * g_app_launch_context_get_display(GAppLaunchContext *context, GAppInfo          *info, GList             *files);
char  ** g_app_launch_context_get_environment(GAppLaunchContext *context);
void g_app_launch_context_unsetenv(GAppLaunchContext *context, const char        *variable);
void g_app_launch_context_setenv(GAppLaunchContext *context, const char        *variable, const char        *value);
GAppLaunchContext  * g_app_launch_context_new(void);
GType g_app_launch_context_get_type(void);
gboolean g_app_info_launch_default_for_uri_finish(GAsyncResult         *result, GError              **error);
void g_app_info_launch_default_for_uri_async(const char           *uri, GAppLaunchContext    *context, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data);
gboolean g_app_info_launch_default_for_uri(const char              *uri, GAppLaunchContext       *context, GError                 **error);
GAppInfo  * g_app_info_get_default_for_uri_scheme(const char  *uri_scheme);
GAppInfo  * g_app_info_get_default_for_type(const char  *content_type, gboolean     must_support_uris);
void g_app_info_reset_type_associations(const char  *content_type);
GList  * g_app_info_get_fallback_for_type(const gchar *content_type);
GList  * g_app_info_get_recommended_for_type(const gchar *content_type);
GList  * g_app_info_get_all_for_type(const char  *content_type);
GList  * g_app_info_get_all(void);
gboolean g_app_info_set_as_last_used_for_type(GAppInfo             *appinfo, const char           *content_type, GError              **error);
gboolean g_app_info_delete(GAppInfo   *appinfo);
gboolean g_app_info_can_delete(GAppInfo   *appinfo);
const char  ** g_app_info_get_supported_types(GAppInfo             *appinfo);
gboolean g_app_info_remove_supports_type(GAppInfo             *appinfo, const char           *content_type, GError              **error);
gboolean g_app_info_can_remove_supports_type(GAppInfo             *appinfo);
gboolean g_app_info_add_supports_type(GAppInfo             *appinfo, const char           *content_type, GError              **error);
gboolean g_app_info_set_as_default_for_extension(GAppInfo             *appinfo, const char           *extension, GError              **error);
gboolean g_app_info_set_as_default_for_type(GAppInfo             *appinfo, const char           *content_type, GError              **error);
gboolean g_app_info_should_show(GAppInfo             *appinfo);
gboolean g_app_info_launch_uris(GAppInfo             *appinfo, GList                *uris, GAppLaunchContext    *context, GError              **error);
gboolean g_app_info_supports_files(GAppInfo             *appinfo);
gboolean g_app_info_supports_uris(GAppInfo             *appinfo);
gboolean g_app_info_launch(GAppInfo             *appinfo, GList                *files, GAppLaunchContext    *context, GError              **error);
GIcon  * g_app_info_get_icon(GAppInfo             *appinfo);
const char  * g_app_info_get_commandline(GAppInfo             *appinfo);
const char  * g_app_info_get_executable(GAppInfo             *appinfo);
const char  * g_app_info_get_description(GAppInfo             *appinfo);
const char  * g_app_info_get_display_name(GAppInfo             *appinfo);
const char  * g_app_info_get_name(GAppInfo             *appinfo);
const char  * g_app_info_get_id(GAppInfo             *appinfo);
gboolean g_app_info_equal(GAppInfo             *appinfo1, GAppInfo             *appinfo2);
GAppInfo  * g_app_info_dup(GAppInfo             *appinfo);
GAppInfo  * g_app_info_create_from_commandline(const char           *commandline, const char           *application_name, GAppInfoCreateFlags   flags, GError              **error);
GType g_app_info_get_type(void);
void g_action_map_add_action_entries(GActionMap         *action_map, const GActionEntry *entries, gint                n_entries, gpointer            user_data);
void g_action_map_remove_action(GActionMap         *action_map, const gchar        *action_name);
void g_action_map_add_action(GActionMap         *action_map, GAction            *action);
GAction  * g_action_map_lookup_action(GActionMap         *action_map, const gchar        *action_name);
GType g_action_map_get_type(void);
void g_dbus_connection_unexport_action_group(GDBusConnection  *connection, guint             export_id);
guint g_dbus_connection_export_action_group(GDBusConnection  *connection, const gchar      *object_path, GActionGroup     *action_group, GError          **error);
gboolean g_action_group_query_action(GActionGroup        *action_group, const gchar         *action_name, gboolean            *enabled, const GVariantType **parameter_type, const GVariantType **state_type, GVariant           **state_hint, GVariant           **state);
void g_action_group_action_state_changed(GActionGroup *action_group, const gchar  *action_name, GVariant     *state);
void g_action_group_action_enabled_changed(GActionGroup *action_group, const gchar  *action_name, gboolean      enabled);
void g_action_group_action_removed(GActionGroup *action_group, const gchar  *action_name);
void g_action_group_action_added(GActionGroup *action_group, const gchar  *action_name);
void g_action_group_activate_action(GActionGroup *action_group, const gchar  *action_name, GVariant     *parameter);
void g_action_group_change_action_state(GActionGroup *action_group, const gchar  *action_name, GVariant     *value);
GVariant  * g_action_group_get_action_state(GActionGroup *action_group, const gchar  *action_name);
gboolean g_action_group_get_action_enabled(GActionGroup *action_group, const gchar  *action_name);
GVariant  * g_action_group_get_action_state_hint(GActionGroup *action_group, const gchar  *action_name);
const GVariantType  * g_action_group_get_action_state_type(GActionGroup *action_group, const gchar  *action_name);
const GVariantType  * g_action_group_get_action_parameter_type(GActionGroup *action_group, const gchar  *action_name);
gchar  ** g_action_group_list_actions(GActionGroup *action_group);
gboolean g_action_group_has_action(GActionGroup *action_group, const gchar  *action_name);
GType g_action_group_get_type(void);
gchar  * g_action_print_detailed_name(const gchar        *action_name, GVariant           *target_value);
gboolean g_action_parse_detailed_name(const gchar        *detailed_name, gchar             **action_name, GVariant          **target_value, GError            **error);
gboolean g_action_name_is_valid(const gchar        *action_name);
void g_action_activate(GAction            *action, GVariant           *parameter);
void g_action_change_state(GAction            *action, GVariant           *value);
GVariant  * g_action_get_state(GAction            *action);
gboolean g_action_get_enabled(GAction            *action);
GVariant  * g_action_get_state_hint(GAction            *action);
const GVariantType  * g_action_get_state_type(GAction            *action);
const GVariantType  * g_action_get_parameter_type(GAction            *action);
const gchar  * g_action_get_name(GAction            *action);
GType g_action_get_type(void);
